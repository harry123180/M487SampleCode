; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\clk.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\clk.d --feedback=.\obj\template.fed --cpu=Cortex-M4.fp.sp --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M480\Include -I..\..\..\Library\StdDriver\inc -ID:\ARM\RV31\INC -ID:\ARM\CMSIS\Include -D__UVISION_VERSION=531 --omf_browse=.\obj\clk.crf ..\..\..\Library\StdDriver\src\clk.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  CLK_DisableModuleClock PROC
;;;28       */
;;;29     void CLK_DisableCKO(void)
000000  f000021f          AND      r2,r0,#0x1f
;;;30     {
;;;31         /* Disable CKO clock source */
;;;32         CLK_DisableModuleClock(CLKO_MODULE);
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  4a03              LDR      r2,|L1.24|
00000a  0f80              LSRS     r0,r0,#30
00000c  eb020080          ADD      r0,r2,r0,LSL #2
000010  6802              LDR      r2,[r0,#0]
000012  438a              BICS     r2,r2,r1
000014  6002              STR      r2,[r0,#0]
000016  4770              BX       lr
;;;33     }
;;;34     
                          ENDP

                  |L1.24|
                          DCD      0x40000204

                          AREA ||area_number.2||, CODE, READONLY, ALIGN=2

                          EXPORTAS ||area_number.2||, ||.text||
                  CLK_DisableCKO PROC
;;;28       */
;;;29     void CLK_DisableCKO(void)
000000  4801              LDR      r0,|L2.8|
;;;30     {
;;;31         /* Disable CKO clock source */
;;;32         CLK_DisableModuleClock(CLKO_MODULE);
000002  f7ffbffe          B.W      CLK_DisableModuleClock
;;;33     }
;;;34     
                          ENDP

000006  0000              DCW      0x0000
                  |L2.8|
                          DCD      0x57c00006

                          AREA ||area_number.3||, CODE, READONLY, ALIGN=2

                          EXPORTAS ||area_number.3||, ||.text||
                  CLK_SetModuleClock PROC
;;;28       */
;;;29     void CLK_DisableCKO(void)
000000  b5f0              PUSH     {r4-r7,lr}
;;;30     {
;;;31         /* Disable CKO clock source */
;;;32         CLK_DisableModuleClock(CLKO_MODULE);
000002  f4103f7f          TST      r0,#0x3fc00
000006  d02e              BEQ      |L3.102|
000008  f04f4380          MOV      r3,#0x40000000
00000c  f8d331f4          LDR      r3,[r3,#0x1f4]
000010  f8dfc328          LDR      r12,|L3.828|
000014  b2df              UXTB     r7,r3
000016  4bc9              LDR      r3,|L3.828|
000018  f3c04481          UBFX     r4,r0,#18,#2
00001c  3b0c              SUBS     r3,r3,#0xc
00001e  ea6f4590          MVN      r5,r0,LSR #18
000022  f10c0604          ADD      r6,r12,#4
000026  eb030384          ADD      r3,r3,r4,LSL #2
00002a  2f01              CMP      r7,#1
00002c  d002              BEQ      |L3.52|
00002e  2c02              CMP      r4,#2
000030  d00d              BEQ      |L3.78|
000032  e001              B        |L3.56|
                  |L3.52|
000034  2c02              CMP      r4,#2
000036  d002              BEQ      |L3.62|
                  |L3.56|
000038  07ac              LSLS     r4,r5,#30
00003a  d00a              BEQ      |L3.82|
00003c  e00a              B        |L3.84|
                  |L3.62|
00003e  43c3              MVNS     r3,r0
000040  06dc              LSLS     r4,r3,#27
000042  4bbf              LDR      r3,|L3.832|
000044  d006              BEQ      |L3.84|
000046  f000041f          AND      r4,r0,#0x1f
00004a  2c1d              CMP      r4,#0x1d
00004c  d002              BEQ      |L3.84|
                  |L3.78|
00004e  4663              MOV      r3,r12
000050  e000              B        |L3.84|
                  |L3.82|
000052  4633              MOV      r3,r6
                  |L3.84|
000054  681c              LDR      r4,[r3,#0]
000056  f3c02587          UBFX     r5,r0,#10,#8
00005a  f3c01644          UBFX     r6,r0,#5,#5
00005e  40b5              LSLS     r5,r5,r6
000060  43ac              BICS     r4,r4,r5
000062  4314              ORRS     r4,r4,r2
000064  601c              STR      r4,[r3,#0]
                  |L3.102|
000066  0e42              LSRS     r2,r0,#25
000068  0752              LSLS     r2,r2,#29
00006a  d00e              BEQ      |L3.138|
00006c  4bb4              LDR      r3,|L3.832|
00006e  f3c07201          UBFX     r2,r0,#28,#2
000072  3b18              SUBS     r3,r3,#0x18
000074  eb030282          ADD      r2,r3,r2,LSL #2
000078  6813              LDR      r3,[r2,#0]
00007a  f3c06442          UBFX     r4,r0,#25,#3
00007e  f3c05004          UBFX     r0,r0,#20,#5
000082  4084              LSLS     r4,r4,r0
000084  43a3              BICS     r3,r3,r4
000086  430b              ORRS     r3,r3,r1
000088  6013              STR      r3,[r2,#0]
                  |L3.138|
00008a  bdf0              POP      {r4-r7,pc}
;;;33     }
;;;34     
                          ENDP

                  CLK_EnableModuleClock PROC
;;;683      */
;;;684    void CLK_EnableModuleClock(uint32_t u32ModuleIdx)
00008c  f000021f          AND      r2,r0,#0x1f
;;;685    {
;;;686        uint32_t u32tmpVal = 0UL, u32tmpAddr = 0UL;
;;;687    
;;;688        u32tmpVal = (1UL << MODULE_IP_EN_Pos(u32ModuleIdx));
000090  2101              MOVS     r1,#1
000092  4091              LSLS     r1,r1,r2
;;;689        u32tmpAddr = (uint32_t)&CLK->AHBCLK;
000094  4aaa              LDR      r2,|L3.832|
000096  3a24              SUBS     r2,r2,#0x24
;;;690        u32tmpAddr += ((MODULE_APBCLK(u32ModuleIdx) * 4UL));
000098  0f80              LSRS     r0,r0,#30
00009a  eb020080          ADD      r0,r2,r0,LSL #2
;;;691    
;;;692        *(volatile uint32_t *)u32tmpAddr |= u32tmpVal;
00009e  6802              LDR      r2,[r0,#0]
0000a0  430a              ORRS     r2,r2,r1
0000a2  6002              STR      r2,[r0,#0]
;;;693    }
0000a4  4770              BX       lr
;;;694    
                          ENDP

                  CLK_WaitClockReady PROC
;;;959      */
;;;960    uint32_t CLK_WaitClockReady(uint32_t u32ClkMask)
0000a6  b530              PUSH     {r4,r5,lr}
;;;961    {
;;;962        int32_t i32TimeOutCnt = 2160000;
;;;963        uint32_t u32Ret = 1U;
0000a8  2401              MOVS     r4,#1
0000aa  4605              MOV      r5,r0                 ;961
0000ac  49a5              LDR      r1,|L3.836|
;;;964    
;;;965        while((CLK->STATUS & u32ClkMask) != u32ClkMask)
0000ae  07a2              LSLS     r2,r4,#30
0000b0  e005              B        |L3.190|
                  |L3.178|
;;;966        {
;;;967            if(i32TimeOutCnt-- <= 0)
0000b2  1e08              SUBS     r0,r1,#0
0000b4  f1a10101          SUB      r1,r1,#1
0000b8  dc01              BGT      |L3.190|
;;;968            {
;;;969                u32Ret = 0U;
0000ba  2400              MOVS     r4,#0
;;;970                break;
0000bc  e004              B        |L3.200|
                  |L3.190|
0000be  f8d23250          LDR      r3,[r2,#0x250]        ;965
0000c2  ea350003          BICS     r0,r5,r3              ;965
0000c6  d1f4              BNE      |L3.178|
                  |L3.200|
;;;971            }
;;;972        }
;;;973        return u32Ret;
0000c8  4620              MOV      r0,r4
;;;974    }
0000ca  bd30              POP      {r4,r5,pc}
;;;975    
                          ENDP

                  CLK_SetHCLK PROC
;;;331      */
;;;332    void CLK_SetHCLK(uint32_t u32ClkSrc, uint32_t u32ClkDiv)
0000cc  e92d41f0          PUSH     {r4-r8,lr}
;;;333    {
;;;334        uint32_t u32HIRCSTB;
;;;335    
;;;336        /* Read HIRC clock source stable flag */
;;;337        u32HIRCSTB = CLK->STATUS & CLK_STATUS_HIRCSTB_Msk;
0000d0  f04f4480          MOV      r4,#0x40000000
0000d4  4607              MOV      r7,r0                 ;333
0000d6  f8d40250          LDR      r0,[r4,#0x250]
0000da  460e              MOV      r6,r1                 ;333
0000dc  f0000510          AND      r5,r0,#0x10
;;;338    
;;;339        /* Switch to HIRC for Safe. Avoid HCLK too high when applying new divider. */
;;;340        CLK->PWRCTL |= CLK_PWRCTL_HIRCEN_Msk;
0000e0  f8d40200          LDR      r0,[r4,#0x200]
0000e4  f0400004          ORR      r0,r0,#4
0000e8  f8c40200          STR      r0,[r4,#0x200]
;;;341        CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
0000ec  2010              MOVS     r0,#0x10
0000ee  f5047400          ADD      r4,r4,#0x200
0000f2  f7fffffe          BL       CLK_WaitClockReady
;;;342        CLK->CLKSEL0 = (CLK->CLKSEL0 & (~CLK_CLKSEL0_HCLKSEL_Msk)) | CLK_CLKSEL0_HCLKSEL_HIRC;
0000f6  6920              LDR      r0,[r4,#0x10]
0000f8  f0400007          ORR      r0,r0,#7
0000fc  6120              STR      r0,[r4,#0x10]
;;;343    
;;;344        /* Apply new Divider */
;;;345        CLK->CLKDIV0 = (CLK->CLKDIV0 & (~CLK_CLKDIV0_HCLKDIV_Msk)) | u32ClkDiv;
0000fe  6a20              LDR      r0,[r4,#0x20]
000100  f020000f          BIC      r0,r0,#0xf
000104  4330              ORRS     r0,r0,r6
000106  6220              STR      r0,[r4,#0x20]
;;;346    
;;;347        /* Switch HCLK to new HCLK source */
;;;348        CLK->CLKSEL0 = (CLK->CLKSEL0 & (~CLK_CLKSEL0_HCLKSEL_Msk)) | u32ClkSrc;
000108  6920              LDR      r0,[r4,#0x10]
00010a  f0200007          BIC      r0,r0,#7
00010e  4338              ORRS     r0,r0,r7
000110  6120              STR      r0,[r4,#0x10]
000112  f5a47400          SUB      r4,r4,#0x200
;;;349    
;;;350        /* Update System Core Clock */
;;;351        SystemCoreClockUpdate();
000116  f7fffffe          BL       SystemCoreClockUpdate
;;;352    
;;;353        /* Disable HIRC if HIRC is disabled before switching HCLK source */
;;;354        if(u32HIRCSTB == 0UL)
00011a  2d00              CMP      r5,#0
00011c  d105              BNE      |L3.298|
;;;355        {
;;;356            CLK->PWRCTL &= ~CLK_PWRCTL_HIRCEN_Msk;
00011e  f8d40200          LDR      r0,[r4,#0x200]
000122  f0200004          BIC      r0,r0,#4
000126  f8c40200          STR      r0,[r4,#0x200]
                  |L3.298|
;;;357        }
;;;358    }
00012a  e8bd81f0          POP      {r4-r8,pc}
;;;359    
                          ENDP

                  CLK_GetPLLClockFreq PROC
;;;1186     */
;;;1187   uint32_t CLK_GetPLLClockFreq(void)
00012e  b508              PUSH     {r3,lr}
;;;1188   {
;;;1189       uint32_t u32PllFreq = 0UL, u32PllReg;
;;;1190       uint32_t u32FIN, u32NF, u32NR, u32NO;
;;;1191       uint8_t au8NoTbl[4] = {1U, 2U, 2U, 4U};
000130  a185              ADR      r1,|L3.840|
000132  2000              MOVS     r0,#0                 ;1189
000134  6809              LDR      r1,[r1,#0]
;;;1192   
;;;1193       u32PllReg = CLK->PLLCTL;
000136  9100              STR      r1,[sp,#0]
000138  f04f4180          MOV      r1,#0x40000000
00013c  f8d11240          LDR      r1,[r1,#0x240]
;;;1194   
;;;1195       if(u32PllReg & (CLK_PLLCTL_PD_Msk | CLK_PLLCTL_OE_Msk))
000140  f4112fa0          TST      r1,#0x50000
000144  d113              BNE      |L3.366|
;;;1196       {
;;;1197           u32PllFreq = 0UL;           /* PLL is in power down mode or fix low */
;;;1198       }
;;;1199       else if((u32PllReg & CLK_PLLCTL_BP_Msk) == CLK_PLLCTL_BP_Msk)
;;;1200       {
;;;1201           if((u32PllReg & CLK_PLLCTL_PLLSRC_HIRC) == CLK_PLLCTL_PLLSRC_HIRC)
;;;1202           {
;;;1203               u32FIN = __HIRC;    /* PLL source clock from HIRC */
000146  4881              LDR      r0,|L3.844|
000148  038a              LSLS     r2,r1,#14             ;1199
00014a  d410              BMI      |L3.366|
;;;1204           }
;;;1205           else
;;;1206           {
;;;1207               u32FIN = __HXT;     /* PLL source clock from HXT */
;;;1208           }
;;;1209   
;;;1210           u32PllFreq = u32FIN;
;;;1211       }
;;;1212       else
;;;1213       {
;;;1214           if((u32PllReg & CLK_PLLCTL_PLLSRC_HIRC) == CLK_PLLCTL_PLLSRC_HIRC)
;;;1215           {
;;;1216               u32FIN = __HIRC;    /* PLL source clock from HIRC */
;;;1217           }
;;;1218           else
;;;1219           {
;;;1220               u32FIN = __HXT;     /* PLL source clock from HXT */
;;;1221           }
;;;1222           /* PLL is output enabled in normal work mode */
;;;1223           u32NO = au8NoTbl[((u32PllReg & CLK_PLLCTL_OUTDIV_Msk) >> CLK_PLLCTL_OUTDIV_Pos)];
;;;1224           u32NF = ((u32PllReg & CLK_PLLCTL_FBDIV_Msk) >> CLK_PLLCTL_FBDIV_Pos) + 2UL;
00014c  f3c10008          UBFX     r0,r1,#0,#9
000150  f3c13281          UBFX     r2,r1,#14,#2          ;1223
;;;1225           u32NR = ((u32PllReg & CLK_PLLCTL_INDIV_Msk) >> CLK_PLLCTL_INDIV_Pos) + 1UL;
;;;1226   
;;;1227           /* u32FIN is shifted 2 bits to avoid overflow */
;;;1228           u32PllFreq = (((u32FIN >> 2) * u32NF) / (u32NR * u32NO) << 2) * 2UL;
000154  4b7e              LDR      r3,|L3.848|
000156  1c80              ADDS     r0,r0,#2
000158  f81d2002          LDRB     r2,[sp,r2]            ;1223
00015c  f3c12144          UBFX     r1,r1,#9,#5           ;1225
000160  4358              MULS     r0,r3,r0
000162  1c49              ADDS     r1,r1,#1
000164  fb11f102          SMULBB   r1,r1,r2
000168  fbb0f0f1          UDIV     r0,r0,r1
00016c  00c0              LSLS     r0,r0,#3
                  |L3.366|
;;;1229       }
;;;1230   
;;;1231       return u32PllFreq;
;;;1232   }
00016e  bd08              POP      {r3,pc}
;;;1233   
                          ENDP

                  CLK_DisablePLL PROC
;;;941      */
;;;942    void CLK_DisablePLL(void)
000170  f04f4080          MOV      r0,#0x40000000
;;;943    {
;;;944        CLK->PLLCTL |= CLK_PLLCTL_PD_Msk;
000174  f8d01240          LDR      r1,[r0,#0x240]
000178  f4413180          ORR      r1,r1,#0x10000
00017c  f8c01240          STR      r1,[r0,#0x240]
;;;945    }
000180  4770              BX       lr
;;;946    
                          ENDP

                  CLK_EnablePLL PROC
;;;788      */
;;;789    uint32_t CLK_EnablePLL(uint32_t u32PllClkSrc, uint32_t u32PllFreq)
000182  e92d4ff8          PUSH     {r3-r11,lr}
;;;790    {
000186  460e              MOV      r6,r1
000188  4604              MOV      r4,r0
;;;791        uint32_t u32PllSrcClk, u32NR, u32NF, u32NO, u32CLK_SRC, u32PllClk;
;;;792        uint32_t u32Tmp, u32Tmp2, u32Tmp3, u32Min, u32MinNF, u32MinNR, u32MinNO, u32basFreq;
;;;793    
;;;794        /* Disable PLL first to avoid unstable when setting PLL */
;;;795        CLK_DisablePLL();
00018a  f7fffffe          BL       CLK_DisablePLL
;;;796    
;;;797        /* PLL source clock is from HXT */
;;;798        if(u32PllClkSrc == CLK_PLLCTL_PLLSRC_HXT)
;;;799        {
;;;800            /* Enable HXT clock */
;;;801            CLK->PWRCTL |= CLK_PWRCTL_HXTEN_Msk;
;;;802    
;;;803            /* Wait for HXT clock ready */
;;;804            CLK_WaitClockReady(CLK_STATUS_HXTSTB_Msk);
;;;805    
;;;806            /* Select PLL source clock from HXT */
;;;807            u32CLK_SRC = CLK_PLLCTL_PLLSRC_HXT;
;;;808            u32PllSrcClk = __HXT;
;;;809    
;;;810            /* u32NR start from 2 */
;;;811            u32NR = 2UL;
;;;812        }
;;;813    
;;;814        /* PLL source clock is from HIRC */
;;;815        else
;;;816        {
;;;817            /* Enable HIRC clock */
;;;818            CLK->PWRCTL |= CLK_PWRCTL_HIRCEN_Msk;
00018e  f04f4080          MOV      r0,#0x40000000
000192  4d6e              LDR      r5,|L3.844|
000194  f8d01200          LDR      r1,[r0,#0x200]
000198  b1c4              CBZ      r4,|L3.460|
00019a  f0410104          ORR      r1,r1,#4
00019e  f8c01200          STR      r1,[r0,#0x200]
;;;819    
;;;820            /* Wait for HIRC clock ready */
;;;821            CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
0001a2  2010              MOVS     r0,#0x10
0001a4  f7fffffe          BL       CLK_WaitClockReady
;;;822    
;;;823            /* Select PLL source clock from HIRC */
;;;824            u32CLK_SRC = CLK_PLLCTL_PLLSRC_HIRC;
0001a8  f44f2000          MOV      r0,#0x80000
                  |L3.428|
;;;825            u32PllSrcClk = __HIRC;
;;;826    
;;;827            /* u32NR start from 4 when FIN = 22.1184MHz to avoid calculation overflow */
;;;828            u32NR = 4UL;
;;;829        }
;;;830    
;;;831        if((u32PllFreq <= FREQ_500MHZ) && (u32PllFreq >= FREQ_50MHZ))
0001ac  9000              STR      r0,[sp,#0]
0001ae  4869              LDR      r0,|L3.852|
0001b0  4969              LDR      r1,|L3.856|
0001b2  4430              ADD      r0,r0,r6
0001b4  46ab              MOV      r11,r5                ;825
0001b6  4288              CMP      r0,r1
0001b8  d869              BHI      |L3.654|
;;;832        {
;;;833    
;;;834            /* Find best solution */
;;;835            u32Min = (uint32_t) - 1;
;;;836            u32MinNR = 0UL;
0001ba  f04f0900          MOV      r9,#0
0001be  f04f31ff          MOV      r1,#0xffffffff        ;835
;;;837            u32MinNF = 0UL;
0001c2  46cc              MOV      r12,r9
;;;838            u32MinNO = 0UL;
0001c4  464f              MOV      r7,r9
;;;839            u32basFreq = u32PllFreq;
0001c6  46b6              MOV      lr,r6
;;;840    
;;;841            for(u32NO = 1UL; u32NO <= 4UL; u32NO++)
0001c8  2501              MOVS     r5,#1
0001ca  e015              B        |L3.504|
                  |L3.460|
0001cc  f0410101          ORR      r1,r1,#1              ;801
0001d0  f8c01200          STR      r1,[r0,#0x200]        ;801
0001d4  2001              MOVS     r0,#1                 ;804
0001d6  f7fffffe          BL       CLK_WaitClockReady
0001da  2000              MOVS     r0,#0                 ;807
0001dc  e7e6              B        |L3.428|
                  |L3.478|
;;;842            {
;;;843                /* Break when get good results */
;;;844                if (u32Min == 0UL)
0001de  b3d1              CBZ      r1,|L3.598|
;;;845                {
;;;846                    break;
;;;847                }
;;;848    
;;;849                if (u32NO != 3UL)
0001e0  2d03              CMP      r5,#3
0001e2  d035              BEQ      |L3.592|
;;;850                {
;;;851    
;;;852                    if(u32NO == 4UL)
0001e4  2d04              CMP      r5,#4
0001e6  d002              BEQ      |L3.494|
;;;853                    {
;;;854                        u32PllFreq = u32basFreq << 2;
;;;855                    }
;;;856                    else if(u32NO == 2UL)
0001e8  2d02              CMP      r5,#2
0001ea  d105              BNE      |L3.504|
0001ec  e002              B        |L3.500|
                  |L3.494|
0001ee  ea4f068e          LSL      r6,lr,#2              ;854
0001f2  e001              B        |L3.504|
                  |L3.500|
;;;857                    {
;;;858                        u32PllFreq = u32basFreq << 1;
0001f4  ea4f064e          LSL      r6,lr,#1
                  |L3.504|
;;;859                    }
;;;860                    else
;;;861                    {
;;;862                    }
;;;863    
;;;864                    for(u32NR = 2UL; u32NR <= 32UL; u32NR++)
0001f8  2202              MOVS     r2,#2
                  |L3.506|
;;;865                    {
;;;866                        /* Break when get good results */
;;;867                        if (u32Min == 0UL)
0001fa  b349              CBZ      r1,|L3.592|
;;;868                        {
;;;869                            break;
;;;870                        }
;;;871    
;;;872                        u32Tmp = u32PllSrcClk / u32NR;
0001fc  fbbbf0f2          UDIV     r0,r11,r2
;;;873                        if((u32Tmp >= 4000000UL) && (u32Tmp <= 8000000UL))
000200  4b56              LDR      r3,|L3.860|
000202  4c56              LDR      r4,|L3.860|
000204  4403              ADD      r3,r3,r0
000206  4264              RSBS     r4,r4,#0
000208  42a3              CMP      r3,r4
00020a  d81e              BHI      |L3.586|
;;;874                        {
;;;875                            for(u32NF = 2UL; u32NF <= 513UL; u32NF++)
00020c  2402              MOVS     r4,#2
;;;876                            {
;;;877                                /* u32Tmp2 is shifted 2 bits to avoid overflow */
;;;878                                u32Tmp2 = (((u32Tmp * 2UL) >> 2) * u32NF);
00020e  f3c00a5d          UBFX     r10,r0,#1,#30
                  |L3.530|
;;;879    
;;;880                                if((u32Tmp2 >= FREQ_50MHZ) && (u32Tmp2 <= FREQ_125MHZ))
000212  4b50              LDR      r3,|L3.852|
000214  fb0af004          MUL      r0,r10,r4             ;878
000218  eb000803          ADD      r8,r0,r3
00021c  4b50              LDR      r3,|L3.864|
00021e  4598              CMP      r8,r3
000220  d80e              BHI      |L3.576|
;;;881                                {
;;;882                                    u32Tmp3 = (u32Tmp2 > (u32PllFreq>>2)) ? u32Tmp2 - (u32PllFreq>>2) : (u32PllFreq>>2) - u32Tmp2;
000222  ebb00f96          CMP      r0,r6,LSR #2
000226  d902              BLS      |L3.558|
000228  eba00096          SUB      r0,r0,r6,LSR #2
00022c  e001              B        |L3.562|
                  |L3.558|
00022e  ebc00096          RSB      r0,r0,r6,LSR #2
                  |L3.562|
;;;883                                    if(u32Tmp3 < u32Min)
000232  4288              CMP      r0,r1
000234  d204              BCS      |L3.576|
;;;884                                    {
;;;885                                        u32Min = u32Tmp3;
000236  0001              MOVS     r1,r0
;;;886                                        u32MinNR = u32NR;
000238  4691              MOV      r9,r2
;;;887                                        u32MinNF = u32NF;
00023a  46a4              MOV      r12,r4
;;;888                                        u32MinNO = u32NO;
00023c  462f              MOV      r7,r5
;;;889    
;;;890                                        /* Break when get good results */
;;;891                                        if(u32Min == 0UL)
00023e  d004              BEQ      |L3.586|
                  |L3.576|
000240  f2402001          MOV      r0,#0x201             ;875
000244  1c64              ADDS     r4,r4,#1              ;875
000246  4284              CMP      r4,r0                 ;875
000248  d9e3              BLS      |L3.530|
                  |L3.586|
00024a  1c52              ADDS     r2,r2,#1              ;875
00024c  2a20              CMP      r2,#0x20              ;864
00024e  d9d4              BLS      |L3.506|
                  |L3.592|
000250  1c6d              ADDS     r5,r5,#1              ;864
000252  2d04              CMP      r5,#4                 ;841
000254  d9c3              BLS      |L3.478|
                  |L3.598|
;;;892                                        {
;;;893                                            break;
;;;894                                        }
;;;895                                    }
;;;896                                }
;;;897                            }
;;;898                        }
;;;899                    }
;;;900                }
;;;901            }
;;;902    
;;;903            /* Enable and apply new PLL setting. */
;;;904            CLK->PLLCTL = u32CLK_SRC | ((u32MinNO - 1UL) << 14) | ((u32MinNR - 1UL) << 9) | (u32MinNF - 2UL);
000256  4843              LDR      r0,|L3.868|
000258  9900              LDR      r1,[sp,#0]
00025a  eb003087          ADD      r0,r0,r7,LSL #14
00025e  4a42              LDR      r2,|L3.872|
000260  4308              ORRS     r0,r0,r1
000262  eb022149          ADD      r1,r2,r9,LSL #9
000266  4308              ORRS     r0,r0,r1
000268  f1ac0102          SUB      r1,r12,#2
00026c  4308              ORRS     r0,r0,r1
00026e  f04f4180          MOV      r1,#0x40000000
000272  f8c10240          STR      r0,[r1,#0x240]
;;;905    
;;;906            /* Wait for PLL clock stable */
;;;907            CLK_WaitClockReady(CLK_STATUS_PLLSTB_Msk);
000276  2004              MOVS     r0,#4
000278  f7fffffe          BL       CLK_WaitClockReady
;;;908    
;;;909            /* Actual PLL output clock frequency */
;;;910            u32PllClk = u32PllSrcClk / (u32MinNO * (u32MinNR)) * (u32MinNF) * 2UL;
00027c  fb07f709          MUL      r7,r7,r9
000280  fbbbf0f7          UDIV     r0,r11,r7
000284  fb00f00c          MUL      r0,r0,r12
000288  0040              LSLS     r0,r0,#1
;;;911        }
;;;912        else
;;;913        {
;;;914            /* Wrong frequency request. Just return default setting. */
;;;915            /* Apply default PLL setting and return */
;;;916            if(u32PllClkSrc == CLK_PLLCTL_PLLSRC_HXT)
;;;917            {
;;;918                CLK->PLLCTL = CLK_PLLCTL_192MHz_HXT;
;;;919            }
;;;920            else
;;;921            {
;;;922                CLK->PLLCTL = CLK_PLLCTL_192MHz_HIRC;
;;;923            }
;;;924    
;;;925            /* Wait for PLL clock stable */
;;;926            CLK_WaitClockReady(CLK_STATUS_PLLSTB_Msk);
;;;927    
;;;928            /* Actual PLL output clock frequency */
;;;929            u32PllClk = CLK_GetPLLClockFreq();
;;;930        }
;;;931    
;;;932        return u32PllClk;
;;;933    }
00028a  e8bd8ff8          POP      {r3-r11,pc}
                  |L3.654|
00028e  b154              CBZ      r4,|L3.678|
000290  4936              LDR      r1,|L3.876|
                  |L3.658|
000292  f04f4080          MOV      r0,#0x40000000        ;922
000296  f8c01240          STR      r1,[r0,#0x240]        ;922
00029a  2004              MOVS     r0,#4                 ;926
00029c  f7fffffe          BL       CLK_WaitClockReady
0002a0  e8bd4ff8          POP      {r3-r11,lr}           ;929
0002a4  e7fe              B        CLK_GetPLLClockFreq
                  |L3.678|
0002a6  f244211e          MOV      r1,#0x421e            ;918
0002aa  e7f2              B        |L3.658|
;;;934    
                          ENDP

                  CLK_SetCoreClock PROC
;;;269      */
;;;270    uint32_t CLK_SetCoreClock(uint32_t u32Hclk)
0002ac  b570              PUSH     {r4-r6,lr}
;;;271    {
;;;272        uint32_t u32HIRCSTB;
;;;273    
;;;274        /* Read HIRC clock source stable flag */
;;;275        u32HIRCSTB = CLK->STATUS & CLK_STATUS_HIRCSTB_Msk;
0002ae  f04f4480          MOV      r4,#0x40000000
0002b2  4606              MOV      r6,r0                 ;271
0002b4  f8d40250          LDR      r0,[r4,#0x250]
0002b8  f0000510          AND      r5,r0,#0x10
;;;276    
;;;277        /* The range of u32Hclk is running up to 192 MHz */
;;;278        if(u32Hclk > FREQ_192MHZ)
0002bc  482c              LDR      r0,|L3.880|
0002be  4286              CMP      r6,r0
0002c0  d900              BLS      |L3.708|
;;;279        {
;;;280            u32Hclk = FREQ_192MHZ;
0002c2  4606              MOV      r6,r0
                  |L3.708|
;;;281        }
;;;282    
;;;283        /* Switch HCLK clock source to HIRC clock for safe */
;;;284        CLK->PWRCTL |= CLK_PWRCTL_HIRCEN_Msk;
0002c4  f8d40200          LDR      r0,[r4,#0x200]
0002c8  f0400004          ORR      r0,r0,#4
0002cc  f8c40200          STR      r0,[r4,#0x200]
;;;285        CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
0002d0  2010              MOVS     r0,#0x10
0002d2  f5047400          ADD      r4,r4,#0x200
0002d6  f7fffffe          BL       CLK_WaitClockReady
;;;286        CLK->CLKSEL0 |= CLK_CLKSEL0_HCLKSEL_Msk;
0002da  6920              LDR      r0,[r4,#0x10]
0002dc  f0400007          ORR      r0,r0,#7
0002e0  6120              STR      r0,[r4,#0x10]
;;;287        CLK->CLKDIV0 &= (~CLK_CLKDIV0_HCLKDIV_Msk);
0002e2  6a20              LDR      r0,[r4,#0x20]
0002e4  f020000f          BIC      r0,r0,#0xf
0002e8  6220              STR      r0,[r4,#0x20]
;;;288    
;;;289        /* Configure PLL setting if HXT clock is enabled */
;;;290        if((CLK->PWRCTL & CLK_PWRCTL_HXTEN_Msk) == CLK_PWRCTL_HXTEN_Msk)
0002ea  6820              LDR      r0,[r4,#0]
0002ec  f5a47400          SUB      r4,r4,#0x200
0002f0  07c0              LSLS     r0,r0,#31
;;;291        {
;;;292            u32Hclk = CLK_EnablePLL(CLK_PLLCTL_PLLSRC_HXT, u32Hclk);
;;;293        }
;;;294        /* Configure PLL setting if HXT clock is not enabled */
;;;295        else
;;;296        {
;;;297            u32Hclk = CLK_EnablePLL(CLK_PLLCTL_PLLSRC_HIRC, u32Hclk);
0002f2  4631              MOV      r1,r6
0002f4  d004              BEQ      |L3.768|
0002f6  2000              MOVS     r0,#0                 ;292
0002f8  f7fffffe          BL       CLK_EnablePLL
0002fc  4606              MOV      r6,r0                 ;292
0002fe  e008              B        |L3.786|
                  |L3.768|
000300  f44f2000          MOV      r0,#0x80000
000304  f7fffffe          BL       CLK_EnablePLL
000308  4606              MOV      r6,r0
;;;298    
;;;299            /* Read HIRC clock source stable flag */
;;;300            u32HIRCSTB = CLK->STATUS & CLK_STATUS_HIRCSTB_Msk;
00030a  f8d40250          LDR      r0,[r4,#0x250]
00030e  f0000510          AND      r5,r0,#0x10
                  |L3.786|
;;;301        }
;;;302    
;;;303        /* Select HCLK clock source to PLL,
;;;304           and update system core clock
;;;305        */
;;;306        CLK_SetHCLK(CLK_CLKSEL0_HCLKSEL_PLL, CLK_CLKDIV0_HCLK(1UL));
000312  2100              MOVS     r1,#0
000314  2002              MOVS     r0,#2
000316  f7fffffe          BL       CLK_SetHCLK
;;;307    
;;;308        /* Disable HIRC if HIRC is disabled before setting core clock */
;;;309        if(u32HIRCSTB == 0UL)
00031a  b92d              CBNZ     r5,|L3.808|
;;;310        {
;;;311            CLK->PWRCTL &= ~CLK_PWRCTL_HIRCEN_Msk;
00031c  f8d40200          LDR      r0,[r4,#0x200]
000320  f0200004          BIC      r0,r0,#4
000324  f8c40200          STR      r0,[r4,#0x200]
                  |L3.808|
;;;312        }
;;;313    
;;;314        /* Return actually HCLK frequency is PLL frequency divide 1 */
;;;315        return u32Hclk;
000328  4630              MOV      r0,r6
;;;316    }
00032a  bd70              POP      {r4-r6,pc}
;;;317    
                          ENDP

                  CLK_EnableXtalRC PROC
;;;590      */
;;;591    void CLK_EnableXtalRC(uint32_t u32ClkMask)
00032c  f04f4180          MOV      r1,#0x40000000
;;;592    {
;;;593        CLK->PWRCTL |= u32ClkMask;
000330  f8d12200          LDR      r2,[r1,#0x200]
000334  4302              ORRS     r2,r2,r0
000336  f8c12200          STR      r2,[r1,#0x200]
;;;594    }
00033a  4770              BX       lr
;;;595    
                          ENDP

                  |L3.828|
                          DCD      0x4000022c
                  |L3.832|
                          DCD      0x40000228
                  |L3.836|
                          DCD      0x0020f580
                  |L3.840|
000348  01020204          DCB      1,2,2,4
                  |L3.844|
                          DCD      0x00b71b00
                  |L3.848|
                          DCD      0x002dc6c0
                  |L3.852|
                          DCD      0xfd050f80
                  |L3.856|
                          DCD      0x1ad27480
                  |L3.860|
                          DCD      0xffc2f700
                  |L3.864|
                          DCD      0x047868c0
                  |L3.868|
                          DCD      0xffffc000
                  |L3.872|
                          DCD      0xfffffe00
                  |L3.876|
                          DCD      0x0008421e
                  |L3.880|
                          DCD      0x0b71b000

                          AREA ||area_number.4||, CODE, READONLY, ALIGN=2

                          EXPORTAS ||area_number.4||, ||.text||
                  CLK_EnableCKO PROC
;;;606      */
;;;607    void CLK_DisableXtalRC(uint32_t u32ClkMask)
000000  4603              MOV      r3,r0
;;;608    {
;;;609        CLK->PWRCTL &= ~u32ClkMask;
000002  ea411042          ORR      r0,r1,r2,LSL #5
000006  b510              PUSH     {r4,lr}
000008  f04f4280          MOV      r2,#0x40000000
00000c  f0400110          ORR      r1,r0,#0x10
;;;610    }
000010  f8c21260          STR      r1,[r2,#0x260]
000014  4c05              LDR      r4,|L4.44|
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       CLK_EnableModuleClock
00001c  4620              MOV      r0,r4
00001e  e8bd4010          POP      {r4,lr}
000022  2200              MOVS     r2,#0
000024  4619              MOV      r1,r3
000026  f7ffbffe          B.W      CLK_SetModuleClock
;;;611    
                          ENDP

00002a  0000              DCW      0x0000
                  |L4.44|
                          DCD      0x57c00006

                          AREA ||area_number.5||, CODE, READONLY, ALIGN=2

                          EXPORTAS ||area_number.5||, ||.text||
                  CLK_PowerDown PROC
;;;606      */
;;;607    void CLK_DisableXtalRC(uint32_t u32ClkMask)
000000  480a              LDR      r0,|L5.44|
;;;608    {
;;;609        CLK->PWRCTL &= ~u32ClkMask;
000002  6801              LDR      r1,[r0,#0]
000004  f0410104          ORR      r1,r1,#4
000008  6001              STR      r1,[r0,#0]
00000a  0680              LSLS     r0,r0,#26
00000c  f8d01200          LDR      r1,[r0,#0x200]
;;;610    }
000010  f0410180          ORR      r1,r1,#0x80
000014  f8c01200          STR      r1,[r0,#0x200]
000018  f8501ff0          LDR      r1,[r0,#0xf0]!
00001c  6802              LDR      r2,[r0,#0]
00001e  f0220203          BIC      r2,r2,#3
000022  6002              STR      r2,[r0,#0]
000024  bf30              WFI      
000026  6001              STR      r1,[r0,#0]
000028  4770              BX       lr
;;;611    
                          ENDP

00002a  0000              DCW      0x0000
                  |L5.44|
                          DCD      0xe000ed10

                          AREA ||area_number.6||, CODE, READONLY, ALIGN=2

                          EXPORTAS ||area_number.6||, ||.text||
                  CLK_Idle PROC
;;;606      */
;;;607    void CLK_DisableXtalRC(uint32_t u32ClkMask)
000000  4806              LDR      r0,|L6.28|
;;;608    {
;;;609        CLK->PWRCTL &= ~u32ClkMask;
000002  6801              LDR      r1,[r0,#0]
000004  f0210104          BIC      r1,r1,#4
000008  6001              STR      r1,[r0,#0]
00000a  0680              LSLS     r0,r0,#26
00000c  f8d01200          LDR      r1,[r0,#0x200]
;;;610    }
000010  f0210180          BIC      r1,r1,#0x80
000014  f8c01200          STR      r1,[r0,#0x200]
000018  bf30              WFI      
00001a  4770              BX       lr
;;;611    
                          ENDP

                  |L6.28|
                          DCD      0xe000ed10

                          AREA ||area_number.7||, CODE, READONLY, ALIGN=2

                          EXPORTAS ||area_number.7||, ||.text||
                  CLK_GetHXTFreq PROC
;;;606      */
;;;607    void CLK_DisableXtalRC(uint32_t u32ClkMask)
000000  f04f4080          MOV      r0,#0x40000000
;;;608    {
;;;609        CLK->PWRCTL &= ~u32ClkMask;
000004  f8d00200          LDR      r0,[r0,#0x200]
000008  07c0              LSLS     r0,r0,#31
00000a  d000              BEQ      |L7.14|
00000c  4800              LDR      r0,|L7.16|
                  |L7.14|
;;;610    }
00000e  4770              BX       lr
;;;611    
                          ENDP

                  |L7.16|
                          DCD      0x00b71b00

                          AREA ||area_number.8||, CODE, READONLY, ALIGN=1

                          EXPORTAS ||area_number.8||, ||.text||
                  CLK_GetLXTFreq PROC
;;;606      */
;;;607    void CLK_DisableXtalRC(uint32_t u32ClkMask)
000000  f04f4080          MOV      r0,#0x40000000
;;;608    {
;;;609        CLK->PWRCTL &= ~u32ClkMask;
000004  f8d00200          LDR      r0,[r0,#0x200]
000008  0780              LSLS     r0,r0,#30
00000a  d502              BPL      |L8.18|
00000c  f44f4000          MOV      r0,#0x8000
;;;610    }
000010  4770              BX       lr
                  |L8.18|
000012  2000              MOVS     r0,#0
000014  4770              BX       lr
;;;611    
                          ENDP


                          AREA ||area_number.9||, CODE, READONLY, ALIGN=2

                          EXPORTAS ||area_number.9||, ||.text||
                  CLK_GetPCLK0Freq PROC
;;;606      */
;;;607    void CLK_DisableXtalRC(uint32_t u32ClkMask)
000000  b510              PUSH     {r4,lr}
;;;608    {
;;;609        CLK->PWRCTL &= ~u32ClkMask;
000002  f7fffffe          BL       SystemCoreClockUpdate
000006  f04f4180          MOV      r1,#0x40000000
00000a  f8d10234          LDR      r0,[r1,#0x234]
;;;610    }
00000e  0742              LSLS     r2,r0,#29
000010  4813              LDR      r0,|L9.96|
000012  d017              BEQ      |L9.68|
000014  f8d12234          LDR      r2,[r1,#0x234]
000018  f0020207          AND      r2,r2,#7
00001c  2a01              CMP      r2,#1
00001e  d013              BEQ      |L9.72|
000020  f8d12234          LDR      r2,[r1,#0x234]
000024  f0020207          AND      r2,r2,#7
000028  2a02              CMP      r2,#2
00002a  d010              BEQ      |L9.78|
00002c  f8d12234          LDR      r2,[r1,#0x234]
000030  f0020207          AND      r2,r2,#7
000034  2a03              CMP      r2,#3
000036  d00d              BEQ      |L9.84|
000038  f8d11234          LDR      r1,[r1,#0x234]
00003c  f0010107          AND      r1,r1,#7
000040  2904              CMP      r1,#4
000042  d00a              BEQ      |L9.90|
                  |L9.68|
000044  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000046  bd10              POP      {r4,pc}
                  |L9.72|
000048  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00004a  0840              LSRS     r0,r0,#1
00004c  bd10              POP      {r4,pc}
                  |L9.78|
00004e  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000050  0880              LSRS     r0,r0,#2
000052  bd10              POP      {r4,pc}
                  |L9.84|
000054  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000056  08c0              LSRS     r0,r0,#3
000058  bd10              POP      {r4,pc}
                  |L9.90|
00005a  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00005c  0900              LSRS     r0,r0,#4
00005e  bd10              POP      {r4,pc}
;;;611    
                          ENDP

                  |L9.96|
                          DCD      SystemCoreClock

                          AREA ||area_number.10||, CODE, READONLY, ALIGN=2

                          EXPORTAS ||area_number.10||, ||.text||
                  CLK_GetPCLK1Freq PROC
;;;606      */
;;;607    void CLK_DisableXtalRC(uint32_t u32ClkMask)
000000  b510              PUSH     {r4,lr}
;;;608    {
;;;609        CLK->PWRCTL &= ~u32ClkMask;
000002  f7fffffe          BL       SystemCoreClockUpdate
000006  f04f4180          MOV      r1,#0x40000000
00000a  f8d10234          LDR      r0,[r1,#0x234]
;;;610    }
00000e  f0100f70          TST      r0,#0x70
000012  4814              LDR      r0,|L10.100|
000014  d017              BEQ      |L10.70|
000016  f8d12234          LDR      r2,[r1,#0x234]
00001a  f3c21202          UBFX     r2,r2,#4,#3
00001e  2a01              CMP      r2,#1
000020  d013              BEQ      |L10.74|
000022  f8d12234          LDR      r2,[r1,#0x234]
000026  f3c21202          UBFX     r2,r2,#4,#3
00002a  2a02              CMP      r2,#2
00002c  d010              BEQ      |L10.80|
00002e  f8d12234          LDR      r2,[r1,#0x234]
000032  f3c21202          UBFX     r2,r2,#4,#3
000036  2a03              CMP      r2,#3
000038  d00d              BEQ      |L10.86|
00003a  f8d11234          LDR      r1,[r1,#0x234]
00003e  f3c11102          UBFX     r1,r1,#4,#3
000042  2904              CMP      r1,#4
000044  d00a              BEQ      |L10.92|
                  |L10.70|
000046  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000048  bd10              POP      {r4,pc}
                  |L10.74|
00004a  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00004c  0840              LSRS     r0,r0,#1
00004e  bd10              POP      {r4,pc}
                  |L10.80|
000050  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000052  0880              LSRS     r0,r0,#2
000054  bd10              POP      {r4,pc}
                  |L10.86|
000056  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000058  08c0              LSRS     r0,r0,#3
00005a  bd10              POP      {r4,pc}
                  |L10.92|
00005c  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00005e  0900              LSRS     r0,r0,#4
000060  bd10              POP      {r4,pc}
;;;611    
                          ENDP

000062  0000              DCW      0x0000
                  |L10.100|
                          DCD      SystemCoreClock

                          AREA ||area_number.11||, CODE, READONLY, ALIGN=2

                          EXPORTAS ||area_number.11||, ||.text||
                  CLK_GetHCLKFreq PROC
;;;606      */
;;;607    void CLK_DisableXtalRC(uint32_t u32ClkMask)
000000  b510              PUSH     {r4,lr}
;;;608    {
;;;609        CLK->PWRCTL &= ~u32ClkMask;
000002  f7fffffe          BL       SystemCoreClockUpdate
000006  4801              LDR      r0,|L11.12|
000008  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00000a  bd10              POP      {r4,pc}
;;;610    }
;;;611    
                          ENDP

                  |L11.12|
                          DCD      SystemCoreClock

                          AREA ||area_number.12||, CODE, READONLY, ALIGN=2

                          EXPORTAS ||area_number.12||, ||.text||
                  CLK_GetCPUFreq PROC
;;;606      */
;;;607    void CLK_DisableXtalRC(uint32_t u32ClkMask)
000000  b510              PUSH     {r4,lr}
;;;608    {
;;;609        CLK->PWRCTL &= ~u32ClkMask;
000002  f7fffffe          BL       SystemCoreClockUpdate
000006  4801              LDR      r0,|L12.12|
000008  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00000a  bd10              POP      {r4,pc}
;;;610    }
;;;611    
                          ENDP

                  |L12.12|
                          DCD      SystemCoreClock

                          AREA ||area_number.13||, CODE, READONLY, ALIGN=1

                          EXPORTAS ||area_number.13||, ||.text||
                  CLK_SetSysTickClockSrc PROC
;;;606      */
;;;607    void CLK_DisableXtalRC(uint32_t u32ClkMask)
000000  f04f4180          MOV      r1,#0x40000000
;;;608    {
;;;609        CLK->PWRCTL &= ~u32ClkMask;
000004  f8d12210          LDR      r2,[r1,#0x210]
000008  f0220238          BIC      r2,r2,#0x38
00000c  4302              ORRS     r2,r2,r0
;;;610    }
00000e  f8c12210          STR      r2,[r1,#0x210]
000012  4770              BX       lr
;;;611    
                          ENDP


                          AREA ||area_number.14||, CODE, READONLY, ALIGN=1

                          EXPORTAS ||area_number.14||, ||.text||
                  CLK_DisableXtalRC PROC
;;;606      */
;;;607    void CLK_DisableXtalRC(uint32_t u32ClkMask)
000000  f04f4180          MOV      r1,#0x40000000
;;;608    {
;;;609        CLK->PWRCTL &= ~u32ClkMask;
000004  f8d12200          LDR      r2,[r1,#0x200]
000008  4382              BICS     r2,r2,r0
00000a  f8c12200          STR      r2,[r1,#0x200]
;;;610    }
00000e  4770              BX       lr
;;;611    
                          ENDP


                          AREA ||area_number.15||, CODE, READONLY, ALIGN=1

                          EXPORTAS ||area_number.15||, ||.text||
                  CLK_EnableSysTick PROC
;;;606      */
;;;607    void CLK_DisableXtalRC(uint32_t u32ClkMask)
000000  b530              PUSH     {r4,r5,lr}
;;;608    {
;;;609        CLK->PWRCTL &= ~u32ClkMask;
000002  f04f22e0          MOV      r2,#0xe000e000
000006  2500              MOVS     r5,#0
000008  6115              STR      r5,[r2,#0x10]
00000a  2804              CMP      r0,#4
00000c  d00f              BEQ      |L15.46|
;;;610    }
00000e  f04f4380          MOV      r3,#0x40000000
000012  f8d34210          LDR      r4,[r3,#0x210]
000016  f0240438          BIC      r4,r4,#0x38
00001a  4304              ORRS     r4,r4,r0
00001c  f8c34210          STR      r4,[r3,#0x210]
                  |L15.32|
000020  6151              STR      r1,[r2,#0x14]
000022  6195              STR      r5,[r2,#0x18]
000024  6910              LDR      r0,[r2,#0x10]
000026  f0400003          ORR      r0,r0,#3
00002a  6110              STR      r0,[r2,#0x10]
00002c  bd30              POP      {r4,r5,pc}
                  |L15.46|
00002e  6910              LDR      r0,[r2,#0x10]
000030  f0400004          ORR      r0,r0,#4
000034  6110              STR      r0,[r2,#0x10]
000036  e7f3              B        |L15.32|
;;;611    
                          ENDP


                          AREA ||area_number.16||, CODE, READONLY, ALIGN=1

                          EXPORTAS ||area_number.16||, ||.text||
                  CLK_DisableSysTick PROC
;;;606      */
;;;607    void CLK_DisableXtalRC(uint32_t u32ClkMask)
000000  f04f21e0          MOV      r1,#0xe000e000
;;;608    {
;;;609        CLK->PWRCTL &= ~u32ClkMask;
000004  2000              MOVS     r0,#0
000006  6108              STR      r0,[r1,#0x10]
000008  4770              BX       lr
;;;610    }
;;;611    
                          ENDP


                          AREA ||area_number.17||, CODE, READONLY, ALIGN=1

                          EXPORTAS ||area_number.17||, ||.text||
                  CLK_SetPowerDownMode PROC
;;;606      */
;;;607    void CLK_DisableXtalRC(uint32_t u32ClkMask)
000000  b530              PUSH     {r4,r5,lr}
;;;608    {
;;;609        CLK->PWRCTL &= ~u32ClkMask;
000002  f04f4580          MOV      r5,#0x40000000
000006  4604              MOV      r4,r0
000008  f8d501f4          LDR      r0,[r5,#0x1f4]
00000c  b2c0              UXTB     r0,r0
;;;610    }
00000e  2801              CMP      r0,#1
000010  d004              BEQ      |L17.28|
000012  2c04              CMP      r4,#4
000014  d016              BEQ      |L17.68|
000016  2c05              CMP      r4,#5
000018  d014              BEQ      |L17.68|
00001a  e01c              B        |L17.86|
                  |L17.28|
00001c  2c04              CMP      r4,#4
00001e  d002              BEQ      |L17.38|
000020  2c05              CMP      r4,#5
000022  d007              BEQ      |L17.52|
000024  e017              B        |L17.86|
                  |L17.38|
000026  f8d50290          LDR      r0,[r5,#0x290]
00002a  f0200070          BIC      r0,r0,#0x70
00002e  f0400010          ORR      r0,r0,#0x10
000032  e004              B        |L17.62|
                  |L17.52|
000034  f8d50290          LDR      r0,[r5,#0x290]
000038  2404              MOVS     r4,#4
00003a  f0200070          BIC      r0,r0,#0x70
                  |L17.62|
00003e  f8c50290          STR      r0,[r5,#0x290]
000042  e008              B        |L17.86|
                  |L17.68|
000044  f8d50200          LDR      r0,[r5,#0x200]
000048  f0400008          ORR      r0,r0,#8
00004c  f8c50200          STR      r0,[r5,#0x200]
000050  2008              MOVS     r0,#8
000052  f7fffffe          BL       CLK_WaitClockReady
                  |L17.86|
000056  f8d50290          LDR      r0,[r5,#0x290]
00005a  f0200007          BIC      r0,r0,#7
00005e  4320              ORRS     r0,r0,r4
000060  f8c50290          STR      r0,[r5,#0x290]
000064  bd30              POP      {r4,r5,pc}
;;;611    
                          ENDP


                          AREA ||area_number.18||, CODE, READONLY, ALIGN=1

                          EXPORTAS ||area_number.18||, ||.text||
                  CLK_EnableDPDWKPin PROC
;;;606      */
;;;607    void CLK_DisableXtalRC(uint32_t u32ClkMask)
000000  f04f4180          MOV      r1,#0x40000000
;;;608    {
;;;609        CLK->PWRCTL &= ~u32ClkMask;
000004  f8d121f4          LDR      r2,[r1,#0x1f4]
000008  b2d2              UXTB     r2,r2
00000a  f8d12290          LDR      r2,[r1,#0x290]
;;;610    }
00000e  f4223240          BIC      r2,r2,#0x30000
000012  4302              ORRS     r2,r2,r0
000014  f8c12290          STR      r2,[r1,#0x290]
000018  4770              BX       lr
;;;611    
                          ENDP


                          AREA ||area_number.19||, CODE, READONLY, ALIGN=1

                          EXPORTAS ||area_number.19||, ||.text||
                  CLK_GetPMUWKSrc PROC
;;;606      */
;;;607    void CLK_DisableXtalRC(uint32_t u32ClkMask)
000000  f04f4080          MOV      r0,#0x40000000
;;;608    {
;;;609        CLK->PWRCTL &= ~u32ClkMask;
000004  f8d00294          LDR      r0,[r0,#0x294]
000008  4770              BX       lr
;;;610    }
;;;611    
                          ENDP


                          AREA ||area_number.20||, CODE, READONLY, ALIGN=2

                          EXPORTAS ||area_number.20||, ||.text||
                  CLK_EnableSPDWKPin PROC
;;;606      */
;;;607    void CLK_DisableXtalRC(uint32_t u32ClkMask)
000000  b530              PUSH     {r4,r5,lr}
;;;608    {
;;;609        CLK->PWRCTL &= ~u32ClkMask;
000002  4c07              LDR      r4,|L20.32|
000004  eb040080          ADD      r0,r4,r0,LSL #2
000008  6804              LDR      r4,[r0,#0]
00000a  f24015f7          MOV      r5,#0x1f7
;;;610    }
00000e  43ac              BICS     r4,r4,r5
000010  ea441101          ORR      r1,r4,r1,LSL #4
000014  4311              ORRS     r1,r1,r2
000016  4319              ORRS     r1,r1,r3
000018  f0410101          ORR      r1,r1,#1
00001c  6001              STR      r1,[r0,#0]
00001e  bd30              POP      {r4,r5,pc}
;;;611    
                          ENDP

                  |L20.32|
                          DCD      0x400002a0

                          AREA ||area_number.21||, CODE, READONLY, ALIGN=2

                          EXPORTAS ||area_number.21||, ||.text||
                  CLK_GetModuleClockSource PROC
;;;606      */
;;;607    void CLK_DisableXtalRC(uint32_t u32ClkMask)
000000  b51f              PUSH     {r0-r4,lr}
;;;608    {
;;;609        CLK->PWRCTL &= ~u32ClkMask;
000002  491d              LDR      r1,|L21.120|
000004  c91e              LDM      r1,{r1-r4}
000006  e88d001e          STM      sp,{r1-r4}
00000a  4a1c              LDR      r2,|L21.124|
00000c  0691              LSLS     r1,r2,#26
;;;610    }
00000e  4290              CMP      r0,r2
000010  d105              BNE      |L21.30|
000012  f8d10218          LDR      r0,[r1,#0x218]
000016  f0000001          AND      r0,r0,#1
                  |L21.26|
00001a  b004              ADD      sp,sp,#0x10
00001c  bd10              POP      {r4,pc}
                  |L21.30|
00001e  4a18              LDR      r2,|L21.128|
000020  4290              CMP      r0,r2
000022  d104              BNE      |L21.46|
000024  f8d10218          LDR      r0,[r1,#0x218]
000028  f3c00040          UBFX     r0,r0,#1,#1
00002c  e7f5              B        |L21.26|
                  |L21.46|
00002e  4a15              LDR      r2,|L21.132|
000030  4290              CMP      r0,r2
000032  d104              BNE      |L21.62|
000034  f8d10218          LDR      r0,[r1,#0x218]
000038  f3c02000          UBFX     r0,r0,#8,#1
00003c  e7ed              B        |L21.26|
                  |L21.62|
00003e  4a12              LDR      r2,|L21.136|
000040  4290              CMP      r0,r2
000042  d104              BNE      |L21.78|
000044  f8d10218          LDR      r0,[r1,#0x218]
000048  f3c02040          UBFX     r0,r0,#9,#1
00004c  e7e5              B        |L21.26|
                  |L21.78|
00004e  0e41              LSRS     r1,r0,#25
000050  0749              LSLS     r1,r1,#29
000052  d00e              BEQ      |L21.114|
000054  f3c07201          UBFX     r2,r0,#28,#2
000058  f85d1022          LDR      r1,[sp,r2,LSL #2]
00005c  4a0b              LDR      r2,|L21.140|
00005e  5889              LDR      r1,[r1,r2]
000060  f3c06242          UBFX     r2,r0,#25,#3
000064  f3c05004          UBFX     r0,r0,#20,#5
000068  4082              LSLS     r2,r2,r0
00006a  4011              ANDS     r1,r1,r2
00006c  fa21f000          LSR      r0,r1,r0
000070  e7d3              B        |L21.26|
                  |L21.114|
000072  2000              MOVS     r0,#0
000074  e7d1              B        |L21.26|
;;;611    
                          ENDP

000076  0000              DCW      0x0000
                  |L21.120|
                          DCD      ||.constdata||
                  |L21.124|
                          DCD      0xa2000010
                  |L21.128|
                          DCD      0xa2100011
                  |L21.132|
                          DCD      0xa2800012
                  |L21.136|
                          DCD      0xa2900013
                  |L21.140|
                          DCD      0x40000210

                          AREA ||area_number.22||, CODE, READONLY, ALIGN=2

                          EXPORTAS ||area_number.22||, ||.text||
                  CLK_GetModuleClockDivider PROC
;;;606      */
;;;607    void CLK_DisableXtalRC(uint32_t u32ClkMask)
000000  b51f              PUSH     {r0-r4,lr}
;;;608    {
;;;609        CLK->PWRCTL &= ~u32ClkMask;
000002  4914              LDR      r1,|L22.84|
000004  f4103f7f          TST      r0,#0x3fc00
000008  c91e              LDM      r1,{r1-r4}
00000a  e88d001e          STM      sp,{r1-r4}
;;;610    }
00000e  d01f              BEQ      |L22.80|
000010  f3c04281          UBFX     r2,r0,#18,#2
000014  f85d1022          LDR      r1,[sp,r2,LSL #2]
000018  4a0f              LDR      r2,|L22.88|
00001a  4411              ADD      r1,r1,r2
00001c  0652              LSLS     r2,r2,#25
00001e  f8d221f4          LDR      r2,[r2,#0x1f4]
000022  b2d2              UXTB     r2,r2
000024  2a01              CMP      r2,#1
000026  d108              BNE      |L22.58|
000028  43c2              MVNS     r2,r0
00002a  4b0c              LDR      r3,|L22.92|
00002c  06d2              LSLS     r2,r2,#27
00002e  d003              BEQ      |L22.56|
000030  f000021f          AND      r2,r0,#0x1f
000034  2a1d              CMP      r2,#0x1d
000036  d100              BNE      |L22.58|
                  |L22.56|
000038  4619              MOV      r1,r3
                  |L22.58|
00003a  6809              LDR      r1,[r1,#0]
00003c  f3c02287          UBFX     r2,r0,#10,#8
000040  f3c01044          UBFX     r0,r0,#5,#5
000044  4082              LSLS     r2,r2,r0
000046  4011              ANDS     r1,r1,r2
000048  fa21f000          LSR      r0,r1,r0
                  |L22.76|
00004c  b004              ADD      sp,sp,#0x10
00004e  bd10              POP      {r4,pc}
                  |L22.80|
000050  2000              MOVS     r0,#0
000052  e7fb              B        |L22.76|
;;;611    
                          ENDP

                  |L22.84|
                          DCD      ||.constdata||+0x10
                  |L22.88|
                          DCD      0x40000220
                  |L22.92|
                          DCD      0x40000228

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                          DCD      0x00000000
                          DCD      0x00000004
                          DCD      0x00000008
                          DCD      0x0000000c
                          DCD      0x00000000
                          DCD      0x00000004
                          DCD      0x0000000c
                          DCD      0x00000010

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Library\\StdDriver\\src\\clk.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_clk_c_9b5832dc____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___5_clk_c_9b5832dc____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_clk_c_9b5832dc____REVSH|
#line 402
|__asm___5_clk_c_9b5832dc____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___5_clk_c_9b5832dc____RRX|
#line 587
|__asm___5_clk_c_9b5832dc____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
