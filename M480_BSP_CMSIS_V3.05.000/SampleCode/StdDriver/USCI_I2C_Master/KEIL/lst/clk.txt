; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\clk.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\clk.d --cpu=Cortex-M4.fp.sp --apcs=interwork --diag_suppress=9931 -I..\..\..\..\Library\CMSIS\Include -I..\..\..\..\Library\Device\Nuvoton\M480\Include -I..\..\..\..\Library\StdDriver\inc -ID:\ARM\RV31\INC -ID:\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=531 --omf_browse=.\obj\clk.crf ..\..\..\..\Library\StdDriver\src\clk.c]
                          THUMB

                          AREA ||i.CLK_DisableCKO||, CODE, READONLY, ALIGN=2

                  CLK_DisableCKO PROC
;;;28       */
;;;29     void CLK_DisableCKO(void)
000000  4801              LDR      r0,|L1.8|
;;;30     {
;;;31         /* Disable CKO clock source */
;;;32         CLK_DisableModuleClock(CLKO_MODULE);
000002  f7ffbffe          B.W      CLK_DisableModuleClock
;;;33     }
;;;34     
                          ENDP

000006  0000              DCW      0x0000
                  |L1.8|
                          DCD      0x57c00006

                          AREA ||i.CLK_DisableModuleClock||, CODE, READONLY, ALIGN=2

                  CLK_DisableModuleClock PROC
;;;766      */
;;;767    void CLK_DisableModuleClock(uint32_t u32ModuleIdx)
000000  f000021f          AND      r2,r0,#0x1f
;;;768    {
;;;769        uint32_t u32tmpVal = 0UL, u32tmpAddr = 0UL;
;;;770    
;;;771        u32tmpVal = ~(1UL << MODULE_IP_EN_Pos(u32ModuleIdx));
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
;;;772        u32tmpAddr = (uint32_t)&CLK->AHBCLK;
000008  4a03              LDR      r2,|L2.24|
;;;773        u32tmpAddr += ((MODULE_APBCLK(u32ModuleIdx) * 4UL));
00000a  0f80              LSRS     r0,r0,#30
00000c  eb020080          ADD      r0,r2,r0,LSL #2
;;;774    
;;;775        *(uint32_t *)u32tmpAddr &= u32tmpVal;
000010  6802              LDR      r2,[r0,#0]
000012  438a              BICS     r2,r2,r1
000014  6002              STR      r2,[r0,#0]
;;;776    }
000016  4770              BX       lr
;;;777    
                          ENDP

                  |L2.24|
                          DCD      0x40000204

                          AREA ||i.CLK_DisablePLL||, CODE, READONLY, ALIGN=1

                  CLK_DisablePLL PROC
;;;941      */
;;;942    void CLK_DisablePLL(void)
000000  f04f4080          MOV      r0,#0x40000000
;;;943    {
;;;944        CLK->PLLCTL |= CLK_PLLCTL_PD_Msk;
000004  f8d01240          LDR      r1,[r0,#0x240]
000008  f4413180          ORR      r1,r1,#0x10000
00000c  f8c01240          STR      r1,[r0,#0x240]
;;;945    }
000010  4770              BX       lr
;;;946    
                          ENDP


                          AREA ||i.CLK_DisableSysTick||, CODE, READONLY, ALIGN=1

                  CLK_DisableSysTick PROC
;;;1020     */
;;;1021   void CLK_DisableSysTick(void)
000000  f04f21e0          MOV      r1,#0xe000e000
;;;1022   {
;;;1023       /* Set System Tick counter disabled */
;;;1024       SysTick->CTRL = 0UL;
000004  2000              MOVS     r0,#0
000006  6108              STR      r0,[r1,#0x10]
;;;1025   }
000008  4770              BX       lr
;;;1026   
                          ENDP


                          AREA ||i.CLK_DisableXtalRC||, CODE, READONLY, ALIGN=1

                  CLK_DisableXtalRC PROC
;;;606      */
;;;607    void CLK_DisableXtalRC(uint32_t u32ClkMask)
000000  f04f4180          MOV      r1,#0x40000000
;;;608    {
;;;609        CLK->PWRCTL &= ~u32ClkMask;
000004  f8d12200          LDR      r2,[r1,#0x200]
000008  4382              BICS     r2,r2,r0
00000a  f8c12200          STR      r2,[r1,#0x200]
;;;610    }
00000e  4770              BX       lr
;;;611    
                          ENDP


                          AREA ||i.CLK_EnableCKO||, CODE, READONLY, ALIGN=2

                  CLK_EnableCKO PROC
;;;51       */
;;;52     void CLK_EnableCKO(uint32_t u32ClkSrc, uint32_t u32ClkDiv, uint32_t u32ClkDivBy1En)
000000  4603              MOV      r3,r0
;;;53     {
;;;54         /* CKO = clock source / 2^(u32ClkDiv + 1) */
;;;55         CLK->CLKOCTL = CLK_CLKOCTL_CLKOEN_Msk | (u32ClkDiv) | (u32ClkDivBy1En << CLK_CLKOCTL_DIV1EN_Pos);
000002  ea411042          ORR      r0,r1,r2,LSL #5
000006  b510              PUSH     {r4,lr}               ;53
000008  f04f4280          MOV      r2,#0x40000000
00000c  f0400110          ORR      r1,r0,#0x10
000010  f8c21260          STR      r1,[r2,#0x260]
;;;56     
;;;57         /* Enable CKO clock source */
;;;58         CLK_EnableModuleClock(CLKO_MODULE);
000014  4c05              LDR      r4,|L6.44|
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       CLK_EnableModuleClock
;;;59     
;;;60         /* Select CKO clock source */
;;;61         CLK_SetModuleClock(CLKO_MODULE, u32ClkSrc, 0UL);
00001c  4620              MOV      r0,r4
00001e  e8bd4010          POP      {r4,lr}
000022  2200              MOVS     r2,#0
000024  4619              MOV      r1,r3
000026  f7ffbffe          B.W      CLK_SetModuleClock
;;;62     }
;;;63     
                          ENDP

00002a  0000              DCW      0x0000
                  |L6.44|
                          DCD      0x57c00006

                          AREA ||i.CLK_EnableDPDWKPin||, CODE, READONLY, ALIGN=1

                  CLK_EnableDPDWKPin PROC
;;;1097   
;;;1098   void CLK_EnableDPDWKPin(uint32_t u32TriggerType)
000000  f04f4180          MOV      r1,#0x40000000
;;;1099   {
;;;1100       uint32_t u32Pin1, u32Pin2, u32Pin3, u32Pin4;
;;;1101   
;;;1102       if ((SYS->CSERVER & SYS_CSERVER_VERSION_Msk) == 0x1) // M480LD
000004  f8d121f4          LDR      r2,[r1,#0x1f4]
000008  b2d2              UXTB     r2,r2
;;;1103       {
;;;1104           u32Pin1 = (((u32TriggerType) & 0x03UL) >> CLK_PMUCTL_WKPINEN1_Pos);
;;;1105           u32Pin2 = (((u32TriggerType) & 0x03UL) >> CLK_PMUCTL_WKPINEN2_Pos);
;;;1106           u32Pin3 = (((u32TriggerType) & 0x03UL) >> CLK_PMUCTL_WKPINEN3_Pos);
;;;1107           u32Pin4 = (((u32TriggerType) & 0x03UL) >> CLK_PMUCTL_WKPINEN4_Pos);
;;;1108   
;;;1109           if(u32Pin1)
;;;1110           {
;;;1111               CLK->PMUCTL = (CLK->PMUCTL & ~(CLK_PMUCTL_WKPINEN1_Msk)) | u32TriggerType;
;;;1112           }
;;;1113           else if(u32Pin2)
;;;1114           {
;;;1115               CLK->PMUCTL = (CLK->PMUCTL & ~(CLK_PMUCTL_WKPINEN2_Msk)) | u32TriggerType;
;;;1116           }
;;;1117           else if(u32Pin3)
;;;1118           {
;;;1119               CLK->PMUCTL = (CLK->PMUCTL & ~(CLK_PMUCTL_WKPINEN3_Msk)) | u32TriggerType;
;;;1120           }
;;;1121           else if(u32Pin4)
;;;1122           {
;;;1123               CLK->PMUCTL = (CLK->PMUCTL & ~(CLK_PMUCTL_WKPINEN4_Msk)) | u32TriggerType;
;;;1124           }
;;;1125           else
;;;1126           {
;;;1127               CLK->PMUCTL = (CLK->PMUCTL & ~(CLK_PMUCTL_WKPINEN_Msk)) | u32TriggerType;
;;;1128           }
;;;1129       }
;;;1130       else
;;;1131       {
;;;1132           CLK->PMUCTL = (CLK->PMUCTL & ~(CLK_PMUCTL_WKPINEN_Msk)) | u32TriggerType;
00000a  f8d12290          LDR      r2,[r1,#0x290]
00000e  f4223240          BIC      r2,r2,#0x30000
000012  4302              ORRS     r2,r2,r0
000014  f8c12290          STR      r2,[r1,#0x290]
;;;1133       }
;;;1134   }
000018  4770              BX       lr
;;;1135   
                          ENDP


                          AREA ||i.CLK_EnableModuleClock||, CODE, READONLY, ALIGN=2

                  CLK_EnableModuleClock PROC
;;;683      */
;;;684    void CLK_EnableModuleClock(uint32_t u32ModuleIdx)
000000  f000021f          AND      r2,r0,#0x1f
;;;685    {
;;;686        uint32_t u32tmpVal = 0UL, u32tmpAddr = 0UL;
;;;687    
;;;688        u32tmpVal = (1UL << MODULE_IP_EN_Pos(u32ModuleIdx));
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
;;;689        u32tmpAddr = (uint32_t)&CLK->AHBCLK;
000008  4a03              LDR      r2,|L8.24|
;;;690        u32tmpAddr += ((MODULE_APBCLK(u32ModuleIdx) * 4UL));
00000a  0f80              LSRS     r0,r0,#30
00000c  eb020080          ADD      r0,r2,r0,LSL #2
;;;691    
;;;692        *(volatile uint32_t *)u32tmpAddr |= u32tmpVal;
000010  6802              LDR      r2,[r0,#0]
000012  430a              ORRS     r2,r2,r1
000014  6002              STR      r2,[r0,#0]
;;;693    }
000016  4770              BX       lr
;;;694    
                          ENDP

                  |L8.24|
                          DCD      0x40000204

                          AREA ||i.CLK_EnablePLL||, CODE, READONLY, ALIGN=2

                  CLK_EnablePLL PROC
;;;788      */
;;;789    uint32_t CLK_EnablePLL(uint32_t u32PllClkSrc, uint32_t u32PllFreq)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;790    {
000004  460d              MOV      r5,r1
000006  4604              MOV      r4,r0
;;;791        uint32_t u32PllSrcClk, u32NR, u32NF, u32NO, u32CLK_SRC, u32PllClk;
;;;792        uint32_t u32Tmp, u32Tmp2, u32Tmp3, u32Min, u32MinNF, u32MinNR, u32MinNO, u32basFreq;
;;;793    
;;;794        /* Disable PLL first to avoid unstable when setting PLL */
;;;795        CLK_DisablePLL();
000008  f7fffffe          BL       CLK_DisablePLL
;;;796    
;;;797        /* PLL source clock is from HXT */
;;;798        if(u32PllClkSrc == CLK_PLLCTL_PLLSRC_HXT)
;;;799        {
;;;800            /* Enable HXT clock */
;;;801            CLK->PWRCTL |= CLK_PWRCTL_HXTEN_Msk;
;;;802    
;;;803            /* Wait for HXT clock ready */
;;;804            CLK_WaitClockReady(CLK_STATUS_HXTSTB_Msk);
;;;805    
;;;806            /* Select PLL source clock from HXT */
;;;807            u32CLK_SRC = CLK_PLLCTL_PLLSRC_HXT;
;;;808            u32PllSrcClk = __HXT;
;;;809    
;;;810            /* u32NR start from 2 */
;;;811            u32NR = 2UL;
;;;812        }
;;;813    
;;;814        /* PLL source clock is from HIRC */
;;;815        else
;;;816        {
;;;817            /* Enable HIRC clock */
;;;818            CLK->PWRCTL |= CLK_PWRCTL_HIRCEN_Msk;
00000c  f04f4080          MOV      r0,#0x40000000
000010  4e48              LDR      r6,|L9.308|
000012  f8d01200          LDR      r1,[r0,#0x200]
000016  b1c4              CBZ      r4,|L9.74|
000018  f0410104          ORR      r1,r1,#4
00001c  f8c01200          STR      r1,[r0,#0x200]
;;;819    
;;;820            /* Wait for HIRC clock ready */
;;;821            CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
000020  2010              MOVS     r0,#0x10
000022  f7fffffe          BL       CLK_WaitClockReady
;;;822    
;;;823            /* Select PLL source clock from HIRC */
;;;824            u32CLK_SRC = CLK_PLLCTL_PLLSRC_HIRC;
000026  f44f2000          MOV      r0,#0x80000
                  |L9.42|
;;;825            u32PllSrcClk = __HIRC;
;;;826    
;;;827            /* u32NR start from 4 when FIN = 22.1184MHz to avoid calculation overflow */
;;;828            u32NR = 4UL;
;;;829        }
;;;830    
;;;831        if((u32PllFreq <= FREQ_500MHZ) && (u32PllFreq >= FREQ_50MHZ))
00002a  9000              STR      r0,[sp,#0]
00002c  4842              LDR      r0,|L9.312|
00002e  4943              LDR      r1,|L9.316|
000030  4428              ADD      r0,r0,r5
000032  46b3              MOV      r11,r6                ;825
000034  4288              CMP      r0,r1
000036  d86d              BHI      |L9.276|
;;;832        {
;;;833    
;;;834            /* Find best solution */
;;;835            u32Min = (uint32_t) - 1;
;;;836            u32MinNR = 0UL;
000038  f04f0900          MOV      r9,#0
00003c  f04f32ff          MOV      r2,#0xffffffff        ;835
;;;837            u32MinNF = 0UL;
000040  464f              MOV      r7,r9
;;;838            u32MinNO = 0UL;
000042  464e              MOV      r6,r9
;;;839            u32basFreq = u32PllFreq;
000044  46ae              MOV      lr,r5
;;;840    
;;;841            for(u32NO = 1UL; u32NO <= 4UL; u32NO++)
000046  2001              MOVS     r0,#1
000048  e015              B        |L9.118|
                  |L9.74|
00004a  f0410101          ORR      r1,r1,#1              ;801
00004e  f8c01200          STR      r1,[r0,#0x200]        ;801
000052  2001              MOVS     r0,#1                 ;804
000054  f7fffffe          BL       CLK_WaitClockReady
000058  2000              MOVS     r0,#0                 ;807
00005a  e7e6              B        |L9.42|
                  |L9.92|
;;;842            {
;;;843                /* Break when get good results */
;;;844                if (u32Min == 0UL)
00005c  b3f2              CBZ      r2,|L9.220|
;;;845                {
;;;846                    break;
;;;847                }
;;;848    
;;;849                if (u32NO != 3UL)
00005e  2803              CMP      r0,#3
000060  d039              BEQ      |L9.214|
;;;850                {
;;;851    
;;;852                    if(u32NO == 4UL)
000062  2804              CMP      r0,#4
000064  d002              BEQ      |L9.108|
;;;853                    {
;;;854                        u32PllFreq = u32basFreq << 2;
;;;855                    }
;;;856                    else if(u32NO == 2UL)
000066  2802              CMP      r0,#2
000068  d105              BNE      |L9.118|
00006a  e002              B        |L9.114|
                  |L9.108|
00006c  ea4f058e          LSL      r5,lr,#2              ;854
000070  e001              B        |L9.118|
                  |L9.114|
;;;857                    {
;;;858                        u32PllFreq = u32basFreq << 1;
000072  ea4f054e          LSL      r5,lr,#1
                  |L9.118|
;;;859                    }
;;;860                    else
;;;861                    {
;;;862                    }
;;;863    
;;;864                    for(u32NR = 2UL; u32NR <= 32UL; u32NR++)
000076  2302              MOVS     r3,#2
                  |L9.120|
;;;865                    {
;;;866                        /* Break when get good results */
;;;867                        if (u32Min == 0UL)
000078  b36a              CBZ      r2,|L9.214|
;;;868                        {
;;;869                            break;
;;;870                        }
;;;871    
;;;872                        u32Tmp = u32PllSrcClk / u32NR;
00007a  fbbbf1f3          UDIV     r1,r11,r3
;;;873                        if((u32Tmp >= 4000000UL) && (u32Tmp <= 8000000UL))
00007e  4c30              LDR      r4,|L9.320|
000080  f8dfc0bc          LDR      r12,|L9.320|
000084  440c              ADD      r4,r4,r1
000086  f1cc0c00          RSB      r12,r12,#0
00008a  4564              CMP      r4,r12
00008c  d820              BHI      |L9.208|
;;;874                        {
;;;875                            for(u32NF = 2UL; u32NF <= 513UL; u32NF++)
00008e  2402              MOVS     r4,#2
;;;876                            {
;;;877                                /* u32Tmp2 is shifted 2 bits to avoid overflow */
;;;878                                u32Tmp2 = (((u32Tmp * 2UL) >> 2) * u32NF);
000090  f3c10a5d          UBFX     r10,r1,#1,#30
                  |L9.148|
;;;879    
;;;880                                if((u32Tmp2 >= FREQ_50MHZ) && (u32Tmp2 <= FREQ_125MHZ))
000094  f8dfc0a0          LDR      r12,|L9.312|
000098  fb0af104          MUL      r1,r10,r4             ;878
00009c  eb01080c          ADD      r8,r1,r12
0000a0  f8dfc0a0          LDR      r12,|L9.324|
0000a4  45e0              CMP      r8,r12
0000a6  d80e              BHI      |L9.198|
;;;881                                {
;;;882                                    u32Tmp3 = (u32Tmp2 > (u32PllFreq>>2)) ? u32Tmp2 - (u32PllFreq>>2) : (u32PllFreq>>2) - u32Tmp2;
0000a8  ebb10f95          CMP      r1,r5,LSR #2
0000ac  d902              BLS      |L9.180|
0000ae  eba10195          SUB      r1,r1,r5,LSR #2
0000b2  e001              B        |L9.184|
                  |L9.180|
0000b4  ebc10195          RSB      r1,r1,r5,LSR #2
                  |L9.184|
;;;883                                    if(u32Tmp3 < u32Min)
0000b8  4291              CMP      r1,r2
0000ba  d204              BCS      |L9.198|
;;;884                                    {
;;;885                                        u32Min = u32Tmp3;
0000bc  000a              MOVS     r2,r1
;;;886                                        u32MinNR = u32NR;
0000be  4699              MOV      r9,r3
;;;887                                        u32MinNF = u32NF;
0000c0  4627              MOV      r7,r4
;;;888                                        u32MinNO = u32NO;
0000c2  4606              MOV      r6,r0
;;;889    
;;;890                                        /* Break when get good results */
;;;891                                        if(u32Min == 0UL)
0000c4  d004              BEQ      |L9.208|
                  |L9.198|
0000c6  f2402101          MOV      r1,#0x201             ;875
0000ca  1c64              ADDS     r4,r4,#1              ;875
0000cc  428c              CMP      r4,r1                 ;875
0000ce  d9e1              BLS      |L9.148|
                  |L9.208|
0000d0  1c5b              ADDS     r3,r3,#1              ;875
0000d2  2b20              CMP      r3,#0x20              ;864
0000d4  d9d0              BLS      |L9.120|
                  |L9.214|
0000d6  1c40              ADDS     r0,r0,#1              ;864
0000d8  2804              CMP      r0,#4                 ;841
0000da  e000              B        |L9.222|
                  |L9.220|
0000dc  e000              B        |L9.224|
                  |L9.222|
0000de  d9bd              BLS      |L9.92|
                  |L9.224|
;;;892                                        {
;;;893                                            break;
;;;894                                        }
;;;895                                    }
;;;896                                }
;;;897                            }
;;;898                        }
;;;899                    }
;;;900                }
;;;901            }
;;;902    
;;;903            /* Enable and apply new PLL setting. */
;;;904            CLK->PLLCTL = u32CLK_SRC | ((u32MinNO - 1UL) << 14) | ((u32MinNR - 1UL) << 9) | (u32MinNF - 2UL);
0000e0  4819              LDR      r0,|L9.328|
0000e2  9900              LDR      r1,[sp,#0]
0000e4  eb003086          ADD      r0,r0,r6,LSL #14
0000e8  4a18              LDR      r2,|L9.332|
0000ea  4308              ORRS     r0,r0,r1
0000ec  eb022149          ADD      r1,r2,r9,LSL #9
0000f0  4308              ORRS     r0,r0,r1
0000f2  1eb9              SUBS     r1,r7,#2
0000f4  4308              ORRS     r0,r0,r1
0000f6  f04f4180          MOV      r1,#0x40000000
0000fa  f8c10240          STR      r0,[r1,#0x240]
;;;905    
;;;906            /* Wait for PLL clock stable */
;;;907            CLK_WaitClockReady(CLK_STATUS_PLLSTB_Msk);
0000fe  2004              MOVS     r0,#4
000100  f7fffffe          BL       CLK_WaitClockReady
;;;908    
;;;909            /* Actual PLL output clock frequency */
;;;910            u32PllClk = u32PllSrcClk / (u32MinNO * (u32MinNR)) * (u32MinNF) * 2UL;
000104  fb06f609          MUL      r6,r6,r9
000108  fbbbf0f6          UDIV     r0,r11,r6
00010c  4378              MULS     r0,r7,r0
00010e  0040              LSLS     r0,r0,#1
;;;911        }
;;;912        else
;;;913        {
;;;914            /* Wrong frequency request. Just return default setting. */
;;;915            /* Apply default PLL setting and return */
;;;916            if(u32PllClkSrc == CLK_PLLCTL_PLLSRC_HXT)
;;;917            {
;;;918                CLK->PLLCTL = CLK_PLLCTL_192MHz_HXT;
;;;919            }
;;;920            else
;;;921            {
;;;922                CLK->PLLCTL = CLK_PLLCTL_192MHz_HIRC;
;;;923            }
;;;924    
;;;925            /* Wait for PLL clock stable */
;;;926            CLK_WaitClockReady(CLK_STATUS_PLLSTB_Msk);
;;;927    
;;;928            /* Actual PLL output clock frequency */
;;;929            u32PllClk = CLK_GetPLLClockFreq();
;;;930        }
;;;931    
;;;932        return u32PllClk;
;;;933    }
000110  e8bd8ff8          POP      {r3-r11,pc}
                  |L9.276|
000114  b15c              CBZ      r4,|L9.302|
000116  490e              LDR      r1,|L9.336|
                  |L9.280|
000118  f04f4080          MOV      r0,#0x40000000        ;922
00011c  f8c01240          STR      r1,[r0,#0x240]        ;922
000120  2004              MOVS     r0,#4                 ;926
000122  f7fffffe          BL       CLK_WaitClockReady
000126  e8bd4ff8          POP      {r3-r11,lr}           ;929
00012a  f7ffbffe          B.W      CLK_GetPLLClockFreq
                  |L9.302|
00012e  f244211e          MOV      r1,#0x421e            ;918
000132  e7f1              B        |L9.280|
;;;934    
                          ENDP

                  |L9.308|
                          DCD      0x00b71b00
                  |L9.312|
                          DCD      0xfd050f80
                  |L9.316|
                          DCD      0x1ad27480
                  |L9.320|
                          DCD      0xffc2f700
                  |L9.324|
                          DCD      0x047868c0
                  |L9.328|
                          DCD      0xffffc000
                  |L9.332|
                          DCD      0xfffffe00
                  |L9.336|
                          DCD      0x0008421e

                          AREA ||i.CLK_EnableSPDWKPin||, CODE, READONLY, ALIGN=2

                  CLK_EnableSPDWKPin PROC
;;;1165    */
;;;1166   void CLK_EnableSPDWKPin(uint32_t u32Port, uint32_t u32Pin, uint32_t u32TriggerType, uint32_t u32DebounceEn)
000000  b530              PUSH     {r4,r5,lr}
;;;1167   {
;;;1168       uint32_t u32tmpAddr = 0UL;
;;;1169       uint32_t u32tmpVal = 0UL;
;;;1170   
;;;1171       /* GPx Stand-by Power-down Wake-up Pin Select */
;;;1172       u32tmpAddr = (uint32_t)&CLK->PASWKCTL;
000002  4c07              LDR      r4,|L10.32|
;;;1173       u32tmpAddr += (0x4UL * u32Port);
000004  eb040080          ADD      r0,r4,r0,LSL #2
;;;1174   
;;;1175       u32tmpVal = inpw((uint32_t *)u32tmpAddr);
000008  6804              LDR      r4,[r0,#0]
;;;1176       u32tmpVal = (u32tmpVal & ~(CLK_PASWKCTL_WKPSEL_Msk | CLK_PASWKCTL_PRWKEN_Msk | CLK_PASWKCTL_PFWKEN_Msk | CLK_PASWKCTL_DBEN_Msk | CLK_PASWKCTL_WKEN_Msk)) |
00000a  f24015f7          MOV      r5,#0x1f7
00000e  43ac              BICS     r4,r4,r5
000010  ea441101          ORR      r1,r4,r1,LSL #4
000014  4311              ORRS     r1,r1,r2
000016  4319              ORRS     r1,r1,r3
000018  f0410101          ORR      r1,r1,#1
;;;1177                   (u32Pin << CLK_PASWKCTL_WKPSEL_Pos) | u32TriggerType | u32DebounceEn | CLK_SPDWKPIN_ENABLE;
;;;1178       outpw((uint32_t *)u32tmpAddr, u32tmpVal);
00001c  6001              STR      r1,[r0,#0]
;;;1179   }
00001e  bd30              POP      {r4,r5,pc}
;;;1180   
                          ENDP

                  |L10.32|
                          DCD      0x400002a0

                          AREA ||i.CLK_EnableSysTick||, CODE, READONLY, ALIGN=1

                  CLK_EnableSysTick PROC
;;;989      */
;;;990    void CLK_EnableSysTick(uint32_t u32ClkSrc, uint32_t u32Count)
000000  b530              PUSH     {r4,r5,lr}
;;;991    {
;;;992        /* Set System Tick counter disabled */
;;;993        SysTick->CTRL = 0UL;
000002  f04f22e0          MOV      r2,#0xe000e000
000006  2500              MOVS     r5,#0
000008  6115              STR      r5,[r2,#0x10]
;;;994    
;;;995        /* Set System Tick clock source */
;;;996        if( u32ClkSrc == CLK_CLKSEL0_STCLKSEL_HCLK )
00000a  2804              CMP      r0,#4
00000c  d00f              BEQ      |L11.46|
;;;997        {
;;;998            SysTick->CTRL |= SysTick_CTRL_CLKSOURCE_Msk;
;;;999        }
;;;1000       else
;;;1001       {
;;;1002           CLK->CLKSEL0 = (CLK->CLKSEL0 & ~CLK_CLKSEL0_STCLKSEL_Msk) | u32ClkSrc;
00000e  f04f4380          MOV      r3,#0x40000000
000012  f8d34210          LDR      r4,[r3,#0x210]
000016  f0240438          BIC      r4,r4,#0x38
00001a  4304              ORRS     r4,r4,r0
00001c  f8c34210          STR      r4,[r3,#0x210]
                  |L11.32|
;;;1003       }
;;;1004   
;;;1005       /* Set System Tick reload value */
;;;1006       SysTick->LOAD = u32Count;
000020  6151              STR      r1,[r2,#0x14]
;;;1007   
;;;1008       /* Clear System Tick current value and counter flag */
;;;1009       SysTick->VAL = 0UL;
000022  6195              STR      r5,[r2,#0x18]
;;;1010   
;;;1011       /* Set System Tick interrupt enabled and counter enabled */
;;;1012       SysTick->CTRL |= SysTick_CTRL_TICKINT_Msk | SysTick_CTRL_ENABLE_Msk;
000024  6910              LDR      r0,[r2,#0x10]
000026  f0400003          ORR      r0,r0,#3
00002a  6110              STR      r0,[r2,#0x10]
;;;1013   }
00002c  bd30              POP      {r4,r5,pc}
                  |L11.46|
00002e  6910              LDR      r0,[r2,#0x10]         ;998
000030  f0400004          ORR      r0,r0,#4              ;998
000034  6110              STR      r0,[r2,#0x10]         ;998
000036  e7f3              B        |L11.32|
;;;1014   
                          ENDP


                          AREA ||i.CLK_EnableXtalRC||, CODE, READONLY, ALIGN=1

                  CLK_EnableXtalRC PROC
;;;590      */
;;;591    void CLK_EnableXtalRC(uint32_t u32ClkMask)
000000  f04f4180          MOV      r1,#0x40000000
;;;592    {
;;;593        CLK->PWRCTL |= u32ClkMask;
000004  f8d12200          LDR      r2,[r1,#0x200]
000008  4302              ORRS     r2,r2,r0
00000a  f8c12200          STR      r2,[r1,#0x200]
;;;594    }
00000e  4770              BX       lr
;;;595    
                          ENDP


                          AREA ||i.CLK_GetCPUFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetCPUFreq PROC
;;;255      */
;;;256    uint32_t CLK_GetCPUFreq(void)
000000  b510              PUSH     {r4,lr}
;;;257    {
;;;258        SystemCoreClockUpdate();
000002  f7fffffe          BL       SystemCoreClockUpdate
;;;259        return SystemCoreClock;
000006  4801              LDR      r0,|L13.12|
000008  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
;;;260    }
00000a  bd10              POP      {r4,pc}
;;;261    
                          ENDP

                  |L13.12|
                          DCD      SystemCoreClock

                          AREA ||i.CLK_GetHCLKFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetHCLKFreq PROC
;;;242      */
;;;243    uint32_t CLK_GetHCLKFreq(void)
000000  b510              PUSH     {r4,lr}
;;;244    {
;;;245        SystemCoreClockUpdate();
000002  f7fffffe          BL       SystemCoreClockUpdate
;;;246        return SystemCoreClock;
000006  4801              LDR      r0,|L14.12|
000008  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
;;;247    }
00000a  bd10              POP      {r4,pc}
;;;248    
                          ENDP

                  |L14.12|
                          DCD      SystemCoreClock

                          AREA ||i.CLK_GetHXTFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetHXTFreq PROC
;;;118      */
;;;119    uint32_t CLK_GetHXTFreq(void)
000000  f04f4080          MOV      r0,#0x40000000
;;;120    {
;;;121        uint32_t u32Freq;
;;;122    
;;;123        if((CLK->PWRCTL & CLK_PWRCTL_HXTEN_Msk) == CLK_PWRCTL_HXTEN_Msk)
000004  f8d00200          LDR      r0,[r0,#0x200]
000008  07c0              LSLS     r0,r0,#31
00000a  d000              BEQ      |L15.14|
;;;124        {
;;;125            u32Freq = __HXT;
00000c  4800              LDR      r0,|L15.16|
                  |L15.14|
;;;126        }
;;;127        else
;;;128        {
;;;129            u32Freq = 0UL;
;;;130        }
;;;131    
;;;132        return u32Freq;
;;;133    }
00000e  4770              BX       lr
;;;134    
                          ENDP

                  |L15.16|
                          DCD      0x00b71b00

                          AREA ||i.CLK_GetLXTFreq||, CODE, READONLY, ALIGN=1

                  CLK_GetLXTFreq PROC
;;;141      */
;;;142    uint32_t CLK_GetLXTFreq(void)
000000  f04f4080          MOV      r0,#0x40000000
;;;143    {
;;;144        uint32_t u32Freq;
;;;145        if((CLK->PWRCTL & CLK_PWRCTL_LXTEN_Msk) == CLK_PWRCTL_LXTEN_Msk)
000004  f8d00200          LDR      r0,[r0,#0x200]
000008  0780              LSLS     r0,r0,#30
00000a  d502              BPL      |L16.18|
;;;146        {
;;;147            u32Freq = __LXT;
00000c  f44f4000          MOV      r0,#0x8000
;;;148        }
;;;149        else
;;;150        {
;;;151            u32Freq = 0UL;
;;;152        }
;;;153    
;;;154        return u32Freq;
;;;155    }
000010  4770              BX       lr
                  |L16.18|
000012  2000              MOVS     r0,#0                 ;151
000014  4770              BX       lr
;;;156    
                          ENDP


                          AREA ||i.CLK_GetModuleClockDivider||, CODE, READONLY, ALIGN=2

                  CLK_GetModuleClockDivider PROC
;;;1321     */
;;;1322   uint32_t CLK_GetModuleClockDivider(uint32_t u32ModuleIdx)
000000  b51f              PUSH     {r0-r4,lr}
;;;1323   {
;;;1324       uint32_t u32div = 0;
;;;1325       uint32_t u32DivTbl[4] = {0x0, 0x4, 0xc, 0x10};
000002  4914              LDR      r1,|L17.84|
;;;1326   
;;;1327       if(MODULE_CLKDIV_Msk(u32ModuleIdx) != MODULE_NoMsk)
000004  f4103f7f          TST      r0,#0x3fc00
000008  c91e              LDM      r1,{r1-r4}            ;1325
00000a  e88d001e          STM      sp,{r1-r4}            ;1325
00000e  d01f              BEQ      |L17.80|
;;;1328       {
;;;1329           /* Get clock divider control register address */
;;;1330           u32div = (uint32_t)&CLK->CLKDIV0 + (u32DivTbl[MODULE_CLKDIV(u32ModuleIdx)]);
000010  f3c04281          UBFX     r2,r0,#18,#2
000014  f85d1022          LDR      r1,[sp,r2,LSL #2]
000018  4a0f              LDR      r2,|L17.88|
00001a  4411              ADD      r1,r1,r2
;;;1331           if ((SYS->CSERVER & SYS_CSERVER_VERSION_Msk) == 0x1) // M480LD
00001c  0652              LSLS     r2,r2,#25
00001e  f8d221f4          LDR      r2,[r2,#0x1f4]
000022  b2d2              UXTB     r2,r2
000024  2a01              CMP      r2,#1
000026  d108              BNE      |L17.58|
;;;1332           {
;;;1333               if(MODULE_IP_EN_Pos_ENC(u32ModuleIdx) == 31U) //EADC1
000028  43c2              MVNS     r2,r0
;;;1334                   u32div = (uint32_t)&CLK->CLKDIV2;
00002a  4b0c              LDR      r3,|L17.92|
00002c  06d2              LSLS     r2,r2,#27             ;1333
00002e  d003              BEQ      |L17.56|
;;;1335               else if(MODULE_IP_EN_Pos_ENC(u32ModuleIdx) == 29U) //I2S0
000030  f000021f          AND      r2,r0,#0x1f
000034  2a1d              CMP      r2,#0x1d
000036  d100              BNE      |L17.58|
                  |L17.56|
;;;1336                   u32div = (uint32_t)&CLK->CLKDIV2;
000038  4619              MOV      r1,r3
                  |L17.58|
;;;1337           }
;;;1338           /* Get clock divider number setting */
;;;1339           return ((M32(u32div) & (MODULE_CLKDIV_Msk(u32ModuleIdx) << MODULE_CLKDIV_Pos(u32ModuleIdx))) >> MODULE_CLKDIV_Pos(u32ModuleIdx));
00003a  6809              LDR      r1,[r1,#0]
00003c  f3c02287          UBFX     r2,r0,#10,#8
000040  f3c01044          UBFX     r0,r0,#5,#5
000044  4082              LSLS     r2,r2,r0
000046  4011              ANDS     r1,r1,r2
000048  fa21f000          LSR      r0,r1,r0
                  |L17.76|
;;;1340       }
;;;1341       else
;;;1342           return 0;
;;;1343   }
00004c  b004              ADD      sp,sp,#0x10
00004e  bd10              POP      {r4,pc}
                  |L17.80|
000050  2000              MOVS     r0,#0                 ;1342
000052  e7fb              B        |L17.76|
;;;1344   
                          ENDP

                  |L17.84|
                          DCD      ||.constdata||+0x10
                  |L17.88|
                          DCD      0x40000220
                  |L17.92|
                          DCD      0x40000228

                          AREA ||i.CLK_GetModuleClockSource||, CODE, READONLY, ALIGN=2

                  CLK_GetModuleClockSource PROC
;;;1272     */
;;;1273   uint32_t CLK_GetModuleClockSource(uint32_t u32ModuleIdx)
000000  b51f              PUSH     {r0-r4,lr}
;;;1274   {
;;;1275       uint32_t u32sel = 0;
;;;1276       uint32_t u32SelTbl[4] = {0x0, 0x4, 0x8, 0xC};
000002  491d              LDR      r1,|L18.120|
000004  c91e              LDM      r1,{r1-r4}
000006  e88d001e          STM      sp,{r1-r4}
;;;1277   
;;;1278       /* Get clock source selection setting */
;;;1279       if(u32ModuleIdx == EPWM0_MODULE)
00000a  4a1c              LDR      r2,|L18.124|
;;;1280           return ((CLK->CLKSEL2 & CLK_CLKSEL2_EPWM0SEL_Msk) >> CLK_CLKSEL2_EPWM0SEL_Pos);
00000c  0691              LSLS     r1,r2,#26
00000e  4290              CMP      r0,r2                 ;1279
000010  d105              BNE      |L18.30|
000012  f8d10218          LDR      r0,[r1,#0x218]
000016  f0000001          AND      r0,r0,#1
                  |L18.26|
;;;1281       else if(u32ModuleIdx == EPWM1_MODULE)
;;;1282           return ((CLK->CLKSEL2 & CLK_CLKSEL2_EPWM1SEL_Msk) >> CLK_CLKSEL2_EPWM1SEL_Pos);
;;;1283       else if(u32ModuleIdx == BPWM0_MODULE)
;;;1284           return ((CLK->CLKSEL2 & CLK_CLKSEL2_BPWM0SEL_Msk) >> CLK_CLKSEL2_BPWM0SEL_Pos);
;;;1285       else if(u32ModuleIdx == BPWM1_MODULE)
;;;1286           return ((CLK->CLKSEL2 & CLK_CLKSEL2_BPWM1SEL_Msk) >> CLK_CLKSEL2_BPWM1SEL_Pos);
;;;1287       else if(MODULE_CLKSEL_Msk(u32ModuleIdx) != MODULE_NoMsk)
;;;1288       {
;;;1289           /* Get clock select control register address */
;;;1290           u32sel = (uint32_t)&CLK->CLKSEL0 + (u32SelTbl[MODULE_CLKSEL(u32ModuleIdx)]);
;;;1291           /* Get clock source selection setting */
;;;1292           return ((M32(u32sel) & (MODULE_CLKSEL_Msk(u32ModuleIdx) << MODULE_CLKSEL_Pos(u32ModuleIdx))) >> MODULE_CLKSEL_Pos(u32ModuleIdx));
;;;1293       }
;;;1294       else
;;;1295           return 0;
;;;1296   }
00001a  b004              ADD      sp,sp,#0x10
00001c  bd10              POP      {r4,pc}
                  |L18.30|
00001e  4a18              LDR      r2,|L18.128|
000020  4290              CMP      r0,r2                 ;1281
000022  d104              BNE      |L18.46|
000024  f8d10218          LDR      r0,[r1,#0x218]        ;1282
000028  f3c00040          UBFX     r0,r0,#1,#1           ;1282
00002c  e7f5              B        |L18.26|
                  |L18.46|
00002e  4a15              LDR      r2,|L18.132|
000030  4290              CMP      r0,r2                 ;1283
000032  d104              BNE      |L18.62|
000034  f8d10218          LDR      r0,[r1,#0x218]        ;1284
000038  f3c02000          UBFX     r0,r0,#8,#1           ;1284
00003c  e7ed              B        |L18.26|
                  |L18.62|
00003e  4a12              LDR      r2,|L18.136|
000040  4290              CMP      r0,r2                 ;1285
000042  d104              BNE      |L18.78|
000044  f8d10218          LDR      r0,[r1,#0x218]        ;1286
000048  f3c02040          UBFX     r0,r0,#9,#1           ;1286
00004c  e7e5              B        |L18.26|
                  |L18.78|
00004e  0e41              LSRS     r1,r0,#25             ;1287
000050  0749              LSLS     r1,r1,#29             ;1287
000052  d00e              BEQ      |L18.114|
000054  f3c07201          UBFX     r2,r0,#28,#2          ;1290
000058  f85d1022          LDR      r1,[sp,r2,LSL #2]     ;1290
00005c  4a0b              LDR      r2,|L18.140|
00005e  5889              LDR      r1,[r1,r2]            ;1292
000060  f3c06242          UBFX     r2,r0,#25,#3          ;1292
000064  f3c05004          UBFX     r0,r0,#20,#5          ;1292
000068  4082              LSLS     r2,r2,r0              ;1292
00006a  4011              ANDS     r1,r1,r2              ;1292
00006c  fa21f000          LSR      r0,r1,r0              ;1292
000070  e7d3              B        |L18.26|
                  |L18.114|
000072  2000              MOVS     r0,#0                 ;1295
000074  e7d1              B        |L18.26|
;;;1297   
                          ENDP

000076  0000              DCW      0x0000
                  |L18.120|
                          DCD      ||.constdata||
                  |L18.124|
                          DCD      0xa2000010
                  |L18.128|
                          DCD      0xa2100011
                  |L18.132|
                          DCD      0xa2800012
                  |L18.136|
                          DCD      0xa2900013
                  |L18.140|
                          DCD      0x40000210

                          AREA ||i.CLK_GetPCLK0Freq||, CODE, READONLY, ALIGN=2

                  CLK_GetPCLK0Freq PROC
;;;162      */
;;;163    uint32_t CLK_GetPCLK0Freq(void)
000000  b510              PUSH     {r4,lr}
;;;164    {
;;;165        uint32_t u32Freq;
;;;166        SystemCoreClockUpdate();
000002  f7fffffe          BL       SystemCoreClockUpdate
;;;167    
;;;168        if((CLK->PCLKDIV & CLK_PCLKDIV_APB0DIV_Msk) == CLK_PCLKDIV_APB0DIV_DIV1)
000006  f04f4180          MOV      r1,#0x40000000
00000a  f8d10234          LDR      r0,[r1,#0x234]
00000e  0742              LSLS     r2,r0,#29
;;;169        {
;;;170            u32Freq = SystemCoreClock;
000010  4813              LDR      r0,|L19.96|
000012  d017              BEQ      |L19.68|
;;;171        }
;;;172        else if((CLK->PCLKDIV & CLK_PCLKDIV_APB0DIV_Msk) == CLK_PCLKDIV_APB0DIV_DIV2)
000014  f8d12234          LDR      r2,[r1,#0x234]
000018  f0020207          AND      r2,r2,#7
00001c  2a01              CMP      r2,#1
00001e  d013              BEQ      |L19.72|
;;;173        {
;;;174            u32Freq = SystemCoreClock / 2UL;
;;;175        }
;;;176        else if((CLK->PCLKDIV & CLK_PCLKDIV_APB0DIV_Msk) == CLK_PCLKDIV_APB0DIV_DIV4)
000020  f8d12234          LDR      r2,[r1,#0x234]
000024  f0020207          AND      r2,r2,#7
000028  2a02              CMP      r2,#2
00002a  d010              BEQ      |L19.78|
;;;177        {
;;;178            u32Freq = SystemCoreClock / 4UL;
;;;179        }
;;;180        else if((CLK->PCLKDIV & CLK_PCLKDIV_APB0DIV_Msk) == CLK_PCLKDIV_APB0DIV_DIV8)
00002c  f8d12234          LDR      r2,[r1,#0x234]
000030  f0020207          AND      r2,r2,#7
000034  2a03              CMP      r2,#3
000036  d00d              BEQ      |L19.84|
;;;181        {
;;;182            u32Freq = SystemCoreClock / 8UL;
;;;183        }
;;;184        else if((CLK->PCLKDIV & CLK_PCLKDIV_APB0DIV_Msk) == CLK_PCLKDIV_APB0DIV_DIV16)
000038  f8d11234          LDR      r1,[r1,#0x234]
00003c  f0010107          AND      r1,r1,#7
000040  2904              CMP      r1,#4
000042  d00a              BEQ      |L19.90|
                  |L19.68|
000044  6800              LDR      r0,[r0,#0]            ;170  ; SystemCoreClock
;;;185        {
;;;186            u32Freq = SystemCoreClock / 16UL;
;;;187        }
;;;188        else
;;;189        {
;;;190            u32Freq = SystemCoreClock;
;;;191        }
;;;192    
;;;193        return u32Freq;
;;;194    }
000046  bd10              POP      {r4,pc}
                  |L19.72|
000048  6800              LDR      r0,[r0,#0]            ;174  ; SystemCoreClock
00004a  0840              LSRS     r0,r0,#1              ;174
00004c  bd10              POP      {r4,pc}
                  |L19.78|
00004e  6800              LDR      r0,[r0,#0]            ;178  ; SystemCoreClock
000050  0880              LSRS     r0,r0,#2              ;178
000052  bd10              POP      {r4,pc}
                  |L19.84|
000054  6800              LDR      r0,[r0,#0]            ;182  ; SystemCoreClock
000056  08c0              LSRS     r0,r0,#3              ;182
000058  bd10              POP      {r4,pc}
                  |L19.90|
00005a  6800              LDR      r0,[r0,#0]            ;186  ; SystemCoreClock
00005c  0900              LSRS     r0,r0,#4              ;186
00005e  bd10              POP      {r4,pc}
;;;195    
                          ENDP

                  |L19.96|
                          DCD      SystemCoreClock

                          AREA ||i.CLK_GetPCLK1Freq||, CODE, READONLY, ALIGN=2

                  CLK_GetPCLK1Freq PROC
;;;202      */
;;;203    uint32_t CLK_GetPCLK1Freq(void)
000000  b510              PUSH     {r4,lr}
;;;204    {
;;;205        uint32_t u32Freq;
;;;206        SystemCoreClockUpdate();
000002  f7fffffe          BL       SystemCoreClockUpdate
;;;207    
;;;208        if((CLK->PCLKDIV & CLK_PCLKDIV_APB1DIV_Msk) == CLK_PCLKDIV_APB1DIV_DIV1)
000006  f04f4180          MOV      r1,#0x40000000
00000a  f8d10234          LDR      r0,[r1,#0x234]
00000e  f0100f70          TST      r0,#0x70
;;;209        {
;;;210            u32Freq = SystemCoreClock;
000012  4814              LDR      r0,|L20.100|
000014  d017              BEQ      |L20.70|
;;;211        }
;;;212        else if((CLK->PCLKDIV & CLK_PCLKDIV_APB1DIV_Msk) == CLK_PCLKDIV_APB1DIV_DIV2)
000016  f8d12234          LDR      r2,[r1,#0x234]
00001a  f3c21202          UBFX     r2,r2,#4,#3
00001e  2a01              CMP      r2,#1
000020  d013              BEQ      |L20.74|
;;;213        {
;;;214            u32Freq = SystemCoreClock / 2UL;
;;;215        }
;;;216        else if((CLK->PCLKDIV & CLK_PCLKDIV_APB1DIV_Msk) == CLK_PCLKDIV_APB1DIV_DIV4)
000022  f8d12234          LDR      r2,[r1,#0x234]
000026  f3c21202          UBFX     r2,r2,#4,#3
00002a  2a02              CMP      r2,#2
00002c  d010              BEQ      |L20.80|
;;;217        {
;;;218            u32Freq = SystemCoreClock / 4UL;
;;;219        }
;;;220        else if((CLK->PCLKDIV & CLK_PCLKDIV_APB1DIV_Msk) == CLK_PCLKDIV_APB1DIV_DIV8)
00002e  f8d12234          LDR      r2,[r1,#0x234]
000032  f3c21202          UBFX     r2,r2,#4,#3
000036  2a03              CMP      r2,#3
000038  d00d              BEQ      |L20.86|
;;;221        {
;;;222            u32Freq = SystemCoreClock / 8UL;
;;;223        }
;;;224        else if((CLK->PCLKDIV & CLK_PCLKDIV_APB1DIV_Msk) == CLK_PCLKDIV_APB1DIV_DIV16)
00003a  f8d11234          LDR      r1,[r1,#0x234]
00003e  f3c11102          UBFX     r1,r1,#4,#3
000042  2904              CMP      r1,#4
000044  d00a              BEQ      |L20.92|
                  |L20.70|
000046  6800              LDR      r0,[r0,#0]            ;210  ; SystemCoreClock
;;;225        {
;;;226            u32Freq = SystemCoreClock / 16UL;
;;;227        }
;;;228        else
;;;229        {
;;;230            u32Freq = SystemCoreClock;
;;;231        }
;;;232    
;;;233        return u32Freq;
;;;234    }
000048  bd10              POP      {r4,pc}
                  |L20.74|
00004a  6800              LDR      r0,[r0,#0]            ;214  ; SystemCoreClock
00004c  0840              LSRS     r0,r0,#1              ;214
00004e  bd10              POP      {r4,pc}
                  |L20.80|
000050  6800              LDR      r0,[r0,#0]            ;218  ; SystemCoreClock
000052  0880              LSRS     r0,r0,#2              ;218
000054  bd10              POP      {r4,pc}
                  |L20.86|
000056  6800              LDR      r0,[r0,#0]            ;222  ; SystemCoreClock
000058  08c0              LSRS     r0,r0,#3              ;222
00005a  bd10              POP      {r4,pc}
                  |L20.92|
00005c  6800              LDR      r0,[r0,#0]            ;226  ; SystemCoreClock
00005e  0900              LSRS     r0,r0,#4              ;226
000060  bd10              POP      {r4,pc}
;;;235    
                          ENDP

000062  0000              DCW      0x0000
                  |L20.100|
                          DCD      SystemCoreClock

                          AREA ||i.CLK_GetPLLClockFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetPLLClockFreq PROC
;;;1186     */
;;;1187   uint32_t CLK_GetPLLClockFreq(void)
000000  b508              PUSH     {r3,lr}
;;;1188   {
;;;1189       uint32_t u32PllFreq = 0UL, u32PllReg;
;;;1190       uint32_t u32FIN, u32NF, u32NR, u32NO;
;;;1191       uint8_t au8NoTbl[4] = {1U, 2U, 2U, 4U};
000002  a110              ADR      r1,|L21.68|
000004  2000              MOVS     r0,#0                 ;1189
000006  6809              LDR      r1,[r1,#0]
;;;1192   
;;;1193       u32PllReg = CLK->PLLCTL;
000008  9100              STR      r1,[sp,#0]
00000a  f04f4180          MOV      r1,#0x40000000
00000e  f8d11240          LDR      r1,[r1,#0x240]
;;;1194   
;;;1195       if(u32PllReg & (CLK_PLLCTL_PD_Msk | CLK_PLLCTL_OE_Msk))
000012  f4112fa0          TST      r1,#0x50000
000016  d113              BNE      |L21.64|
;;;1196       {
;;;1197           u32PllFreq = 0UL;           /* PLL is in power down mode or fix low */
;;;1198       }
;;;1199       else if((u32PllReg & CLK_PLLCTL_BP_Msk) == CLK_PLLCTL_BP_Msk)
;;;1200       {
;;;1201           if((u32PllReg & CLK_PLLCTL_PLLSRC_HIRC) == CLK_PLLCTL_PLLSRC_HIRC)
;;;1202           {
;;;1203               u32FIN = __HIRC;    /* PLL source clock from HIRC */
000018  480b              LDR      r0,|L21.72|
00001a  038a              LSLS     r2,r1,#14             ;1199
00001c  d410              BMI      |L21.64|
;;;1204           }
;;;1205           else
;;;1206           {
;;;1207               u32FIN = __HXT;     /* PLL source clock from HXT */
;;;1208           }
;;;1209   
;;;1210           u32PllFreq = u32FIN;
;;;1211       }
;;;1212       else
;;;1213       {
;;;1214           if((u32PllReg & CLK_PLLCTL_PLLSRC_HIRC) == CLK_PLLCTL_PLLSRC_HIRC)
;;;1215           {
;;;1216               u32FIN = __HIRC;    /* PLL source clock from HIRC */
;;;1217           }
;;;1218           else
;;;1219           {
;;;1220               u32FIN = __HXT;     /* PLL source clock from HXT */
;;;1221           }
;;;1222           /* PLL is output enabled in normal work mode */
;;;1223           u32NO = au8NoTbl[((u32PllReg & CLK_PLLCTL_OUTDIV_Msk) >> CLK_PLLCTL_OUTDIV_Pos)];
;;;1224           u32NF = ((u32PllReg & CLK_PLLCTL_FBDIV_Msk) >> CLK_PLLCTL_FBDIV_Pos) + 2UL;
00001e  f3c10008          UBFX     r0,r1,#0,#9
000022  f3c13281          UBFX     r2,r1,#14,#2          ;1223
;;;1225           u32NR = ((u32PllReg & CLK_PLLCTL_INDIV_Msk) >> CLK_PLLCTL_INDIV_Pos) + 1UL;
;;;1226   
;;;1227           /* u32FIN is shifted 2 bits to avoid overflow */
;;;1228           u32PllFreq = (((u32FIN >> 2) * u32NF) / (u32NR * u32NO) << 2) * 2UL;
000026  4b09              LDR      r3,|L21.76|
000028  1c80              ADDS     r0,r0,#2
00002a  f81d2002          LDRB     r2,[sp,r2]            ;1223
00002e  f3c12144          UBFX     r1,r1,#9,#5           ;1225
000032  4358              MULS     r0,r3,r0
000034  1c49              ADDS     r1,r1,#1
000036  fb11f102          SMULBB   r1,r1,r2
00003a  fbb0f0f1          UDIV     r0,r0,r1
00003e  00c0              LSLS     r0,r0,#3
                  |L21.64|
;;;1229       }
;;;1230   
;;;1231       return u32PllFreq;
;;;1232   }
000040  bd08              POP      {r3,pc}
;;;1233   
                          ENDP

000042  0000              DCW      0x0000
                  |L21.68|
000044  01020204          DCB      1,2,2,4
                  |L21.72|
                          DCD      0x00b71b00
                  |L21.76|
                          DCD      0x002dc6c0

                          AREA ||i.CLK_GetPMUWKSrc||, CODE, READONLY, ALIGN=1

                  CLK_GetPMUWKSrc PROC
;;;1144   
;;;1145   uint32_t CLK_GetPMUWKSrc(void)
000000  f04f4080          MOV      r0,#0x40000000
;;;1146   {
;;;1147       return (CLK->PMUSTS);
000004  f8d00294          LDR      r0,[r0,#0x294]
;;;1148   }
000008  4770              BX       lr
;;;1149   
                          ENDP


                          AREA ||i.CLK_Idle||, CODE, READONLY, ALIGN=2

                  CLK_Idle PROC
;;;100      */
;;;101    void CLK_Idle(void)
000000  4806              LDR      r0,|L23.28|
;;;102    {
;;;103        /* Set the processor uses sleep as its low power mode */
;;;104        SCB->SCR &= ~SCB_SCR_SLEEPDEEP_Msk;
000002  6801              LDR      r1,[r0,#0]
000004  f0210104          BIC      r1,r1,#4
000008  6001              STR      r1,[r0,#0]
;;;105    
;;;106        /* Set chip in idle mode because of WFI command */
;;;107        CLK->PWRCTL &= ~CLK_PWRCTL_PDEN_Msk;
00000a  0680              LSLS     r0,r0,#26
00000c  f8d01200          LDR      r1,[r0,#0x200]
000010  f0210180          BIC      r1,r1,#0x80
000014  f8c01200          STR      r1,[r0,#0x200]
;;;108    
;;;109        /* Chip enter idle mode after CPU run WFI instruction */
;;;110        __WFI();
000018  bf30              WFI      
;;;111    }
00001a  4770              BX       lr
;;;112    
                          ENDP

                  |L23.28|
                          DCD      0xe000ed10

                          AREA ||i.CLK_PowerDown||, CODE, READONLY, ALIGN=2

                  CLK_PowerDown PROC
;;;70       */
;;;71     void CLK_PowerDown(void)
000000  480a              LDR      r0,|L24.44|
;;;72     {
;;;73         uint32_t u32HIRCTRIMCTL;
;;;74     
;;;75         /* Set the processor uses deep sleep as its low power mode */
;;;76         SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
000002  6801              LDR      r1,[r0,#0]
000004  f0410104          ORR      r1,r1,#4
000008  6001              STR      r1,[r0,#0]
;;;77     
;;;78         /* Set system Power-down enabled */
;;;79         CLK->PWRCTL |= (CLK_PWRCTL_PDEN_Msk);
00000a  0680              LSLS     r0,r0,#26
00000c  f8d01200          LDR      r1,[r0,#0x200]
000010  f0410180          ORR      r1,r1,#0x80
000014  f8c01200          STR      r1,[r0,#0x200]
;;;80     
;;;81         /* Store HIRC control register */
;;;82         u32HIRCTRIMCTL = SYS->IRCTCTL;
000018  f8501ff0          LDR      r1,[r0,#0xf0]!
;;;83     
;;;84         /* Disable HIRC auto trim */
;;;85         SYS->IRCTCTL &= (~SYS_IRCTCTL_FREQSEL_Msk);
00001c  6802              LDR      r2,[r0,#0]
00001e  f0220203          BIC      r2,r2,#3
000022  6002              STR      r2,[r0,#0]
;;;86     
;;;87         /* Chip enter Power-down mode after CPU run WFI instruction */
;;;88         __WFI();
000024  bf30              WFI      
;;;89     
;;;90         /* Restore HIRC control register */
;;;91         SYS->IRCTCTL = u32HIRCTRIMCTL;
000026  6001              STR      r1,[r0,#0]
;;;92     }
000028  4770              BX       lr
;;;93     
                          ENDP

00002a  0000              DCW      0x0000
                  |L24.44|
                          DCD      0xe000ed10

                          AREA ||i.CLK_SetCoreClock||, CODE, READONLY, ALIGN=2

                  CLK_SetCoreClock PROC
;;;269      */
;;;270    uint32_t CLK_SetCoreClock(uint32_t u32Hclk)
000000  b570              PUSH     {r4-r6,lr}
;;;271    {
;;;272        uint32_t u32HIRCSTB;
;;;273    
;;;274        /* Read HIRC clock source stable flag */
;;;275        u32HIRCSTB = CLK->STATUS & CLK_STATUS_HIRCSTB_Msk;
000002  f04f4480          MOV      r4,#0x40000000
000006  4606              MOV      r6,r0                 ;271
000008  f8d40250          LDR      r0,[r4,#0x250]
00000c  f0000510          AND      r5,r0,#0x10
;;;276    
;;;277        /* The range of u32Hclk is running up to 192 MHz */
;;;278        if(u32Hclk > FREQ_192MHZ)
000010  481b              LDR      r0,|L25.128|
000012  4286              CMP      r6,r0
000014  d900              BLS      |L25.24|
;;;279        {
;;;280            u32Hclk = FREQ_192MHZ;
000016  4606              MOV      r6,r0
                  |L25.24|
;;;281        }
;;;282    
;;;283        /* Switch HCLK clock source to HIRC clock for safe */
;;;284        CLK->PWRCTL |= CLK_PWRCTL_HIRCEN_Msk;
000018  f8d40200          LDR      r0,[r4,#0x200]
00001c  f0400004          ORR      r0,r0,#4
000020  f8c40200          STR      r0,[r4,#0x200]
;;;285        CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
000024  2010              MOVS     r0,#0x10
000026  f5047400          ADD      r4,r4,#0x200
00002a  f7fffffe          BL       CLK_WaitClockReady
;;;286        CLK->CLKSEL0 |= CLK_CLKSEL0_HCLKSEL_Msk;
00002e  6920              LDR      r0,[r4,#0x10]
000030  f0400007          ORR      r0,r0,#7
000034  6120              STR      r0,[r4,#0x10]
;;;287        CLK->CLKDIV0 &= (~CLK_CLKDIV0_HCLKDIV_Msk);
000036  6a20              LDR      r0,[r4,#0x20]
000038  f020000f          BIC      r0,r0,#0xf
00003c  6220              STR      r0,[r4,#0x20]
;;;288    
;;;289        /* Configure PLL setting if HXT clock is enabled */
;;;290        if((CLK->PWRCTL & CLK_PWRCTL_HXTEN_Msk) == CLK_PWRCTL_HXTEN_Msk)
00003e  6820              LDR      r0,[r4,#0]
000040  f5a47400          SUB      r4,r4,#0x200
000044  07c0              LSLS     r0,r0,#31
;;;291        {
;;;292            u32Hclk = CLK_EnablePLL(CLK_PLLCTL_PLLSRC_HXT, u32Hclk);
;;;293        }
;;;294        /* Configure PLL setting if HXT clock is not enabled */
;;;295        else
;;;296        {
;;;297            u32Hclk = CLK_EnablePLL(CLK_PLLCTL_PLLSRC_HIRC, u32Hclk);
000046  4631              MOV      r1,r6
000048  d004              BEQ      |L25.84|
00004a  2000              MOVS     r0,#0                 ;292
00004c  f7fffffe          BL       CLK_EnablePLL
000050  4606              MOV      r6,r0                 ;292
000052  e008              B        |L25.102|
                  |L25.84|
000054  f44f2000          MOV      r0,#0x80000
000058  f7fffffe          BL       CLK_EnablePLL
00005c  4606              MOV      r6,r0
;;;298    
;;;299            /* Read HIRC clock source stable flag */
;;;300            u32HIRCSTB = CLK->STATUS & CLK_STATUS_HIRCSTB_Msk;
00005e  f8d40250          LDR      r0,[r4,#0x250]
000062  f0000510          AND      r5,r0,#0x10
                  |L25.102|
;;;301        }
;;;302    
;;;303        /* Select HCLK clock source to PLL,
;;;304           and update system core clock
;;;305        */
;;;306        CLK_SetHCLK(CLK_CLKSEL0_HCLKSEL_PLL, CLK_CLKDIV0_HCLK(1UL));
000066  2100              MOVS     r1,#0
000068  2002              MOVS     r0,#2
00006a  f7fffffe          BL       CLK_SetHCLK
;;;307    
;;;308        /* Disable HIRC if HIRC is disabled before setting core clock */
;;;309        if(u32HIRCSTB == 0UL)
00006e  b92d              CBNZ     r5,|L25.124|
;;;310        {
;;;311            CLK->PWRCTL &= ~CLK_PWRCTL_HIRCEN_Msk;
000070  f8d40200          LDR      r0,[r4,#0x200]
000074  f0200004          BIC      r0,r0,#4
000078  f8c40200          STR      r0,[r4,#0x200]
                  |L25.124|
;;;312        }
;;;313    
;;;314        /* Return actually HCLK frequency is PLL frequency divide 1 */
;;;315        return u32Hclk;
00007c  4630              MOV      r0,r6
;;;316    }
00007e  bd70              POP      {r4-r6,pc}
;;;317    
                          ENDP

                  |L25.128|
                          DCD      0x0b71b000

                          AREA ||i.CLK_SetHCLK||, CODE, READONLY, ALIGN=1

                  CLK_SetHCLK PROC
;;;331      */
;;;332    void CLK_SetHCLK(uint32_t u32ClkSrc, uint32_t u32ClkDiv)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;333    {
;;;334        uint32_t u32HIRCSTB;
;;;335    
;;;336        /* Read HIRC clock source stable flag */
;;;337        u32HIRCSTB = CLK->STATUS & CLK_STATUS_HIRCSTB_Msk;
000004  f04f4480          MOV      r4,#0x40000000
000008  4607              MOV      r7,r0                 ;333
00000a  f8d40250          LDR      r0,[r4,#0x250]
00000e  460e              MOV      r6,r1                 ;333
000010  f0000510          AND      r5,r0,#0x10
;;;338    
;;;339        /* Switch to HIRC for Safe. Avoid HCLK too high when applying new divider. */
;;;340        CLK->PWRCTL |= CLK_PWRCTL_HIRCEN_Msk;
000014  f8d40200          LDR      r0,[r4,#0x200]
000018  f0400004          ORR      r0,r0,#4
00001c  f8c40200          STR      r0,[r4,#0x200]
;;;341        CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
000020  2010              MOVS     r0,#0x10
000022  f5047400          ADD      r4,r4,#0x200
000026  f7fffffe          BL       CLK_WaitClockReady
;;;342        CLK->CLKSEL0 = (CLK->CLKSEL0 & (~CLK_CLKSEL0_HCLKSEL_Msk)) | CLK_CLKSEL0_HCLKSEL_HIRC;
00002a  6920              LDR      r0,[r4,#0x10]
00002c  f0400007          ORR      r0,r0,#7
000030  6120              STR      r0,[r4,#0x10]
;;;343    
;;;344        /* Apply new Divider */
;;;345        CLK->CLKDIV0 = (CLK->CLKDIV0 & (~CLK_CLKDIV0_HCLKDIV_Msk)) | u32ClkDiv;
000032  6a20              LDR      r0,[r4,#0x20]
000034  f020000f          BIC      r0,r0,#0xf
000038  4330              ORRS     r0,r0,r6
00003a  6220              STR      r0,[r4,#0x20]
;;;346    
;;;347        /* Switch HCLK to new HCLK source */
;;;348        CLK->CLKSEL0 = (CLK->CLKSEL0 & (~CLK_CLKSEL0_HCLKSEL_Msk)) | u32ClkSrc;
00003c  6920              LDR      r0,[r4,#0x10]
00003e  f0200007          BIC      r0,r0,#7
000042  4338              ORRS     r0,r0,r7
000044  6120              STR      r0,[r4,#0x10]
000046  f5a47400          SUB      r4,r4,#0x200
;;;349    
;;;350        /* Update System Core Clock */
;;;351        SystemCoreClockUpdate();
00004a  f7fffffe          BL       SystemCoreClockUpdate
;;;352    
;;;353        /* Disable HIRC if HIRC is disabled before switching HCLK source */
;;;354        if(u32HIRCSTB == 0UL)
00004e  2d00              CMP      r5,#0
000050  d105              BNE      |L26.94|
;;;355        {
;;;356            CLK->PWRCTL &= ~CLK_PWRCTL_HIRCEN_Msk;
000052  f8d40200          LDR      r0,[r4,#0x200]
000056  f0200004          BIC      r0,r0,#4
00005a  f8c40200          STR      r0,[r4,#0x200]
                  |L26.94|
;;;357        }
;;;358    }
00005e  e8bd81f0          POP      {r4-r8,pc}
;;;359    
                          ENDP


                          AREA ||i.CLK_SetModuleClock||, CODE, READONLY, ALIGN=2

                  CLK_SetModuleClock PROC
;;;501      */
;;;502    void CLK_SetModuleClock(uint32_t u32ModuleIdx, uint32_t u32ClkSrc, uint32_t u32ClkDiv)
000000  b5f0              PUSH     {r4-r7,lr}
;;;503    {
;;;504        uint32_t u32sel = 0U, u32div = 0U;
;;;505    
;;;506        if(MODULE_CLKDIV_Msk(u32ModuleIdx) != MODULE_NoMsk)
000002  f4103f7f          TST      r0,#0x3fc00
000006  d02e              BEQ      |L27.102|
;;;507        {
;;;508            /* Get clock divider control register address */
;;;509            if ((SYS->CSERVER & SYS_CSERVER_VERSION_Msk) == 0x1) // M480LD
000008  f04f4380          MOV      r3,#0x40000000
00000c  f8d331f4          LDR      r3,[r3,#0x1f4]
;;;510            {
;;;511                if(MODULE_CLKDIV(u32ModuleIdx) == 2U && MODULE_IP_EN_Pos_ENC(u32ModuleIdx) == 31U) //EADC1
;;;512                {
;;;513                    u32div = (uint32_t)&CLK->CLKDIV2;
;;;514                }
;;;515                else if(MODULE_CLKDIV(u32ModuleIdx) == 2U && MODULE_IP_EN_Pos_ENC(u32ModuleIdx) == 29U) //I2S0
;;;516                {
;;;517                    u32div = (uint32_t)&CLK->CLKDIV2;
;;;518                }
;;;519                else if (MODULE_CLKDIV(u32ModuleIdx) == 2U)
;;;520                {
;;;521                    u32div = (uint32_t)&CLK->CLKDIV3;
000010  f8dfc078          LDR      r12,|L27.140|
000014  b2df              UXTB     r7,r3                 ;509
;;;522                }
;;;523                else if (MODULE_CLKDIV(u32ModuleIdx) == 3U)
;;;524                {
;;;525                    u32div = (uint32_t)&CLK->CLKDIV4;
;;;526                }
;;;527                else
;;;528                {
;;;529                    u32div = (uint32_t)&CLK->CLKDIV0 + ((MODULE_CLKDIV(u32ModuleIdx)) * 4U);
000016  4b1d              LDR      r3,|L27.140|
000018  f3c04481          UBFX     r4,r0,#18,#2          ;511
00001c  3b0c              SUBS     r3,r3,#0xc
00001e  ea6f4590          MVN      r5,r0,LSR #18         ;523
000022  f10c0604          ADD      r6,r12,#4             ;525
000026  eb030384          ADD      r3,r3,r4,LSL #2
00002a  2f01              CMP      r7,#1                 ;509
00002c  d002              BEQ      |L27.52|
;;;530                }
;;;531            }
;;;532            else
;;;533            {
;;;534                /* Get clock divider control register address */
;;;535                if(MODULE_CLKDIV(u32ModuleIdx) == 2U)
00002e  2c02              CMP      r4,#2
000030  d00d              BEQ      |L27.78|
000032  e001              B        |L27.56|
                  |L27.52|
000034  2c02              CMP      r4,#2                 ;511
000036  d002              BEQ      |L27.62|
                  |L27.56|
;;;536                {
;;;537                    u32div = (uint32_t)&CLK->CLKDIV3;
;;;538                }
;;;539                else if (MODULE_CLKDIV(u32ModuleIdx) == 3U)
000038  07ac              LSLS     r4,r5,#30
00003a  d00a              BEQ      |L27.82|
00003c  e00a              B        |L27.84|
                  |L27.62|
00003e  43c3              MVNS     r3,r0                 ;511
000040  06dc              LSLS     r4,r3,#27             ;511
000042  4b13              LDR      r3,|L27.144|
000044  d006              BEQ      |L27.84|
000046  f000041f          AND      r4,r0,#0x1f           ;515
00004a  2c1d              CMP      r4,#0x1d              ;515
00004c  d002              BEQ      |L27.84|
                  |L27.78|
00004e  4663              MOV      r3,r12                ;537
000050  e000              B        |L27.84|
                  |L27.82|
;;;540                {
;;;541                    u32div = (uint32_t)&CLK->CLKDIV4;
000052  4633              MOV      r3,r6
                  |L27.84|
;;;542                }
;;;543                else
;;;544                {
;;;545                    u32div = (uint32_t)&CLK->CLKDIV0 + ((MODULE_CLKDIV(u32ModuleIdx)) * 4U);
;;;546                }
;;;547            }
;;;548    
;;;549            /* Apply new divider */
;;;550            M32(u32div) = (M32(u32div) & (~(MODULE_CLKDIV_Msk(u32ModuleIdx) << MODULE_CLKDIV_Pos(u32ModuleIdx)))) | u32ClkDiv;
000054  681c              LDR      r4,[r3,#0]
000056  f3c02587          UBFX     r5,r0,#10,#8
00005a  f3c01644          UBFX     r6,r0,#5,#5
00005e  40b5              LSLS     r5,r5,r6
000060  43ac              BICS     r4,r4,r5
000062  4314              ORRS     r4,r4,r2
000064  601c              STR      r4,[r3,#0]
                  |L27.102|
;;;551        }
;;;552    
;;;553        if(MODULE_CLKSEL_Msk(u32ModuleIdx) != MODULE_NoMsk)
000066  0e42              LSRS     r2,r0,#25
000068  0752              LSLS     r2,r2,#29
00006a  d00e              BEQ      |L27.138|
;;;554        {
;;;555            /* Get clock select control register address */
;;;556            u32sel = (uint32_t)&CLK->CLKSEL0 + ((MODULE_CLKSEL(u32ModuleIdx)) * 4U);
00006c  4b08              LDR      r3,|L27.144|
00006e  f3c07201          UBFX     r2,r0,#28,#2
000072  3b18              SUBS     r3,r3,#0x18
000074  eb030282          ADD      r2,r3,r2,LSL #2
;;;557            /* Set new clock selection setting */
;;;558            M32(u32sel) = (M32(u32sel) & (~(MODULE_CLKSEL_Msk(u32ModuleIdx) << MODULE_CLKSEL_Pos(u32ModuleIdx)))) | u32ClkSrc;
000078  6813              LDR      r3,[r2,#0]
00007a  f3c06442          UBFX     r4,r0,#25,#3
00007e  f3c05004          UBFX     r0,r0,#20,#5
000082  4084              LSLS     r4,r4,r0
000084  43a3              BICS     r3,r3,r4
000086  430b              ORRS     r3,r3,r1
000088  6013              STR      r3,[r2,#0]
                  |L27.138|
;;;559        }
;;;560    }
00008a  bdf0              POP      {r4-r7,pc}
;;;561    
                          ENDP

                  |L27.140|
                          DCD      0x4000022c
                  |L27.144|
                          DCD      0x40000228

                          AREA ||i.CLK_SetPowerDownMode||, CODE, READONLY, ALIGN=1

                  CLK_SetPowerDownMode PROC
;;;1041   
;;;1042   void CLK_SetPowerDownMode(uint32_t u32PDMode)
000000  b530              PUSH     {r4,r5,lr}
;;;1043   {
;;;1044       if ((SYS->CSERVER & SYS_CSERVER_VERSION_Msk) == 0x1) // M480LD
000002  f04f4580          MOV      r5,#0x40000000
000006  4604              MOV      r4,r0                 ;1043
000008  f8d501f4          LDR      r0,[r5,#0x1f4]
00000c  b2c0              UXTB     r0,r0
00000e  2801              CMP      r0,#1
000010  d004              BEQ      |L28.28|
;;;1045       {
;;;1046           if(u32PDMode == CLK_PMUCTL_PDMSEL_SPD0)
;;;1047           {
;;;1048               u32PDMode = CLK_PMUCTL_PDMSEL_SPD0;
;;;1049               CLK->PMUCTL = (CLK->PMUCTL & ~(CLK_PMUCTL_SRETSEL_Msk)) | CLK_SPDSRETSEL_16K;
;;;1050           }
;;;1051           else if(u32PDMode == CLK_PMUCTL_PDMSEL_SPD1)
;;;1052           {
;;;1053               u32PDMode = CLK_PMUCTL_PDMSEL_SPD0;
;;;1054               CLK->PMUCTL = (CLK->PMUCTL & ~(CLK_PMUCTL_SRETSEL_Msk)) | CLK_SPDSRETSEL_NO;
;;;1055           }
;;;1056       }
;;;1057       else
;;;1058       {
;;;1059           /* Enable LIRC clock before entering to Standby Power-down Mode */
;;;1060           if((u32PDMode == CLK_PMUCTL_PDMSEL_SPD0) || (u32PDMode == CLK_PMUCTL_PDMSEL_SPD1))
000012  2c04              CMP      r4,#4
000014  d016              BEQ      |L28.68|
000016  2c05              CMP      r4,#5
000018  d014              BEQ      |L28.68|
00001a  e01c              B        |L28.86|
                  |L28.28|
00001c  2c04              CMP      r4,#4                 ;1046
00001e  d002              BEQ      |L28.38|
000020  2c05              CMP      r4,#5                 ;1051
000022  d007              BEQ      |L28.52|
000024  e017              B        |L28.86|
                  |L28.38|
000026  f8d50290          LDR      r0,[r5,#0x290]        ;1049
00002a  f0200070          BIC      r0,r0,#0x70           ;1049
00002e  f0400010          ORR      r0,r0,#0x10           ;1049
000032  e004              B        |L28.62|
                  |L28.52|
000034  f8d50290          LDR      r0,[r5,#0x290]        ;1054
000038  2404              MOVS     r4,#4                 ;1053
00003a  f0200070          BIC      r0,r0,#0x70           ;1054
                  |L28.62|
00003e  f8c50290          STR      r0,[r5,#0x290]        ;1054
000042  e008              B        |L28.86|
                  |L28.68|
;;;1061           {
;;;1062               /* Enable LIRC clock */
;;;1063               CLK->PWRCTL |= CLK_PWRCTL_LIRCEN_Msk;
000044  f8d50200          LDR      r0,[r5,#0x200]
000048  f0400008          ORR      r0,r0,#8
00004c  f8c50200          STR      r0,[r5,#0x200]
;;;1064   
;;;1065               /* Wait for LIRC clock stable */
;;;1066               CLK_WaitClockReady(CLK_STATUS_LIRCSTB_Msk);
000050  2008              MOVS     r0,#8
000052  f7fffffe          BL       CLK_WaitClockReady
                  |L28.86|
;;;1067           }
;;;1068       }
;;;1069   
;;;1070       CLK->PMUCTL = (CLK->PMUCTL & ~(CLK_PMUCTL_PDMSEL_Msk)) | u32PDMode;
000056  f8d50290          LDR      r0,[r5,#0x290]
00005a  f0200007          BIC      r0,r0,#7
00005e  4320              ORRS     r0,r0,r4
000060  f8c50290          STR      r0,[r5,#0x290]
;;;1071   }
000064  bd30              POP      {r4,r5,pc}
;;;1072   
                          ENDP


                          AREA ||i.CLK_SetSysTickClockSrc||, CODE, READONLY, ALIGN=1

                  CLK_SetSysTickClockSrc PROC
;;;573      */
;;;574    void CLK_SetSysTickClockSrc(uint32_t u32ClkSrc)
000000  f04f4180          MOV      r1,#0x40000000
;;;575    {
;;;576        CLK->CLKSEL0 = (CLK->CLKSEL0 & ~CLK_CLKSEL0_STCLKSEL_Msk) | u32ClkSrc;
000004  f8d12210          LDR      r2,[r1,#0x210]
000008  f0220238          BIC      r2,r2,#0x38
00000c  4302              ORRS     r2,r2,r0
00000e  f8c12210          STR      r2,[r1,#0x210]
;;;577    
;;;578    }
000012  4770              BX       lr
;;;579    
                          ENDP


                          AREA ||i.CLK_WaitClockReady||, CODE, READONLY, ALIGN=2

                  CLK_WaitClockReady PROC
;;;959      */
;;;960    uint32_t CLK_WaitClockReady(uint32_t u32ClkMask)
000000  b530              PUSH     {r4,r5,lr}
;;;961    {
;;;962        int32_t i32TimeOutCnt = 2160000;
;;;963        uint32_t u32Ret = 1U;
000002  2401              MOVS     r4,#1
000004  4605              MOV      r5,r0                 ;961
000006  4908              LDR      r1,|L30.40|
;;;964    
;;;965        while((CLK->STATUS & u32ClkMask) != u32ClkMask)
000008  07a2              LSLS     r2,r4,#30
00000a  e005              B        |L30.24|
                  |L30.12|
;;;966        {
;;;967            if(i32TimeOutCnt-- <= 0)
00000c  1e08              SUBS     r0,r1,#0
00000e  f1a10101          SUB      r1,r1,#1
000012  dc01              BGT      |L30.24|
;;;968            {
;;;969                u32Ret = 0U;
000014  2400              MOVS     r4,#0
;;;970                break;
000016  e004              B        |L30.34|
                  |L30.24|
000018  f8d23250          LDR      r3,[r2,#0x250]        ;965
00001c  ea350003          BICS     r0,r5,r3              ;965
000020  d1f4              BNE      |L30.12|
                  |L30.34|
;;;971            }
;;;972        }
;;;973        return u32Ret;
000022  4620              MOV      r0,r4
;;;974    }
000024  bd30              POP      {r4,r5,pc}
;;;975    
                          ENDP

000026  0000              DCW      0x0000
                  |L30.40|
                          DCD      0x0020f580

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                          DCD      0x00000000
                          DCD      0x00000004
                          DCD      0x00000008
                          DCD      0x0000000c
                          DCD      0x00000000
                          DCD      0x00000004
                          DCD      0x0000000c
                          DCD      0x00000010

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\Library\\StdDriver\\src\\clk.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_clk_c_9b5832dc____REV16|
#line 388 "..\\..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___5_clk_c_9b5832dc____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_clk_c_9b5832dc____REVSH|
#line 402
|__asm___5_clk_c_9b5832dc____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___5_clk_c_9b5832dc____RRX|
#line 587
|__asm___5_clk_c_9b5832dc____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
