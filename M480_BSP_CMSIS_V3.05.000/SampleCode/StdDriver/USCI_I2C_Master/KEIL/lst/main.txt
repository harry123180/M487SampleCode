; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\main.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\main.d --cpu=Cortex-M4.fp.sp --apcs=interwork --diag_suppress=9931 -I..\..\..\..\Library\CMSIS\Include -I..\..\..\..\Library\Device\Nuvoton\M480\Include -I..\..\..\..\Library\StdDriver\inc -ID:\ARM\RV31\INC -ID:\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=531 --omf_browse=.\obj\main.crf ..\main.c]
                          THUMB

                          AREA ||i.Read_Write_SLAVE||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  Read_Write_SLAVE PROC
;;;252    
;;;253    int32_t Read_Write_SLAVE(uint8_t slvaddr)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;254    {
;;;255        uint32_t i;
;;;256    
;;;257        g_u8DeviceAddr = slvaddr;
000004  4b22              LDR      r3,|L1.144|
;;;258    
;;;259        for (i = 0; i < 2; i++)
000006  2200              MOVS     r2,#0
;;;260        {
;;;261            g_au8MstTxData[0] = (uint8_t)((i & 0xFF00) >> 8);
;;;262            g_au8MstTxData[1] = (uint8_t)(i & 0x00FF);
;;;263            g_au8MstTxData[2] = (uint8_t)(g_au8MstTxData[1] + 3);
;;;264    
;;;265            g_u8MstDataLen = 0;
;;;266            g_u8MstEndFlag = 0;
;;;267    
;;;268            /* USCI_I2C function to write data to slave */
;;;269            s_UI2C0HandlerFn = (UI2C_FUNC)USCI_I2C_MasterTx;
000008  f8dfe088          LDR      lr,|L1.148|
;;;270    
;;;271            /* USCI_I2C as master sends START signal */
;;;272            m_Event = MASTER_SEND_START;
;;;273            UI2C_SET_CONTROL_REG(UI2C0, UI2C_CTL_STA);
00000c  4d22              LDR      r5,|L1.152|
00000e  7058              STRB     r0,[r3,#1]            ;257
000010  2712              MOVS     r7,#0x12              ;272
000012  4616              MOV      r6,r2
000014  f1030c05          ADD      r12,r3,#5             ;261
                  |L1.24|
000018  0a11              LSRS     r1,r2,#8              ;261
00001a  f88c1000          STRB     r1,[r12,#0]           ;261
00001e  1cd1              ADDS     r1,r2,#3              ;263
000020  f88c2001          STRB     r2,[r12,#1]           ;262
000024  b2c9              UXTB     r1,r1                 ;263
000026  f88c1002          STRB     r1,[r12,#2]           ;263
00002a  70de              STRB     r6,[r3,#3]            ;265
00002c  701e              STRB     r6,[r3,#0]            ;266
00002e  f8c3e008          STR      lr,[r3,#8]            ;272  ; s_UI2C0HandlerFn
000032  711f              STRB     r7,[r3,#4]            ;272
000034  6dec              LDR      r4,[r5,#0x5c]
000036  f024042e          BIC      r4,r4,#0x2e
00003a  f0440408          ORR      r4,r4,#8
00003e  65ec              STR      r4,[r5,#0x5c]
                  |L1.64|
;;;274    
;;;275            /* Wait USCI_I2C Tx Finish */
;;;276            while (g_u8MstEndFlag == 0);
000040  781c              LDRB     r4,[r3,#0]  ; g_u8MstEndFlag
000042  2c00              CMP      r4,#0
000044  d0fc              BEQ      |L1.64|
;;;277            g_u8MstEndFlag = 0;
000046  701e              STRB     r6,[r3,#0]
;;;278    
;;;279            /* USCI_I2C function to read data from slave */
;;;280            s_UI2C0HandlerFn = (UI2C_FUNC)USCI_I2C_MasterRx;
000048  4c14              LDR      r4,|L1.156|
;;;281    
;;;282            g_u8MstDataLen = 0;
00004a  609c              STR      r4,[r3,#8]  ; s_UI2C0HandlerFn
00004c  70de              STRB     r6,[r3,#3]
;;;283            g_u8DeviceAddr = slvaddr;
00004e  7058              STRB     r0,[r3,#1]
;;;284    
;;;285            m_Event = MASTER_SEND_START;
000050  711f              STRB     r7,[r3,#4]
;;;286            UI2C_SET_CONTROL_REG(UI2C0, UI2C_CTL_STA);
000052  6dec              LDR      r4,[r5,#0x5c]
000054  f024042e          BIC      r4,r4,#0x2e
000058  f0440408          ORR      r4,r4,#8
00005c  65ec              STR      r4,[r5,#0x5c]
                  |L1.94|
;;;287    
;;;288            /* Wait USCI_I2C Rx Finish */
;;;289            while(g_u8MstEndFlag == 0);
00005e  781c              LDRB     r4,[r3,#0]  ; g_u8MstEndFlag
000060  2c00              CMP      r4,#0
000062  d0fc              BEQ      |L1.94|
;;;290            g_u8MstEndFlag = 0;
000064  701e              STRB     r6,[r3,#0]
;;;291    
;;;292            /* Compare data */
;;;293            if (g_u8MstRxData != g_au8MstTxData[2])
000066  789c              LDRB     r4,[r3,#2]  ; g_u8MstRxData
000068  42a1              CMP      r1,r4
00006a  d007              BEQ      |L1.124|
;;;294            {
;;;295                printf("USCI_I2C Byte Write/Read Failed, Data 0x%x\n", g_u8MstRxData);
00006c  7899              LDRB     r1,[r3,#2]  ; g_u8MstRxData
00006e  a00c              ADR      r0,|L1.160|
000070  f7fffffe          BL       __2printf
;;;296                return -1;
000074  f04f30ff          MOV      r0,#0xffffffff
                  |L1.120|
;;;297            }
;;;298        }
;;;299        printf("Master Access Slave (0x%X) Test OK\n", slvaddr);
;;;300        return 0;
;;;301    }
000078  e8bd81f0          POP      {r4-r8,pc}
                  |L1.124|
00007c  1c52              ADDS     r2,r2,#1
00007e  2a02              CMP      r2,#2                 ;259
000080  d3ca              BCC      |L1.24|
000082  4601              MOV      r1,r0                 ;299
000084  a011              ADR      r0,|L1.204|
000086  f7fffffe          BL       __2printf
00008a  2000              MOVS     r0,#0                 ;300
00008c  e7f4              B        |L1.120|
;;;302    
                          ENDP

00008e  0000              DCW      0x0000
                  |L1.144|
                          DCD      ||.data||
                  |L1.148|
                          DCD      USCI_I2C_MasterTx
                  |L1.152|
                          DCD      0x400d0000
                  |L1.156|
                          DCD      USCI_I2C_MasterRx
                  |L1.160|
0000a0  55534349          DCB      "USCI_I2C Byte Write/Read Failed, Data 0x%x\n",0
0000a4  5f493243
0000a8  20427974
0000ac  65205772
0000b0  6974652f
0000b4  52656164
0000b8  20466169
0000bc  6c65642c
0000c0  20446174
0000c4  61203078
0000c8  25780a00
                  |L1.204|
0000cc  4d617374          DCB      "Master Access Slave (0x%X) Test OK\n",0
0000d0  65722041
0000d4  63636573
0000d8  7320536c
0000dc  61766520
0000e0  28307825
0000e4  58292054
0000e8  65737420
0000ec  4f4b0a00

                          AREA ||i.SYS_Init||, CODE, READONLY, ALIGN=2

                  SYS_Init PROC
;;;194    
;;;195    void SYS_Init(void)
000000  b570              PUSH     {r4-r6,lr}
;;;196    {
;;;197        /* Set XT1_OUT(PF.2) and XT1_IN(PF.3) to input mode */
;;;198        PF->MODE &= ~(GPIO_MODE_MODE2_Msk | GPIO_MODE_MODE3_Msk);
000002  f04f2540          MOV      r5,#0x40004000
000006  f8d50140          LDR      r0,[r5,#0x140]
00000a  f02000f0          BIC      r0,r0,#0xf0
00000e  f8c50140          STR      r0,[r5,#0x140]
;;;199    
;;;200        /* Enable external XTAL 12MHz clock */
;;;201        CLK_EnableXtalRC(CLK_PWRCTL_HXTEN_Msk);
000012  2001              MOVS     r0,#1
000014  f7fffffe          BL       CLK_EnableXtalRC
;;;202    
;;;203        /* Waiting for external XTAL clock ready */
;;;204        CLK_WaitClockReady(CLK_STATUS_HXTSTB_Msk);
000018  2001              MOVS     r0,#1
00001a  f7fffffe          BL       CLK_WaitClockReady
;;;205    
;;;206        /* Set core clock as PLL_CLOCK from PLL */
;;;207        CLK_SetCoreClock(PLL_CLOCK);
00001e  4814              LDR      r0,|L2.112|
000020  f7fffffe          BL       CLK_SetCoreClock
;;;208    
;;;209        /* Set PCLK0 = PCLK1 = HCLK/2 */
;;;210        CLK->PCLKDIV = (CLK_PCLKDIV_APB0DIV_DIV2 | CLK_PCLKDIV_APB1DIV_DIV2);
000024  2011              MOVS     r0,#0x11
000026  0784              LSLS     r4,r0,#30
000028  f8c40234          STR      r0,[r4,#0x234]
;;;211    
;;;212        /* Enable UART module clock */
;;;213        CLK_EnableModuleClock(UART0_MODULE);
00002c  4e11              LDR      r6,|L2.116|
00002e  4630              MOV      r0,r6
000030  f7fffffe          BL       CLK_EnableModuleClock
;;;214    
;;;215        /* Enable IP clock */
;;;216        CLK_EnableModuleClock(USCI0_MODULE);
000034  4810              LDR      r0,|L2.120|
000036  f7fffffe          BL       CLK_EnableModuleClock
;;;217    
;;;218        /* Select UART module clock source */
;;;219        CLK_SetModuleClock(UART0_MODULE, CLK_CLKSEL1_UART0SEL_HXT, CLK_CLKDIV0_UART0(1));
00003a  2200              MOVS     r2,#0
00003c  4611              MOV      r1,r2
00003e  4630              MOV      r0,r6
000040  f7fffffe          BL       CLK_SetModuleClock
;;;220    
;;;221        /* Update System Core Clock */
;;;222        /* User can use SystemCoreClockUpdate() to calculate SystemCoreClock and cyclesPerUs automatically. */
;;;223        SystemCoreClockUpdate();
000044  f7fffffe          BL       SystemCoreClockUpdate
;;;224    
;;;225    
;;;226        /* Set GPB multi-function pins for UART0 RXD and TXD */
;;;227        SYS->GPB_MFPH &= ~(SYS_GPB_MFPH_PB12MFP_Msk | SYS_GPB_MFPH_PB13MFP_Msk);
000048  6be0              LDR      r0,[r4,#0x3c]
00004a  f420007f          BIC      r0,r0,#0xff0000
00004e  63e0              STR      r0,[r4,#0x3c]
;;;228        SYS->GPB_MFPH |= (SYS_GPB_MFPH_PB12MFP_UART0_RXD | SYS_GPB_MFPH_PB13MFP_UART0_TXD);
000050  6be0              LDR      r0,[r4,#0x3c]
000052  f44000cc          ORR      r0,r0,#0x660000
000056  63e0              STR      r0,[r4,#0x3c]
;;;229    
;;;230        /* Set UI2C0 multi-function pins */
;;;231        SYS->GPA_MFPH = (SYS->GPA_MFPH & ~(SYS_GPA_MFPH_PA11MFP_Msk | SYS_GPA_MFPH_PA10MFP_Msk)) |
000058  6b60              LDR      r0,[r4,#0x34]
00005a  f420407f          BIC      r0,r0,#0xff00
00005e  f44040cc          ORR      r0,r0,#0x6600
000062  6360              STR      r0,[r4,#0x34]
;;;232                        (SYS_GPA_MFPH_PA11MFP_USCI0_CLK | SYS_GPA_MFPH_PA10MFP_USCI0_DAT0);
;;;233    
;;;234        /* USCI_I2C clock pin enable schmitt trigger */
;;;235        PA->SMTEN |= GPIO_SMTEN_SMTEN11_Msk;
000064  6a68              LDR      r0,[r5,#0x24]
000066  f4406000          ORR      r0,r0,#0x800
00006a  6268              STR      r0,[r5,#0x24]
;;;236    }
00006c  bd70              POP      {r4-r6,pc}
;;;237    
                          ENDP

00006e  0000              DCW      0x0000
                  |L2.112|
                          DCD      0x0b71b000
                  |L2.116|
                          DCD      0x57803d10
                  |L2.120|
                          DCD      0x80000008

                          AREA ||i.UI2C0_Init||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  UI2C0_Init PROC
;;;237    
;;;238    void UI2C0_Init(void)
000000  b510              PUSH     {r4,lr}
;;;239    {
;;;240        /* Open USCI_I2C0 and set clock to 100k */
;;;241        UI2C_Open(UI2C0, 100000);
000002  4c0f              LDR      r4,|L3.64|
000004  490d              LDR      r1,|L3.60|
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       UI2C_Open
;;;242    
;;;243        /* Get UI2C0 Bus Clock */
;;;244        printf("UI2C clock %d Hz\n", UI2C_GetBusClockFreq(UI2C0));
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       UI2C_GetBusClockFreq
000012  4601              MOV      r1,r0
000014  a00b              ADR      r0,|L3.68|
000016  f7fffffe          BL       __2printf
;;;245    
;;;246        /* Set UI2C1 Slave Addresses */
;;;247        UI2C_SetSlaveAddr(UI2C0, 0, 0x15, UI2C_GCMODE_DISABLE);   /* Slave Address : 0x15 */
00001a  2300              MOVS     r3,#0
00001c  2215              MOVS     r2,#0x15
00001e  4619              MOV      r1,r3
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       UI2C_SetSlaveAddr
;;;248    
;;;249        UI2C_ENABLE_PROT_INT(UI2C0, (UI2C_PROTIEN_ACKIEN_Msk | UI2C_PROTIEN_NACKIEN_Msk | UI2C_PROTIEN_STORIEN_Msk | UI2C_PROTIEN_STARIEN_Msk));
000026  6e20              LDR      r0,[r4,#0x60]
000028  f040004e          ORR      r0,r0,#0x4e
00002c  6620              STR      r0,[r4,#0x60]
00002e  490a              LDR      r1,|L3.88|
000030  f44f5080          MOV      r0,#0x1000
000034  f8c10100          STR      r0,[r1,#0x100]
;;;250        NVIC_EnableIRQ(USCI0_IRQn);
;;;251    }
000038  bd10              POP      {r4,pc}
;;;252    
                          ENDP

00003a  0000              DCW      0x0000
                  |L3.60|
                          DCD      0x000186a0
                  |L3.64|
                          DCD      0x400d0000
                  |L3.68|
000044  55493243          DCB      "UI2C clock %d Hz\n",0
000048  20636c6f
00004c  636b2025
000050  6420487a
000054  0a00    
000056  00                DCB      0
000057  00                DCB      0
                  |L3.88|
                          DCD      0xe000e008

                          AREA ||i.USCI0_IRQHandler||, CODE, READONLY, ALIGN=2

                  USCI0_IRQHandler PROC
;;;28     
;;;29     void USCI0_IRQHandler(void)
000000  480a              LDR      r0,|L4.44|
;;;30     {
000002  b510              PUSH     {r4,lr}
;;;31         uint32_t u32Status;
;;;32     
;;;33         u32Status = (UI2C0->PROTSTS);
000004  6e40              LDR      r0,[r0,#0x64]
;;;34         if (s_UI2C0HandlerFn != NULL)
000006  490a              LDR      r1,|L4.48|
000008  6889              LDR      r1,[r1,#8]  ; s_UI2C0HandlerFn
00000a  2900              CMP      r1,#0                 ;30
00000c  d00d              BEQ      |L4.42|
;;;35         {
;;;36             s_UI2C0HandlerFn(u32Status);
00000e  4788              BLX      r1
000010  4808              LDR      r0,|L4.52|
000012  6801              LDR      r1,[r0,#0]  ; CyclesPerUs
000014  f04f20e0          MOV      r0,#0xe000e000
000018  6141              STR      r1,[r0,#0x14]
00001a  2200              MOVS     r2,#0
00001c  6182              STR      r2,[r0,#0x18]
00001e  2105              MOVS     r1,#5
000020  6101              STR      r1,[r0,#0x10]
                  |L4.34|
000022  6901              LDR      r1,[r0,#0x10]
000024  03c9              LSLS     r1,r1,#15
000026  d5fc              BPL      |L4.34|
000028  6102              STR      r2,[r0,#0x10]
                  |L4.42|
;;;37             CLK_SysTickDelay(1);
;;;38         }
;;;39     }
00002a  bd10              POP      {r4,pc}
;;;40     
                          ENDP

                  |L4.44|
                          DCD      0x400d0000
                  |L4.48|
                          DCD      ||.data||
                  |L4.52|
                          DCD      CyclesPerUs

                          AREA ||i.USCI_I2C_MasterRx||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  USCI_I2C_MasterRx PROC
;;;43     /*---------------------------------------------------------------------------------------------------------*/
;;;44     void USCI_I2C_MasterRx(uint32_t u32Status)
000000  b430              PUSH     {r4,r5}
;;;45     {
;;;46         if (UI2C_GET_TIMEOUT_FLAG(UI2C0))
000002  4940              LDR      r1,|L5.260|
000004  6e4a              LDR      r2,[r1,#0x64]
000006  43d2              MVNS     r2,r2
000008  0692              LSLS     r2,r2,#26
00000a  d403              BMI      |L5.20|
;;;47         {
;;;48             /* Clear USCI_I2C0 Timeout Flag */
;;;49             UI2C_ClearTimeoutFlag(UI2C0);
00000c  bc30              POP      {r4,r5}
00000e  4608              MOV      r0,r1
000010  f7ffbffe          B.W      UI2C_ClearTimeoutFlag
                  |L5.20|
;;;50         }
;;;51         else if((u32Status & UI2C_PROTSTS_STARIF_Msk) == UI2C_PROTSTS_STARIF_Msk)
;;;52         {
;;;53             UI2C_CLR_PROT_INT_FLAG(UI2C0, UI2C_PROTSTS_STARIF_Msk); /* Clear START INT Flag */
;;;54     
;;;55             if(m_Event == MASTER_SEND_START)
000014  4a3c              LDR      r2,|L5.264|
000016  05c4              LSLS     r4,r0,#23             ;51
;;;56             {
;;;57                 UI2C_SET_DATA(UI2C0, (g_u8DeviceAddr << 1) | 0x00); /* Write SLA+W to Register TXDAT */
;;;58                 m_Event = MASTER_SEND_ADDRESS;
;;;59             }
;;;60             else if(m_Event == MASTER_SEND_REPEAT_START)
;;;61             {
;;;62                 UI2C_SET_DATA(UI2C0, (g_u8DeviceAddr << 1) | 0x01); /* Write SLA+R to Register TXDAT */
000018  f04f0301          MOV      r3,#1
00001c  d514              BPL      |L5.72|
00001e  0218              LSLS     r0,r3,#8              ;53
000020  6648              STR      r0,[r1,#0x64]         ;53
000022  7914              LDRB     r4,[r2,#4]            ;55  ; m_Event
000024  4610              MOV      r0,r2                 ;55
000026  2c12              CMP      r4,#0x12              ;55
000028  7840              LDRB     r0,[r0,#1]            ;57
00002a  d003              BEQ      |L5.52|
00002c  7914              LDRB     r4,[r2,#4]            ;60  ; m_Event
00002e  2c0f              CMP      r4,#0xf               ;60
000030  d004              BEQ      |L5.60|
000032  e02c              B        |L5.142|
                  |L5.52|
000034  0040              LSLS     r0,r0,#1              ;57
000036  6308              STR      r0,[r1,#0x30]         ;57
000038  200a              MOVS     r0,#0xa               ;58
00003a  e003              B        |L5.68|
                  |L5.60|
00003c  eb030040          ADD      r0,r3,r0,LSL #1
000040  6308              STR      r0,[r1,#0x30]
;;;63                 m_Event = MASTER_SEND_H_RD_ADDRESS;
000042  200c              MOVS     r0,#0xc
                  |L5.68|
000044  7110              STRB     r0,[r2,#4]
000046  e022              B        |L5.142|
                  |L5.72|
;;;64             }
;;;65     
;;;66             UI2C_SET_CONTROL_REG(UI2C0, UI2C_CTL_PTRG);
;;;67         }
;;;68         else if((u32Status & UI2C_PROTSTS_ACKIF_Msk) == UI2C_PROTSTS_ACKIF_Msk)
000048  0484              LSLS     r4,r0,#18
00004a  d52b              BPL      |L5.164|
;;;69         {
;;;70             UI2C_CLR_PROT_INT_FLAG(UI2C0, UI2C_PROTSTS_ACKIF_Msk);  /* Clear ACK INT Flag */
00004c  f44f5000          MOV      r0,#0x2000
000050  6648              STR      r0,[r1,#0x64]
;;;71     
;;;72             if(m_Event == MASTER_SEND_ADDRESS)
000052  7910              LDRB     r0,[r2,#4]  ; m_Event
;;;73             {
;;;74                 UI2C_SET_DATA(UI2C0, g_au8MstTxData[g_u8MstDataLen++]);  /* SLA+W has been transmitted and write ADDRESS to Register TXDAT */
000054  4b2c              LDR      r3,|L5.264|
000056  1d5b              ADDS     r3,r3,#5
000058  280a              CMP      r0,#0xa               ;72
00005a  d007              BEQ      |L5.108|
;;;75                 m_Event = MASTER_SEND_DATA;
;;;76                 UI2C_SET_CONTROL_REG(UI2C0, UI2C_CTL_PTRG);
;;;77             }
;;;78             else if(m_Event == MASTER_SEND_DATA)
00005c  7910              LDRB     r0,[r2,#4]  ; m_Event
00005e  280e              CMP      r0,#0xe
000060  d00c              BEQ      |L5.124|
;;;79             {
;;;80                 if(g_u8MstDataLen != 2)
;;;81                 {
;;;82                     UI2C_SET_DATA(UI2C0, g_au8MstTxData[g_u8MstDataLen++]);  /* ADDRESS has been transmitted and write DATA to Register TXDAT */
;;;83                     UI2C_SET_CONTROL_REG(UI2C0, UI2C_CTL_PTRG);
;;;84                 }
;;;85                 else
;;;86                 {
;;;87                     m_Event = MASTER_SEND_REPEAT_START;
;;;88                     UI2C_SET_CONTROL_REG(UI2C0, (UI2C_CTL_PTRG | UI2C_CTL_STA));    /* Send repeat START signal */
;;;89                 }
;;;90             }
;;;91             else if(m_Event == MASTER_SEND_H_RD_ADDRESS)
000062  7910              LDRB     r0,[r2,#4]  ; m_Event
000064  280c              CMP      r0,#0xc
000066  d11b              BNE      |L5.160|
;;;92             {
;;;93                 m_Event = MASTER_READ_DATA;
000068  2010              MOVS     r0,#0x10
;;;94                 UI2C_SET_CONTROL_REG(UI2C0, UI2C_CTL_PTRG);
00006a  e7eb              B        |L5.68|
                  |L5.108|
00006c  78d0              LDRB     r0,[r2,#3]            ;74  ; g_u8MstDataLen
00006e  4403              ADD      r3,r3,r0              ;74
000070  1c40              ADDS     r0,r0,#1              ;74
000072  70d0              STRB     r0,[r2,#3]            ;74
000074  7818              LDRB     r0,[r3,#0]            ;74
000076  6308              STR      r0,[r1,#0x30]         ;74
000078  200e              MOVS     r0,#0xe               ;75
00007a  e7e3              B        |L5.68|
                  |L5.124|
00007c  78d0              LDRB     r0,[r2,#3]            ;80  ; g_u8MstDataLen
00007e  2802              CMP      r0,#2                 ;80
000080  d00b              BEQ      |L5.154|
000082  78d0              LDRB     r0,[r2,#3]            ;82  ; g_u8MstDataLen
000084  4403              ADD      r3,r3,r0              ;82
000086  1c40              ADDS     r0,r0,#1              ;82
000088  70d0              STRB     r0,[r2,#3]            ;82
00008a  7818              LDRB     r0,[r3,#0]            ;82
00008c  6308              STR      r0,[r1,#0x30]         ;82
                  |L5.142|
00008e  6dc8              LDR      r0,[r1,#0x5c]         ;76
000090  f020002e          BIC      r0,r0,#0x2e           ;76
000094  f0400020          ORR      r0,r0,#0x20           ;76
000098  e001              B        |L5.158|
                  |L5.154|
00009a  200f              MOVS     r0,#0xf               ;87
00009c  e013              B        |L5.198|
                  |L5.158|
00009e  65c8              STR      r0,[r1,#0x5c]         ;66
                  |L5.160|
;;;95             }
;;;96         }
;;;97         else if((u32Status & UI2C_PROTSTS_NACKIF_Msk) == UI2C_PROTSTS_NACKIF_Msk)
;;;98         {
;;;99             UI2C_CLR_PROT_INT_FLAG(UI2C0, UI2C_PROTSTS_NACKIF_Msk); /* Clear NACK INT Flag */
;;;100    
;;;101            if(m_Event == MASTER_SEND_ADDRESS)
;;;102            {
;;;103                m_Event = MASTER_SEND_START;
;;;104                UI2C_SET_CONTROL_REG(UI2C0, (UI2C_CTL_PTRG | UI2C_CTL_STA));    /* Send START signal */
;;;105            }
;;;106            else if(m_Event == MASTER_READ_DATA)
;;;107            {
;;;108                g_u8MstRxData = (unsigned char) UI2C_GET_DATA(UI2C0) & 0xFF;
;;;109                m_Event = MASTER_STOP;
;;;110                UI2C_SET_CONTROL_REG(UI2C0, (UI2C_CTL_PTRG | UI2C_CTL_STO));    /* DATA has been received and send STOP signal */
;;;111            }
;;;112            else
;;;113                /* TO DO */
;;;114                printf("Status 0x%x is NOT processed\n", u32Status);
;;;115        }
;;;116        else if((u32Status & UI2C_PROTSTS_STORIF_Msk) == UI2C_PROTSTS_STORIF_Msk)
;;;117        {
;;;118            UI2C_CLR_PROT_INT_FLAG(UI2C0, UI2C_PROTSTS_STORIF_Msk);  /* Clear STOP INT Flag */
;;;119            UI2C_SET_CONTROL_REG(UI2C0, UI2C_CTL_PTRG);
;;;120            g_u8MstEndFlag = 1;
;;;121        }
;;;122    }
0000a0  bc30              POP      {r4,r5}
0000a2  4770              BX       lr
                  |L5.164|
0000a4  0544              LSLS     r4,r0,#21             ;97
0000a6  d51f              BPL      |L5.232|
0000a8  f44f6380          MOV      r3,#0x400             ;99
0000ac  664b              STR      r3,[r1,#0x64]         ;99
0000ae  7913              LDRB     r3,[r2,#4]            ;101  ; m_Event
0000b0  2b0a              CMP      r3,#0xa               ;101
0000b2  d007              BEQ      |L5.196|
0000b4  7913              LDRB     r3,[r2,#4]            ;106  ; m_Event
0000b6  2b10              CMP      r3,#0x10              ;106
0000b8  d00c              BEQ      |L5.212|
0000ba  4601              MOV      r1,r0                 ;114
0000bc  bc30              POP      {r4,r5}               ;114
0000be  a013              ADR      r0,|L5.268|
0000c0  f7ffbffe          B.W      __2printf
                  |L5.196|
0000c4  2012              MOVS     r0,#0x12              ;103
                  |L5.198|
0000c6  7110              STRB     r0,[r2,#4]            ;103
0000c8  6dc8              LDR      r0,[r1,#0x5c]         ;104
0000ca  f020002e          BIC      r0,r0,#0x2e           ;104
0000ce  f0400028          ORR      r0,r0,#0x28           ;104
0000d2  e7e4              B        |L5.158|
                  |L5.212|
0000d4  6b48              LDR      r0,[r1,#0x34]         ;108
0000d6  7090              STRB     r0,[r2,#2]            ;108
0000d8  2011              MOVS     r0,#0x11              ;109
0000da  7110              STRB     r0,[r2,#4]            ;109
0000dc  6dc8              LDR      r0,[r1,#0x5c]         ;110
0000de  f020002e          BIC      r0,r0,#0x2e           ;110
0000e2  f0400024          ORR      r0,r0,#0x24           ;110
0000e6  e7da              B        |L5.158|
                  |L5.232|
0000e8  0580              LSLS     r0,r0,#22             ;116
0000ea  d5d9              BPL      |L5.160|
0000ec  f44f7000          MOV      r0,#0x200             ;118
0000f0  6648              STR      r0,[r1,#0x64]         ;118
0000f2  6dc8              LDR      r0,[r1,#0x5c]         ;119
0000f4  f020002e          BIC      r0,r0,#0x2e           ;119
0000f8  f0400020          ORR      r0,r0,#0x20           ;119
0000fc  65c8              STR      r0,[r1,#0x5c]         ;119
0000fe  7013              STRB     r3,[r2,#0]            ;120
000100  e7ce              B        |L5.160|
;;;123    
                          ENDP

000102  0000              DCW      0x0000
                  |L5.260|
                          DCD      0x400d0000
                  |L5.264|
                          DCD      ||.data||
                  |L5.268|
00010c  53746174          DCB      "Status 0x%x is NOT processed\n",0
000110  75732030
000114  78257820
000118  6973204e
00011c  4f542070
000120  726f6365
000124  73736564
000128  0a00    
00012a  00                DCB      0
00012b  00                DCB      0

                          AREA ||i.USCI_I2C_MasterTx||, CODE, READONLY, ALIGN=2

                  USCI_I2C_MasterTx PROC
;;;126    /*---------------------------------------------------------------------------------------------------------*/
;;;127    void USCI_I2C_MasterTx(uint32_t u32Status)
000000  4935              LDR      r1,|L6.216|
;;;128    {
000002  b430              PUSH     {r4,r5}
;;;129        if (UI2C_GET_TIMEOUT_FLAG(UI2C0))
000004  6e4a              LDR      r2,[r1,#0x64]
000006  43d2              MVNS     r2,r2
000008  0692              LSLS     r2,r2,#26
00000a  d403              BMI      |L6.20|
;;;130        {
;;;131            /* Clear USCI_I2C0 Timeout Flag */
;;;132            UI2C_ClearTimeoutFlag(UI2C0);
00000c  bc30              POP      {r4,r5}
00000e  4608              MOV      r0,r1
000010  f7ffbffe          B.W      UI2C_ClearTimeoutFlag
                  |L6.20|
;;;133        }
;;;134        else if((u32Status & UI2C_PROTSTS_STARIF_Msk) == UI2C_PROTSTS_STARIF_Msk)
;;;135        {
;;;136            UI2C_CLR_PROT_INT_FLAG(UI2C0, UI2C_PROTSTS_STARIF_Msk); /* Clear START INT Flag */
;;;137    
;;;138            UI2C_SET_DATA(UI2C0, (g_u8DeviceAddr << 1) | 0x00);     /* Write SLA+W to Register TXDAT */
000014  4a31              LDR      r2,|L6.220|
000016  05c3              LSLS     r3,r0,#23             ;134
000018  d507              BPL      |L6.42|
00001a  f44f7080          MOV      r0,#0x100             ;136
00001e  6648              STR      r0,[r1,#0x64]         ;136
000020  7850              LDRB     r0,[r2,#1]  ; g_u8DeviceAddr
000022  0040              LSLS     r0,r0,#1
000024  6308              STR      r0,[r1,#0x30]
;;;139            m_Event = MASTER_SEND_ADDRESS;
000026  200a              MOVS     r0,#0xa
;;;140    
;;;141            UI2C_SET_CONTROL_REG(UI2C0, UI2C_CTL_PTRG);
000028  e026              B        |L6.120|
                  |L6.42|
;;;142        }
;;;143        else if((u32Status & UI2C_PROTSTS_ACKIF_Msk) == UI2C_PROTSTS_ACKIF_Msk)
00002a  0484              LSLS     r4,r0,#18
;;;144        {
;;;145            UI2C_CLR_PROT_INT_FLAG(UI2C0, UI2C_PROTSTS_ACKIF_Msk);  /* Clear ACK INT Flag */
;;;146    
;;;147            if(m_Event == MASTER_SEND_ADDRESS)
;;;148            {
;;;149                UI2C_SET_DATA(UI2C0, g_au8MstTxData[g_u8MstDataLen++]);  /* SLA+W has been transmitted and write ADDRESS to Register TXDAT */
;;;150                m_Event = MASTER_SEND_DATA;
;;;151                UI2C_SET_CONTROL_REG(UI2C0, UI2C_CTL_PTRG);
;;;152            }
;;;153            else if(m_Event == MASTER_SEND_DATA)
;;;154            {
;;;155                if(g_u8MstDataLen != 3)
;;;156                {
;;;157                    UI2C_SET_DATA(UI2C0, g_au8MstTxData[g_u8MstDataLen++]);  /* ADDRESS has been transmitted and write DATA to Register TXDAT */
;;;158                    UI2C_SET_CONTROL_REG(UI2C0, UI2C_CTL_PTRG);
;;;159                }
;;;160                else
;;;161                {
;;;162                    m_Event = MASTER_STOP;
00002c  f04f0311          MOV      r3,#0x11
000030  d524              BPL      |L6.124|
000032  f44f5000          MOV      r0,#0x2000            ;145
000036  6648              STR      r0,[r1,#0x64]         ;145
000038  7910              LDRB     r0,[r2,#4]            ;147  ; m_Event
00003a  4c28              LDR      r4,|L6.220|
00003c  1d64              ADDS     r4,r4,#5              ;149
00003e  280a              CMP      r0,#0xa               ;147
000040  d013              BEQ      |L6.106|
000042  7910              LDRB     r0,[r2,#4]            ;153  ; m_Event
000044  280e              CMP      r0,#0xe               ;153
000046  d10e              BNE      |L6.102|
000048  78d0              LDRB     r0,[r2,#3]            ;155  ; g_u8MstDataLen
00004a  2803              CMP      r0,#3                 ;155
00004c  d02f              BEQ      |L6.174|
00004e  78d0              LDRB     r0,[r2,#3]            ;157  ; g_u8MstDataLen
000050  1823              ADDS     r3,r4,r0              ;157
000052  1c40              ADDS     r0,r0,#1              ;157
000054  70d0              STRB     r0,[r2,#3]            ;157
000056  7818              LDRB     r0,[r3,#0]            ;157
000058  6308              STR      r0,[r1,#0x30]         ;157
                  |L6.90|
00005a  6dc8              LDR      r0,[r1,#0x5c]         ;141
00005c  f020002e          BIC      r0,r0,#0x2e           ;141
000060  f0400020          ORR      r0,r0,#0x20           ;141
                  |L6.100|
000064  65c8              STR      r0,[r1,#0x5c]         ;141
                  |L6.102|
;;;163                    UI2C_SET_CONTROL_REG(UI2C0, (UI2C_CTL_PTRG | UI2C_CTL_STO));        /* Send STOP signal */
;;;164                }
;;;165            }
;;;166        }
;;;167        else if((u32Status & UI2C_PROTSTS_NACKIF_Msk) == UI2C_PROTSTS_NACKIF_Msk)
;;;168        {
;;;169            UI2C_CLR_PROT_INT_FLAG(UI2C0, UI2C_PROTSTS_NACKIF_Msk); /* Clear NACK INT Flag */
;;;170    
;;;171            g_u8MstEndFlag = 0;
;;;172            if(m_Event == MASTER_SEND_ADDRESS)
;;;173            {
;;;174                /* SLA+W has been transmitted and NACK has been received */
;;;175                m_Event = MASTER_SEND_START;
;;;176                UI2C_SET_CONTROL_REG(UI2C0, (UI2C_CTL_PTRG | UI2C_CTL_STA));            /* Send START signal */
;;;177            }
;;;178            else if(m_Event == MASTER_SEND_DATA)
;;;179            {
;;;180                /* ADDRESS has been transmitted and NACK has been received */
;;;181                m_Event = MASTER_STOP;
;;;182                UI2C_SET_CONTROL_REG(UI2C0, (UI2C_CTL_PTRG | UI2C_CTL_STO));            /* Send STOP signal */
;;;183            }
;;;184            else
;;;185                printf("Get Wrong NACK Event\n");
;;;186        }
;;;187        else if((u32Status & UI2C_PROTSTS_STORIF_Msk) == UI2C_PROTSTS_STORIF_Msk)
;;;188        {
;;;189            UI2C_CLR_PROT_INT_FLAG(UI2C0, UI2C_PROTSTS_STORIF_Msk);  /* Clear STOP INT Flag */
;;;190            UI2C_SET_CONTROL_REG(UI2C0, UI2C_CTL_PTRG);
;;;191            g_u8MstEndFlag = 1;
;;;192        }
;;;193    }
000066  bc30              POP      {r4,r5}
000068  4770              BX       lr
                  |L6.106|
00006a  78d0              LDRB     r0,[r2,#3]            ;149  ; g_u8MstDataLen
00006c  1823              ADDS     r3,r4,r0              ;149
00006e  1c40              ADDS     r0,r0,#1              ;149
000070  70d0              STRB     r0,[r2,#3]            ;149
000072  7818              LDRB     r0,[r3,#0]            ;149
000074  6308              STR      r0,[r1,#0x30]         ;149
000076  200e              MOVS     r0,#0xe               ;150
                  |L6.120|
000078  7110              STRB     r0,[r2,#4]            ;150
00007a  e7ee              B        |L6.90|
                  |L6.124|
00007c  0544              LSLS     r4,r0,#21             ;167
00007e  d51d              BPL      |L6.188|
000080  f44f6080          MOV      r0,#0x400             ;169
000084  6648              STR      r0,[r1,#0x64]         ;169
000086  2000              MOVS     r0,#0                 ;171
000088  7010              STRB     r0,[r2,#0]            ;171
00008a  7910              LDRB     r0,[r2,#4]            ;172  ; m_Event
00008c  280a              CMP      r0,#0xa               ;172
00008e  d006              BEQ      |L6.158|
000090  7910              LDRB     r0,[r2,#4]            ;178  ; m_Event
000092  280e              CMP      r0,#0xe               ;178
000094  d00b              BEQ      |L6.174|
000096  bc30              POP      {r4,r5}               ;185
000098  a011              ADR      r0,|L6.224|
00009a  f7ffbffe          B.W      __2printf
                  |L6.158|
00009e  2012              MOVS     r0,#0x12              ;175
0000a0  7110              STRB     r0,[r2,#4]            ;175
0000a2  6dc8              LDR      r0,[r1,#0x5c]         ;176
0000a4  f020002e          BIC      r0,r0,#0x2e           ;176
0000a8  f0400028          ORR      r0,r0,#0x28           ;176
0000ac  e7da              B        |L6.100|
                  |L6.174|
0000ae  7113              STRB     r3,[r2,#4]            ;181
0000b0  6dc8              LDR      r0,[r1,#0x5c]         ;182
0000b2  f020002e          BIC      r0,r0,#0x2e           ;182
0000b6  f0400024          ORR      r0,r0,#0x24           ;182
0000ba  e7d3              B        |L6.100|
                  |L6.188|
0000bc  0580              LSLS     r0,r0,#22             ;187
0000be  d5d2              BPL      |L6.102|
0000c0  f44f7000          MOV      r0,#0x200             ;189
0000c4  6648              STR      r0,[r1,#0x64]         ;189
0000c6  6dc8              LDR      r0,[r1,#0x5c]         ;190
0000c8  f020002e          BIC      r0,r0,#0x2e           ;190
0000cc  f0400020          ORR      r0,r0,#0x20           ;190
0000d0  65c8              STR      r0,[r1,#0x5c]         ;190
0000d2  2001              MOVS     r0,#1                 ;191
0000d4  7010              STRB     r0,[r2,#0]            ;191
0000d6  e7c6              B        |L6.102|
;;;194    
                          ENDP

                  |L6.216|
                          DCD      0x400d0000
                  |L6.220|
                          DCD      ||.data||
                  |L6.224|
0000e0  47657420          DCB      "Get Wrong NACK Event\n",0
0000e4  57726f6e
0000e8  67204e41
0000ec  434b2045
0000f0  76656e74
0000f4  0a00    
0000f6  00                DCB      0
0000f7  00                DCB      0

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;303    
;;;304    int main()
000000  2159              MOVS     r1,#0x59
000002  0788              LSLS     r0,r1,#30
000004  2216              MOVS     r2,#0x16
000006  2388              MOVS     r3,#0x88
                  |L7.8|
000008  f8c01100          STR      r1,[r0,#0x100]
00000c  f8c02100          STR      r2,[r0,#0x100]
000010  f8c03100          STR      r3,[r0,#0x100]
000014  f8d04100          LDR      r4,[r0,#0x100]
000018  2c00              CMP      r4,#0
00001a  d0f5              BEQ      |L7.8|
;;;305    {
;;;306        /* Unlock protected registers */
;;;307        SYS_UnlockReg();
;;;308    
;;;309        /* Init System, IP clock and multi-function I/O. */
;;;310        SYS_Init();
00001c  f7fffffe          BL       SYS_Init
;;;311    
;;;312        /* Configure UART0: 115200, 8-bit word, no parity bit, 1 stop bit. */
;;;313        UART_Open(UART0, 115200);
000020  f44f31e1          MOV      r1,#0x1c200
000024  481f              LDR      r0,|L7.164|
000026  f7fffffe          BL       UART_Open
;;;314    
;;;315        /*
;;;316            This sample code sets USCI_I2C bus clock to 100kHz. Then, Master accesses Slave with Byte Write
;;;317            and Byte Read operations, and check if the read data is equal to the programmed data.
;;;318        */
;;;319    
;;;320        printf("+--------------------------------------------------------+\n");
00002a  a01f              ADR      r0,|L7.168|
00002c  f7fffffe          BL       __2printf
;;;321        printf("|  USCI_I2C Driver Sample Code for Master access 7-bit   |\n");
000030  a02c              ADR      r0,|L7.228|
000032  f7fffffe          BL       __2printf
;;;322        printf("|  address Slave. This sample code needs work with       |\n");
000036  a03a              ADR      r0,|L7.288|
000038  f7fffffe          BL       __2printf
;;;323        printf("|  USCI_I2C_Slave sample code                            |\n");
00003c  a047              ADR      r0,|L7.348|
00003e  f7fffffe          BL       __2printf
;;;324        printf("|         UI2C0(Master)  <----> UI2C0(Slave)             |\n");
000042  a055              ADR      r0,|L7.408|
000044  f7fffffe          BL       __2printf
;;;325        printf("|  This sample code requires two boards for testing      |\n");
000048  a062              ADR      r0,|L7.468|
00004a  f7fffffe          BL       __2printf
;;;326        printf("+--------------------------------------------------------+\n");
00004e  a016              ADR      r0,|L7.168|
000050  f7fffffe          BL       __2printf
;;;327    
;;;328        printf("\n");
000054  a06e              ADR      r0,|L7.528|
000056  f7fffffe          BL       __2printf
;;;329        printf("Configure UI2C0 as a Master\n");
00005a  a06e              ADR      r0,|L7.532|
00005c  f7fffffe          BL       __2printf
;;;330        printf("The I/O connection to UI2C0:\n");
000060  a074              ADR      r0,|L7.564|
000062  f7fffffe          BL       __2printf
;;;331        printf("UI2C0_SDA(PA10), UI2C0_SCL(PA11)\n");
000066  a07b              ADR      r0,|L7.596|
000068  f7fffffe          BL       __2printf
;;;332    
;;;333        /* Init USCI_I2C0 */
;;;334        UI2C0_Init();
00006c  f7fffffe          BL       UI2C0_Init
;;;335    
;;;336        /* Access Slave with no address mask */
;;;337        printf("\n");
000070  a067              ADR      r0,|L7.528|
000072  f7fffffe          BL       __2printf
;;;338        printf(" == No Mask Address ==\n");
000076  a080              ADR      r0,|L7.632|
000078  f7fffffe          BL       __2printf
;;;339        Read_Write_SLAVE(0x15);
00007c  2015              MOVS     r0,#0x15
00007e  f7fffffe          BL       Read_Write_SLAVE
;;;340        printf("SLAVE Address test OK.\n");
000082  a083              ADR      r0,|L7.656|
000084  f7fffffe          BL       __2printf
;;;341    
;;;342        /* Access Slave with address mask */
;;;343        printf("\n");
000088  a061              ADR      r0,|L7.528|
00008a  f7fffffe          BL       __2printf
;;;344        printf(" == Mask Address ==\n");
00008e  a086              ADR      r0,|L7.680|
000090  f7fffffe          BL       __2printf
;;;345        Read_Write_SLAVE(0x15 & ~0x01);
000094  2014              MOVS     r0,#0x14
000096  f7fffffe          BL       Read_Write_SLAVE
;;;346        printf("SLAVE Address Mask test OK.\n");
00009a  a089              ADR      r0,|L7.704|
00009c  f7fffffe          BL       __2printf
                  |L7.160|
;;;347    
;;;348        while(1);
0000a0  e7fe              B        |L7.160|
;;;349    }
;;;350    
                          ENDP

0000a2  0000              DCW      0x0000
                  |L7.164|
                          DCD      0x40070000
                  |L7.168|
0000a8  2b2d2d2d          DCB      "+------------------------------------------------------"
0000ac  2d2d2d2d
0000b0  2d2d2d2d
0000b4  2d2d2d2d
0000b8  2d2d2d2d
0000bc  2d2d2d2d
0000c0  2d2d2d2d
0000c4  2d2d2d2d
0000c8  2d2d2d2d
0000cc  2d2d2d2d
0000d0  2d2d2d2d
0000d4  2d2d2d2d
0000d8  2d2d2d2d
0000dc  2d2d2d  
0000df  2d2d2b0a          DCB      "--+\n",0
0000e3  00      
                  |L7.228|
0000e4  7c202055          DCB      "|  USCI_I2C Driver Sample Code for Master access 7-bit "
0000e8  5343495f
0000ec  49324320
0000f0  44726976
0000f4  65722053
0000f8  616d706c
0000fc  6520436f
000100  64652066
000104  6f72204d
000108  61737465
00010c  72206163
000110  63657373
000114  20372d62
000118  697420  
00011b  20207c0a          DCB      "  |\n",0
00011f  00      
                  |L7.288|
000120  7c202061          DCB      "|  address Slave. This sample code needs work with     "
000124  64647265
000128  73732053
00012c  6c617665
000130  2e205468
000134  69732073
000138  616d706c
00013c  6520636f
000140  6465206e
000144  65656473
000148  20776f72
00014c  6b207769
000150  74682020
000154  202020  
000157  20207c0a          DCB      "  |\n",0
00015b  00      
                  |L7.348|
00015c  7c202055          DCB      "|  USCI_I2C_Slave sample code                          "
000160  5343495f
000164  4932435f
000168  536c6176
00016c  65207361
000170  6d706c65
000174  20636f64
000178  65202020
00017c  20202020
000180  20202020
000184  20202020
000188  20202020
00018c  20202020
000190  202020  
000193  20207c0a          DCB      "  |\n",0
000197  00      
                  |L7.408|
000198  7c202020          DCB      "|         UI2C0(Master)  <----> UI2C0(Slave)           "
00019c  20202020
0001a0  20205549
0001a4  32433028
0001a8  4d617374
0001ac  65722920
0001b0  203c2d2d
0001b4  2d2d3e20
0001b8  55493243
0001bc  3028536c
0001c0  61766529
0001c4  20202020
0001c8  20202020
0001cc  202020  
0001cf  20207c0a          DCB      "  |\n",0
0001d3  00      
                  |L7.468|
0001d4  7c202054          DCB      "|  This sample code requires two boards for testing    "
0001d8  68697320
0001dc  73616d70
0001e0  6c652063
0001e4  6f646520
0001e8  72657175
0001ec  69726573
0001f0  2074776f
0001f4  20626f61
0001f8  72647320
0001fc  666f7220
000200  74657374
000204  696e6720
000208  202020  
00020b  20207c0a          DCB      "  |\n",0
00020f  00      
                  |L7.528|
000210  0a00              DCB      "\n",0
000212  00                DCB      0
000213  00                DCB      0
                  |L7.532|
000214  436f6e66          DCB      "Configure UI2C0 as a Master\n",0
000218  69677572
00021c  65205549
000220  32433020
000224  61732061
000228  204d6173
00022c  7465720a
000230  00      
000231  00                DCB      0
000232  00                DCB      0
000233  00                DCB      0
                  |L7.564|
000234  54686520          DCB      "The I/O connection to UI2C0:\n",0
000238  492f4f20
00023c  636f6e6e
000240  65637469
000244  6f6e2074
000248  6f205549
00024c  3243303a
000250  0a00    
000252  00                DCB      0
000253  00                DCB      0
                  |L7.596|
000254  55493243          DCB      "UI2C0_SDA(PA10), UI2C0_SCL(PA11)\n",0
000258  305f5344
00025c  41285041
000260  3130292c
000264  20554932
000268  43305f53
00026c  434c2850
000270  41313129
000274  0a00    
000276  00                DCB      0
000277  00                DCB      0
                  |L7.632|
000278  203d3d20          DCB      " == No Mask Address ==\n",0
00027c  4e6f204d
000280  61736b20
000284  41646472
000288  65737320
00028c  3d3d0a00
                  |L7.656|
000290  534c4156          DCB      "SLAVE Address test OK.\n",0
000294  45204164
000298  64726573
00029c  73207465
0002a0  7374204f
0002a4  4b2e0a00
                  |L7.680|
0002a8  203d3d20          DCB      " == Mask Address ==\n",0
0002ac  4d61736b
0002b0  20416464
0002b4  72657373
0002b8  203d3d0a
0002bc  00      
0002bd  00                DCB      0
0002be  00                DCB      0
0002bf  00                DCB      0
                  |L7.704|
0002c0  534c4156          DCB      "SLAVE Address Mask test OK.\n",0
0002c4  45204164
0002c8  64726573
0002cc  73204d61
0002d0  736b2074
0002d4  65737420
0002d8  4f4b2e0a
0002dc  00      
0002dd  00                DCB      0
0002de  00                DCB      0
0002df  00                DCB      0

                          AREA ||.data||, DATA, ALIGN=2

                  g_u8MstEndFlag
000000  00                DCB      0x00
                  g_u8DeviceAddr
000001  00                DCB      0x00
                  g_u8MstRxData
000002  00                DCB      0x00
                  g_u8MstDataLen
000003  00                DCB      0x00
                  m_Event
000004  00                DCB      0x00
                  g_au8MstTxData
000005  000000            DCB      0x00,0x00,0x00
                  s_UI2C0HandlerFn
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_aa9c707c____REV16|
#line 388 "..\\..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_main_c_aa9c707c____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_aa9c707c____REVSH|
#line 402
|__asm___6_main_c_aa9c707c____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_aa9c707c____RRX|
#line 587
|__asm___6_main_c_aa9c707c____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
