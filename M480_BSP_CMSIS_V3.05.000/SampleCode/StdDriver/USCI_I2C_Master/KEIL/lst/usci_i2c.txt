; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\usci_i2c.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\usci_i2c.d --cpu=Cortex-M4.fp.sp --apcs=interwork --diag_suppress=9931 -I..\..\..\..\Library\CMSIS\Include -I..\..\..\..\Library\Device\Nuvoton\M480\Include -I..\..\..\..\Library\StdDriver\inc -ID:\ARM\RV31\INC -ID:\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=531 --omf_browse=.\obj\usci_i2c.crf ..\..\..\..\Library\StdDriver\src\usci_i2c.c]
                          THUMB

                          AREA ||i.UI2C_ClearIntFlag||, CODE, READONLY, ALIGN=1

                  UI2C_ClearIntFlag PROC
;;;416     */
;;;417    void UI2C_ClearIntFlag(UI2C_T *ui2c, uint32_t u32Mask)
000000  07ca              LSLS     r2,r1,#31
;;;418    {
000002  d001              BEQ      |L1.8|
;;;419        /* Clear Time-out Interrupt Flag */
;;;420        if(u32Mask & UI2C_TO_INT_MASK)
;;;421        {
;;;422            ui2c->PROTSTS = UI2C_PROTSTS_TOIF_Msk;
000004  2220              MOVS     r2,#0x20
000006  6642              STR      r2,[r0,#0x64]
                  |L1.8|
;;;423        }
;;;424    
;;;425        /* Clear Start Condition Received Interrupt Flag */
;;;426        if(u32Mask & UI2C_STAR_INT_MASK)
000008  078a              LSLS     r2,r1,#30
00000a  d502              BPL      |L1.18|
;;;427        {
;;;428            ui2c->PROTSTS = UI2C_PROTSTS_STARIF_Msk;
00000c  f44f7280          MOV      r2,#0x100
000010  6642              STR      r2,[r0,#0x64]
                  |L1.18|
;;;429        }
;;;430    
;;;431        /* Clear Stop Condition Received Interrupt Flag */
;;;432        if(u32Mask & UI2C_STOR_INT_MASK)
000012  074a              LSLS     r2,r1,#29
000014  d502              BPL      |L1.28|
;;;433        {
;;;434            ui2c->PROTSTS = UI2C_PROTSTS_STORIF_Msk;
000016  f44f7200          MOV      r2,#0x200
00001a  6642              STR      r2,[r0,#0x64]
                  |L1.28|
;;;435        }
;;;436    
;;;437        /* Clear Non-Acknowledge Interrupt Flag */
;;;438        if(u32Mask & UI2C_NACK_INT_MASK)
00001c  070a              LSLS     r2,r1,#28
00001e  d502              BPL      |L1.38|
;;;439        {
;;;440            ui2c->PROTSTS = UI2C_PROTSTS_NACKIF_Msk;
000020  f44f6280          MOV      r2,#0x400
000024  6642              STR      r2,[r0,#0x64]
                  |L1.38|
;;;441        }
;;;442    
;;;443        /* Clear Arbitration Lost Interrupt Flag */
;;;444        if(u32Mask & UI2C_ARBLO_INT_MASK)
000026  06ca              LSLS     r2,r1,#27
000028  d502              BPL      |L1.48|
;;;445        {
;;;446            ui2c->PROTSTS = UI2C_PROTSTS_ARBLOIF_Msk;
00002a  f44f6200          MOV      r2,#0x800
00002e  6642              STR      r2,[r0,#0x64]
                  |L1.48|
;;;447        }
;;;448    
;;;449        /* Clear Error Interrupt Flag */
;;;450        if(u32Mask & UI2C_ERR_INT_MASK)
000030  068a              LSLS     r2,r1,#26
000032  d502              BPL      |L1.58|
;;;451        {
;;;452            ui2c->PROTSTS = UI2C_PROTSTS_ERRIF_Msk;
000034  f44f5280          MOV      r2,#0x1000
000038  6642              STR      r2,[r0,#0x64]
                  |L1.58|
;;;453        }
;;;454    
;;;455        /* Clear Acknowledge Interrupt Flag */
;;;456        if(u32Mask & UI2C_ACK_INT_MASK)
00003a  0649              LSLS     r1,r1,#25
00003c  d502              BPL      |L1.68|
;;;457        {
;;;458            ui2c->PROTSTS = UI2C_PROTSTS_ACKIF_Msk;
00003e  f44f5100          MOV      r1,#0x2000
000042  6641              STR      r1,[r0,#0x64]
                  |L1.68|
;;;459        }
;;;460    }
000044  4770              BX       lr
;;;461    
                          ENDP


                          AREA ||i.UI2C_ClearTimeoutFlag||, CODE, READONLY, ALIGN=1

                  UI2C_ClearTimeoutFlag PROC
;;;92      */
;;;93     void UI2C_ClearTimeoutFlag(UI2C_T *ui2c)
000000  2120              MOVS     r1,#0x20
;;;94     {
;;;95         ui2c->PROTSTS = UI2C_PROTSTS_TOIF_Msk;
000002  6641              STR      r1,[r0,#0x64]
;;;96     }
000004  4770              BX       lr
;;;97     
                          ENDP


                          AREA ||i.UI2C_Close||, CODE, READONLY, ALIGN=1

                  UI2C_Close PROC
;;;77      */
;;;78     void UI2C_Close(UI2C_T *ui2c)
000000  6801              LDR      r1,[r0,#0]
;;;79     {
;;;80         /* Disable USCI_I2C function */
;;;81         ui2c->CTL &= ~UI2C_CTL_FUNMODE_Msk;
000002  f0210107          BIC      r1,r1,#7
000006  6001              STR      r1,[r0,#0]
;;;82     }
000008  4770              BX       lr
;;;83     
                          ENDP


                          AREA ||i.UI2C_DisableInt||, CODE, READONLY, ALIGN=1

                  UI2C_DisableInt PROC
;;;154     */
;;;155    void UI2C_DisableInt(UI2C_T *ui2c, uint32_t u32Mask)
000000  07ca              LSLS     r2,r1,#31
;;;156    {
000002  d003              BEQ      |L4.12|
;;;157        /* Disable time-out interrupt flag */
;;;158        if((u32Mask & UI2C_TO_INT_MASK) == UI2C_TO_INT_MASK)
;;;159        {
;;;160            ui2c->PROTIEN &= ~UI2C_PROTIEN_TOIEN_Msk;
000004  6e02              LDR      r2,[r0,#0x60]
000006  f0220201          BIC      r2,r2,#1
00000a  6602              STR      r2,[r0,#0x60]
                  |L4.12|
;;;161        }
;;;162    
;;;163        /* Disable start condition received interrupt flag */
;;;164        if((u32Mask & UI2C_STAR_INT_MASK) == UI2C_STAR_INT_MASK)
00000c  078a              LSLS     r2,r1,#30
00000e  d503              BPL      |L4.24|
;;;165        {
;;;166            ui2c->PROTIEN &= ~UI2C_PROTIEN_STARIEN_Msk;
000010  6e02              LDR      r2,[r0,#0x60]
000012  f0220202          BIC      r2,r2,#2
000016  6602              STR      r2,[r0,#0x60]
                  |L4.24|
;;;167        }
;;;168    
;;;169        /* Disable stop condition received interrupt flag */
;;;170        if((u32Mask & UI2C_STOR_INT_MASK) == UI2C_STOR_INT_MASK)
000018  074a              LSLS     r2,r1,#29
00001a  d503              BPL      |L4.36|
;;;171        {
;;;172            ui2c->PROTIEN &= ~UI2C_PROTIEN_STORIEN_Msk;
00001c  6e02              LDR      r2,[r0,#0x60]
00001e  f0220204          BIC      r2,r2,#4
000022  6602              STR      r2,[r0,#0x60]
                  |L4.36|
;;;173        }
;;;174    
;;;175        /* Disable non-acknowledge interrupt flag */
;;;176        if((u32Mask & UI2C_NACK_INT_MASK) == UI2C_NACK_INT_MASK)
000024  070a              LSLS     r2,r1,#28
000026  d503              BPL      |L4.48|
;;;177        {
;;;178            ui2c->PROTIEN &= ~UI2C_PROTIEN_NACKIEN_Msk;
000028  6e02              LDR      r2,[r0,#0x60]
00002a  f0220208          BIC      r2,r2,#8
00002e  6602              STR      r2,[r0,#0x60]
                  |L4.48|
;;;179        }
;;;180    
;;;181        /* Disable arbitration lost interrupt flag */
;;;182        if((u32Mask & UI2C_ARBLO_INT_MASK) == UI2C_ARBLO_INT_MASK)
000030  06ca              LSLS     r2,r1,#27
000032  d503              BPL      |L4.60|
;;;183        {
;;;184            ui2c->PROTIEN &= ~UI2C_PROTIEN_ARBLOIEN_Msk;
000034  6e02              LDR      r2,[r0,#0x60]
000036  f0220210          BIC      r2,r2,#0x10
00003a  6602              STR      r2,[r0,#0x60]
                  |L4.60|
;;;185        }
;;;186    
;;;187        /* Disable error interrupt flag */
;;;188        if((u32Mask & UI2C_ERR_INT_MASK) == UI2C_ERR_INT_MASK)
00003c  068a              LSLS     r2,r1,#26
00003e  d503              BPL      |L4.72|
;;;189        {
;;;190            ui2c->PROTIEN &= ~UI2C_PROTIEN_ERRIEN_Msk;
000040  6e02              LDR      r2,[r0,#0x60]
000042  f0220220          BIC      r2,r2,#0x20
000046  6602              STR      r2,[r0,#0x60]
                  |L4.72|
;;;191        }
;;;192    
;;;193        /* Disable acknowledge interrupt flag */
;;;194        if((u32Mask & UI2C_ACK_INT_MASK) == UI2C_ACK_INT_MASK)
000048  0649              LSLS     r1,r1,#25
00004a  d503              BPL      |L4.84|
;;;195        {
;;;196            ui2c->PROTIEN &= ~UI2C_PROTIEN_ACKIEN_Msk;
00004c  6e01              LDR      r1,[r0,#0x60]
00004e  f0210140          BIC      r1,r1,#0x40
000052  6601              STR      r1,[r0,#0x60]
                  |L4.84|
;;;197        }
;;;198    }
000054  4770              BX       lr
;;;199    
                          ENDP


                          AREA ||i.UI2C_DisableTimeout||, CODE, READONLY, ALIGN=2

                  UI2C_DisableTimeout PROC
;;;567     */
;;;568    void UI2C_DisableTimeout(UI2C_T *ui2c)
000000  6dc1              LDR      r1,[r0,#0x5c]
;;;569    {
;;;570        ui2c->PROTCTL &= ~UI2C_PROTCTL_TOCNT_Msk;
000002  4a04              LDR      r2,|L5.20|
000004  4011              ANDS     r1,r1,r2
000006  65c1              STR      r1,[r0,#0x5c]
;;;571        ui2c->BRGEN &= ~UI2C_BRGEN_TMCNTEN_Msk;
000008  6881              LDR      r1,[r0,#8]
00000a  f0210110          BIC      r1,r1,#0x10
00000e  6081              STR      r1,[r0,#8]
;;;572    }
000010  4770              BX       lr
;;;573    
                          ENDP

000012  0000              DCW      0x0000
                  |L5.20|
                          DCD      0xfc00ffff

                          AREA ||i.UI2C_DisableWakeup||, CODE, READONLY, ALIGN=1

                  UI2C_DisableWakeup PROC
;;;599     */
;;;600    void UI2C_DisableWakeup(UI2C_T *ui2c)
000000  6d41              LDR      r1,[r0,#0x54]
;;;601    {
;;;602        ui2c->WKCTL &= ~UI2C_WKCTL_WKEN_Msk;
000002  f0210101          BIC      r1,r1,#1
000006  6541              STR      r1,[r0,#0x54]
;;;603    }
000008  4770              BX       lr
;;;604    
                          ENDP


                          AREA ||i.UI2C_EnableInt||, CODE, READONLY, ALIGN=1

                  UI2C_EnableInt PROC
;;;216     */
;;;217    void UI2C_EnableInt(UI2C_T *ui2c, uint32_t u32Mask)
000000  07ca              LSLS     r2,r1,#31
;;;218    {
000002  d003              BEQ      |L7.12|
;;;219        /* Enable time-out interrupt flag */
;;;220        if((u32Mask & UI2C_TO_INT_MASK) == UI2C_TO_INT_MASK)
;;;221        {
;;;222            ui2c->PROTIEN |= UI2C_PROTIEN_TOIEN_Msk;
000004  6e02              LDR      r2,[r0,#0x60]
000006  f0420201          ORR      r2,r2,#1
00000a  6602              STR      r2,[r0,#0x60]
                  |L7.12|
;;;223        }
;;;224    
;;;225        /* Enable start condition received interrupt flag */
;;;226        if((u32Mask & UI2C_STAR_INT_MASK) == UI2C_STAR_INT_MASK)
00000c  078a              LSLS     r2,r1,#30
00000e  d503              BPL      |L7.24|
;;;227        {
;;;228            ui2c->PROTIEN |= UI2C_PROTIEN_STARIEN_Msk;
000010  6e02              LDR      r2,[r0,#0x60]
000012  f0420202          ORR      r2,r2,#2
000016  6602              STR      r2,[r0,#0x60]
                  |L7.24|
;;;229        }
;;;230    
;;;231        /* Enable stop condition received interrupt flag */
;;;232        if((u32Mask & UI2C_STOR_INT_MASK) == UI2C_STOR_INT_MASK)
000018  074a              LSLS     r2,r1,#29
00001a  d503              BPL      |L7.36|
;;;233        {
;;;234            ui2c->PROTIEN |= UI2C_PROTIEN_STORIEN_Msk;
00001c  6e02              LDR      r2,[r0,#0x60]
00001e  f0420204          ORR      r2,r2,#4
000022  6602              STR      r2,[r0,#0x60]
                  |L7.36|
;;;235        }
;;;236    
;;;237        /* Enable non-acknowledge interrupt flag */
;;;238        if((u32Mask & UI2C_NACK_INT_MASK) == UI2C_NACK_INT_MASK)
000024  070a              LSLS     r2,r1,#28
000026  d503              BPL      |L7.48|
;;;239        {
;;;240            ui2c->PROTIEN |= UI2C_PROTIEN_NACKIEN_Msk;
000028  6e02              LDR      r2,[r0,#0x60]
00002a  f0420208          ORR      r2,r2,#8
00002e  6602              STR      r2,[r0,#0x60]
                  |L7.48|
;;;241        }
;;;242    
;;;243        /* Enable arbitration lost interrupt flag */
;;;244        if((u32Mask & UI2C_ARBLO_INT_MASK) == UI2C_ARBLO_INT_MASK)
000030  06ca              LSLS     r2,r1,#27
000032  d503              BPL      |L7.60|
;;;245        {
;;;246            ui2c->PROTIEN |= UI2C_PROTIEN_ARBLOIEN_Msk;
000034  6e02              LDR      r2,[r0,#0x60]
000036  f0420210          ORR      r2,r2,#0x10
00003a  6602              STR      r2,[r0,#0x60]
                  |L7.60|
;;;247        }
;;;248    
;;;249        /* Enable error interrupt flag */
;;;250        if((u32Mask & UI2C_ERR_INT_MASK) == UI2C_ERR_INT_MASK)
00003c  068a              LSLS     r2,r1,#26
00003e  d503              BPL      |L7.72|
;;;251        {
;;;252            ui2c->PROTIEN |= UI2C_PROTIEN_ERRIEN_Msk;
000040  6e02              LDR      r2,[r0,#0x60]
000042  f0420220          ORR      r2,r2,#0x20
000046  6602              STR      r2,[r0,#0x60]
                  |L7.72|
;;;253        }
;;;254    
;;;255        /* Enable acknowledge interrupt flag */
;;;256        if((u32Mask & UI2C_ACK_INT_MASK) == UI2C_ACK_INT_MASK)
000048  0649              LSLS     r1,r1,#25
00004a  d503              BPL      |L7.84|
;;;257        {
;;;258            ui2c->PROTIEN |= UI2C_PROTIEN_ACKIEN_Msk;
00004c  6e01              LDR      r1,[r0,#0x60]
00004e  f0410140          ORR      r1,r1,#0x40
000052  6601              STR      r1,[r0,#0x60]
                  |L7.84|
;;;259        }
;;;260    }
000054  4770              BX       lr
;;;261    
                          ENDP


                          AREA ||i.UI2C_EnableTimeout||, CODE, READONLY, ALIGN=2

                  UI2C_EnableTimeout PROC
;;;552     */
;;;553    void UI2C_EnableTimeout(UI2C_T *ui2c, uint32_t u32TimeoutCnt)
000000  6dc2              LDR      r2,[r0,#0x5c]
;;;554    {
;;;555        ui2c->PROTCTL = (ui2c->PROTCTL & ~UI2C_PROTCTL_TOCNT_Msk) | (u32TimeoutCnt << UI2C_PROTCTL_TOCNT_Pos);
000002  4b06              LDR      r3,|L8.28|
000004  401a              ANDS     r2,r2,r3
000006  ea424101          ORR      r1,r2,r1,LSL #16
00000a  65c1              STR      r1,[r0,#0x5c]
;;;556        ui2c->BRGEN = (ui2c->BRGEN & ~UI2C_BRGEN_TMCNTSRC_Msk) | UI2C_BRGEN_TMCNTEN_Msk;
00000c  6881              LDR      r1,[r0,#8]
00000e  f0210120          BIC      r1,r1,#0x20
000012  f0410110          ORR      r1,r1,#0x10
000016  6081              STR      r1,[r0,#8]
;;;557    }
000018  4770              BX       lr
;;;558    
                          ENDP

00001a  0000              DCW      0x0000
                  |L8.28|
                          DCD      0xfc00ffff

                          AREA ||i.UI2C_EnableWakeup||, CODE, READONLY, ALIGN=1

                  UI2C_EnableWakeup PROC
;;;585     */
;;;586    void UI2C_EnableWakeup(UI2C_T *ui2c, uint8_t u8WakeupMode)
000000  6d42              LDR      r2,[r0,#0x54]
;;;587    {
;;;588        ui2c->WKCTL = (ui2c->WKCTL & ~UI2C_WKCTL_WKADDREN_Msk) | (u8WakeupMode | UI2C_WKCTL_WKEN_Msk);
000002  f0220202          BIC      r2,r2,#2
000006  430a              ORRS     r2,r2,r1
000008  f0420101          ORR      r1,r2,#1
00000c  6541              STR      r1,[r0,#0x54]
;;;589    }
00000e  4770              BX       lr
;;;590    
                          ENDP


                          AREA ||i.UI2C_GetBusClockFreq||, CODE, READONLY, ALIGN=2

                  UI2C_GetBusClockFreq PROC
;;;270     */
;;;271    uint32_t UI2C_GetBusClockFreq(UI2C_T *ui2c)
000000  b510              PUSH     {r4,lr}
;;;272    {
000002  4604              MOV      r4,r0
;;;273        uint32_t u32Divider;
;;;274        uint32_t u32Pclk;
;;;275    
;;;276        if (ui2c == UI2C0)
000004  4807              LDR      r0,|L10.36|
000006  4284              CMP      r4,r0
000008  d102              BNE      |L10.16|
;;;277        {
;;;278            u32Pclk = CLK_GetPCLK0Freq();
00000a  f7fffffe          BL       CLK_GetPCLK0Freq
00000e  e001              B        |L10.20|
                  |L10.16|
;;;279        }
;;;280        else
;;;281        {
;;;282            u32Pclk = CLK_GetPCLK1Freq();
000010  f7fffffe          BL       CLK_GetPCLK1Freq
                  |L10.20|
;;;283        }
;;;284    
;;;285        u32Divider = (ui2c->BRGEN & UI2C_BRGEN_CLKDIV_Msk) >> UI2C_BRGEN_CLKDIV_Pos;
000014  68a1              LDR      r1,[r4,#8]
000016  f3c14109          UBFX     r1,r1,#16,#10
;;;286    
;;;287        return ( u32Pclk / ((u32Divider+1U)<<1U) );
00001a  0049              LSLS     r1,r1,#1
00001c  1c89              ADDS     r1,r1,#2
00001e  fbb0f0f1          UDIV     r0,r0,r1
;;;288    }
000022  bd10              POP      {r4,pc}
;;;289    
                          ENDP

                  |L10.36|
                          DCD      0x400d0000

                          AREA ||i.UI2C_GetData||, CODE, READONLY, ALIGN=1

                  UI2C_GetData PROC
;;;470     */
;;;471    uint32_t UI2C_GetData(UI2C_T *ui2c)
000000  6b40              LDR      r0,[r0,#0x34]
;;;472    {
;;;473        return ( ui2c->RXDAT );
;;;474    }
000002  4770              BX       lr
;;;475    
                          ENDP


                          AREA ||i.UI2C_GetIntFlag||, CODE, READONLY, ALIGN=1

                  UI2C_GetIntFlag PROC
;;;341     */
;;;342    uint32_t UI2C_GetIntFlag(UI2C_T *ui2c, uint32_t u32Mask)
000000  b510              PUSH     {r4,lr}
;;;343    {
000002  4602              MOV      r2,r0
;;;344        uint32_t u32IntFlag = 0U;
000004  2000              MOVS     r0,#0
;;;345        uint32_t u32TmpValue;
;;;346    
;;;347        u32TmpValue = ui2c->PROTSTS & UI2C_PROTSTS_TOIF_Msk;
000006  6e53              LDR      r3,[r2,#0x64]
;;;348        /* Check Time-out Interrupt Flag */
;;;349        if((u32Mask & UI2C_TO_INT_MASK) && (u32TmpValue))
000008  07cc              LSLS     r4,r1,#31
00000a  f0030320          AND      r3,r3,#0x20           ;347
00000e  d001              BEQ      |L12.20|
000010  b103              CBZ      r3,|L12.20|
;;;350        {
;;;351            u32IntFlag |= UI2C_TO_INT_MASK;
000012  2001              MOVS     r0,#1
                  |L12.20|
;;;352        }
;;;353    
;;;354        u32TmpValue = ui2c->PROTSTS & UI2C_PROTSTS_STARIF_Msk;
000014  6e53              LDR      r3,[r2,#0x64]
;;;355        /* Check Start Condition Received Interrupt Flag */
;;;356        if((u32Mask & UI2C_STAR_INT_MASK) && (u32TmpValue))
000016  078c              LSLS     r4,r1,#30
000018  f4037380          AND      r3,r3,#0x100          ;354
00001c  d502              BPL      |L12.36|
00001e  b10b              CBZ      r3,|L12.36|
;;;357        {
;;;358            u32IntFlag |= UI2C_STAR_INT_MASK;
000020  f0400002          ORR      r0,r0,#2
                  |L12.36|
;;;359        }
;;;360    
;;;361        u32TmpValue = ui2c->PROTSTS & UI2C_PROTSTS_STORIF_Msk;
000024  6e53              LDR      r3,[r2,#0x64]
;;;362        /* Check Stop Condition Received Interrupt Flag */
;;;363        if((u32Mask & UI2C_STOR_INT_MASK) && (u32TmpValue))
000026  074c              LSLS     r4,r1,#29
000028  f4037300          AND      r3,r3,#0x200          ;361
00002c  d502              BPL      |L12.52|
00002e  b10b              CBZ      r3,|L12.52|
;;;364        {
;;;365            u32IntFlag |= UI2C_STOR_INT_MASK;
000030  f0400004          ORR      r0,r0,#4
                  |L12.52|
;;;366        }
;;;367    
;;;368        u32TmpValue = ui2c->PROTSTS & UI2C_PROTSTS_NACKIF_Msk;
000034  6e53              LDR      r3,[r2,#0x64]
;;;369        /* Check Non-Acknowledge Interrupt Flag */
;;;370        if((u32Mask & UI2C_NACK_INT_MASK) && (u32TmpValue))
000036  070c              LSLS     r4,r1,#28
000038  f4036380          AND      r3,r3,#0x400          ;368
00003c  d502              BPL      |L12.68|
00003e  b10b              CBZ      r3,|L12.68|
;;;371        {
;;;372            u32IntFlag |= UI2C_NACK_INT_MASK;
000040  f0400008          ORR      r0,r0,#8
                  |L12.68|
;;;373        }
;;;374    
;;;375        u32TmpValue = ui2c->PROTSTS & UI2C_PROTSTS_ARBLOIF_Msk;
000044  6e53              LDR      r3,[r2,#0x64]
;;;376        /* Check Arbitration Lost Interrupt Flag */
;;;377        if((u32Mask & UI2C_ARBLO_INT_MASK) && (u32TmpValue))
000046  06cc              LSLS     r4,r1,#27
000048  f4036300          AND      r3,r3,#0x800          ;375
00004c  d502              BPL      |L12.84|
00004e  b10b              CBZ      r3,|L12.84|
;;;378        {
;;;379            u32IntFlag |= UI2C_ARBLO_INT_MASK;
000050  f0400010          ORR      r0,r0,#0x10
                  |L12.84|
;;;380        }
;;;381    
;;;382        u32TmpValue = ui2c->PROTSTS & UI2C_PROTSTS_ERRIF_Msk;
000054  6e53              LDR      r3,[r2,#0x64]
;;;383        /* Check Error Interrupt Flag */
;;;384        if((u32Mask & UI2C_ERR_INT_MASK) && (u32TmpValue))
000056  068c              LSLS     r4,r1,#26
000058  f4035380          AND      r3,r3,#0x1000         ;382
00005c  d502              BPL      |L12.100|
00005e  b10b              CBZ      r3,|L12.100|
;;;385        {
;;;386            u32IntFlag |= UI2C_ERR_INT_MASK;
000060  f0400020          ORR      r0,r0,#0x20
                  |L12.100|
;;;387        }
;;;388    
;;;389        u32TmpValue = ui2c->PROTSTS & UI2C_PROTSTS_ACKIF_Msk;
000064  6e52              LDR      r2,[r2,#0x64]
;;;390        /* Check Acknowledge Interrupt Flag */
;;;391        if((u32Mask & UI2C_ACK_INT_MASK) && (u32TmpValue))
000066  0649              LSLS     r1,r1,#25
000068  f4025200          AND      r2,r2,#0x2000         ;389
00006c  d503              BPL      |L12.118|
00006e  2a00              CMP      r2,#0
000070  d001              BEQ      |L12.118|
;;;392        {
;;;393            u32IntFlag |= UI2C_ACK_INT_MASK;
000072  f0400040          ORR      r0,r0,#0x40
                  |L12.118|
;;;394        }
;;;395    
;;;396        return u32IntFlag;
;;;397    }
000076  bd10              POP      {r4,pc}
;;;398    
                          ENDP


                          AREA ||i.UI2C_Open||, CODE, READONLY, ALIGN=2

                  UI2C_Open PROC
;;;32      */
;;;33     uint32_t UI2C_Open(UI2C_T *ui2c, uint32_t u32BusClock)
000000  b570              PUSH     {r4-r6,lr}
;;;34     {
000002  4604              MOV      r4,r0
;;;35         uint32_t u32ClkDiv;
;;;36         uint32_t u32Pclk;
;;;37     
;;;38         if( ui2c == UI2C0 )
000004  481a              LDR      r0,|L13.112|
000006  460d              MOV      r5,r1                 ;34
000008  4284              CMP      r4,r0
00000a  d102              BNE      |L13.18|
;;;39         {
;;;40             u32Pclk = CLK_GetPCLK0Freq();
00000c  f7fffffe          BL       CLK_GetPCLK0Freq
000010  e001              B        |L13.22|
                  |L13.18|
;;;41         }
;;;42         else
;;;43         {
;;;44             u32Pclk = CLK_GetPCLK1Freq();
000012  f7fffffe          BL       CLK_GetPCLK1Freq
                  |L13.22|
;;;45         }
;;;46     
;;;47         u32ClkDiv = (uint32_t) ((((((u32Pclk/2U)*10U)/(u32BusClock))+5U)/10U)-1U); /* Compute proper divider for USCI_I2C clock */
000016  0842              LSRS     r2,r0,#1
000018  eb020182          ADD      r1,r2,r2,LSL #2
00001c  0049              LSLS     r1,r1,#1
00001e  fbb1f1f5          UDIV     r1,r1,r5
000022  220a              MOVS     r2,#0xa
000024  1d49              ADDS     r1,r1,#5
000026  fbb1f1f2          UDIV     r1,r1,r2
;;;48     
;;;49         /* Enable USCI_I2C protocol */
;;;50         ui2c->CTL &= ~UI2C_CTL_FUNMODE_Msk;
00002a  6823              LDR      r3,[r4,#0]
00002c  1e4a              SUBS     r2,r1,#1              ;47
00002e  f0230307          BIC      r3,r3,#7
000032  6023              STR      r3,[r4,#0]
;;;51         ui2c->CTL = 4U << UI2C_CTL_FUNMODE_Pos;
000034  2304              MOVS     r3,#4
000036  6023              STR      r3,[r4,#0]
;;;52     
;;;53         /* Data format configuration */
;;;54         /* 8 bit data length */
;;;55         ui2c->LINECTL &= ~UI2C_LINECTL_DWIDTH_Msk;
000038  6ae3              LDR      r3,[r4,#0x2c]
00003a  f4236370          BIC      r3,r3,#0xf00
00003e  62e3              STR      r3,[r4,#0x2c]
;;;56         ui2c->LINECTL |= 8U << UI2C_LINECTL_DWIDTH_Pos;
000040  6ae3              LDR      r3,[r4,#0x2c]
000042  f4436300          ORR      r3,r3,#0x800
000046  62e3              STR      r3,[r4,#0x2c]
;;;57     
;;;58         /* MSB data format */
;;;59         ui2c->LINECTL &= ~UI2C_LINECTL_LSB_Msk;
000048  6ae3              LDR      r3,[r4,#0x2c]
00004a  f0230301          BIC      r3,r3,#1
00004e  62e3              STR      r3,[r4,#0x2c]
;;;60     
;;;61         /* Set USCI_I2C bus clock */
;;;62         ui2c->BRGEN &= ~UI2C_BRGEN_CLKDIV_Msk;
000050  68a3              LDR      r3,[r4,#8]
000052  4d08              LDR      r5,|L13.116|
000054  402b              ANDS     r3,r3,r5
000056  60a3              STR      r3,[r4,#8]
;;;63         ui2c->BRGEN |=  (u32ClkDiv << UI2C_BRGEN_CLKDIV_Pos);
000058  68a3              LDR      r3,[r4,#8]
00005a  ea434202          ORR      r2,r3,r2,LSL #16
00005e  60a2              STR      r2,[r4,#8]
;;;64         ui2c->PROTCTL |=  UI2C_PROTCTL_PROTEN_Msk;
000060  6de2              LDR      r2,[r4,#0x5c]
000062  f0424200          ORR      r2,r2,#0x80000000
000066  65e2              STR      r2,[r4,#0x5c]
;;;65     
;;;66         return ( u32Pclk / ((u32ClkDiv+1U)<<1U) );
;;;67     }
000068  0049              LSLS     r1,r1,#1
00006a  fbb0f0f1          UDIV     r0,r0,r1              ;66
00006e  bd70              POP      {r4-r6,pc}
;;;68     
                          ENDP

                  |L13.112|
                          DCD      0x400d0000
                  |L13.116|
                          DCD      0xfc00ffff

                          AREA ||i.UI2C_ReadByte||, CODE, READONLY, ALIGN=1

                  UI2C_ReadByte PROC
;;;1090     */
;;;1091   uint8_t UI2C_ReadByte(UI2C_T *ui2c, uint8_t u8SlaveAddr)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;1092   {
;;;1093       uint8_t u8Xfering = 1U, u8Err = 0U, rdata = 0U, u8Ctrl = 0U;
000004  2500              MOVS     r5,#0
000006  2701              MOVS     r7,#1
;;;1094       enum UI2C_MASTER_EVENT eEvent = MASTER_SEND_START;
;;;1095   
;;;1096       UI2C_START(ui2c);                                                       /* Send START */
000008  6dc3              LDR      r3,[r0,#0x5c]
00000a  462e              MOV      r6,r5                 ;1093
00000c  462a              MOV      r2,r5                 ;1093
00000e  2412              MOVS     r4,#0x12              ;1094
000010  f0230320          BIC      r3,r3,#0x20
000014  f0430308          ORR      r3,r3,#8
000018  65c3              STR      r3,[r0,#0x5c]
;;;1097   
;;;1098       while (u8Xfering)
;;;1099       {
;;;1100           while (!(UI2C_GET_PROT_STATUS(ui2c) & 0x3F00U));                     /* Wait UI2C new status occur */
;;;1101   
;;;1102           switch (UI2C_GET_PROT_STATUS(ui2c) & 0x3F00U)
00001a  f44f7880          MOV      r8,#0x100
00001e  f44f5900          MOV      r9,#0x2000
000022  f44f6a80          MOV      r10,#0x400
000026  f44f7b00          MOV      r11,#0x200
                  |L14.42|
00002a  6e43              LDR      r3,[r0,#0x64]         ;1100
00002c  f4135f7c          TST      r3,#0x3f00            ;1100
000030  d0fb              BEQ      |L14.42|
000032  6e43              LDR      r3,[r0,#0x64]
000034  f403537c          AND      r3,r3,#0x3f00
000038  4543              CMP      r3,r8
00003a  d00c              BEQ      |L14.86|
00003c  46dc              MOV      r12,r11
00003e  4563              CMP      r3,r12
000040  d01c              BEQ      |L14.124|
000042  46d4              MOV      r12,r10
000044  4563              CMP      r3,r12
000046  d00f              BEQ      |L14.104|
000048  46cc              MOV      r12,r9
00004a  4563              CMP      r3,r12
00004c  d11b              BNE      |L14.134|
;;;1103           {
;;;1104           case UI2C_PROTSTS_STARIF_Msk:
;;;1105               UI2C_CLR_PROT_INT_FLAG(ui2c, UI2C_PROTSTS_STARIF_Msk);     /* Clear START INT Flag */
;;;1106               UI2C_SET_DATA(ui2c, (u8SlaveAddr << 1U) | 0x01U);             /* Write SLA+R to Register UI2C_TXDAT */
;;;1107               eEvent = MASTER_SEND_H_RD_ADDRESS;
;;;1108               u8Ctrl = UI2C_CTL_PTRG;
;;;1109               break;
;;;1110   
;;;1111           case UI2C_PROTSTS_ACKIF_Msk:
;;;1112               UI2C_CLR_PROT_INT_FLAG(ui2c, UI2C_PROTSTS_ACKIF_Msk);      /* Clear ACK INT Flag */
00004e  f8c0c064          STR      r12,[r0,#0x64]
;;;1113               eEvent = MASTER_READ_DATA;
000052  2410              MOVS     r4,#0x10
;;;1114               break;
000054  e019              B        |L14.138|
                  |L14.86|
000056  f8c08064          STR      r8,[r0,#0x64]         ;1105
00005a  2201              MOVS     r2,#1                 ;1106
00005c  eb020241          ADD      r2,r2,r1,LSL #1       ;1106
000060  6302              STR      r2,[r0,#0x30]         ;1106
000062  240c              MOVS     r4,#0xc               ;1107
000064  2220              MOVS     r2,#0x20              ;1108
000066  e010              B        |L14.138|
                  |L14.104|
;;;1115   
;;;1116           case UI2C_PROTSTS_NACKIF_Msk:
;;;1117               UI2C_CLR_PROT_INT_FLAG(ui2c, UI2C_PROTSTS_NACKIF_Msk);     /* Clear NACK INT Flag */
000068  f8c0c064          STR      r12,[r0,#0x64]
;;;1118   
;;;1119               if (eEvent == MASTER_SEND_H_RD_ADDRESS)
00006c  2c0c              CMP      r4,#0xc
00006e  d003              BEQ      |L14.120|
;;;1120               {
;;;1121                   u8Err = 1U;
;;;1122               }
;;;1123               else
;;;1124               {
;;;1125                   rdata = (unsigned char) UI2C_GET_DATA(ui2c);            /* Receive Data */
000070  6b42              LDR      r2,[r0,#0x34]
000072  b2d6              UXTB     r6,r2
                  |L14.116|
;;;1126               }
;;;1127   
;;;1128               u8Ctrl = (UI2C_CTL_PTRG | UI2C_CTL_STO);                        /* Clear SI and send STOP */
000074  2224              MOVS     r2,#0x24
;;;1129   
;;;1130               break;
000076  e008              B        |L14.138|
                  |L14.120|
000078  2501              MOVS     r5,#1                 ;1121
00007a  e7fb              B        |L14.116|
                  |L14.124|
;;;1131   
;;;1132           case UI2C_PROTSTS_STORIF_Msk:
;;;1133               UI2C_CLR_PROT_INT_FLAG(ui2c, UI2C_PROTSTS_STORIF_Msk);     /* Clear STOP INT Flag */
00007c  f8c0c064          STR      r12,[r0,#0x64]
;;;1134               u8Ctrl = UI2C_CTL_PTRG;                                     /* Clear SI */
000080  2220              MOVS     r2,#0x20
;;;1135               u8Xfering = 0U;
000082  2700              MOVS     r7,#0
;;;1136               break;
000084  e001              B        |L14.138|
                  |L14.134|
;;;1137   
;;;1138           case UI2C_PROTSTS_ARBLOIF_Msk:                                  /* Arbitration Lost */
;;;1139           default:                                                        /* Unknow status */
;;;1140               u8Ctrl = (UI2C_CTL_PTRG | UI2C_CTL_STO);                    /* Clear SI and send STOP */
000086  2224              MOVS     r2,#0x24
;;;1141               u8Err = 1U;
000088  2501              MOVS     r5,#1
                  |L14.138|
;;;1142               break;
;;;1143           }
;;;1144   
;;;1145           UI2C_SET_CONTROL_REG(ui2c, u8Ctrl);                                 /* Write controlbit to UI2C_PROTCTL register */
00008a  6dc3              LDR      r3,[r0,#0x5c]
00008c  f023032e          BIC      r3,r3,#0x2e
000090  4313              ORRS     r3,r3,r2
000092  65c3              STR      r3,[r0,#0x5c]
000094  2f00              CMP      r7,#0
000096  d1c8              BNE      |L14.42|
;;;1146       }
;;;1147   
;;;1148       if (u8Err)
000098  b105              CBZ      r5,|L14.156|
;;;1149           rdata = 0U;
00009a  2600              MOVS     r6,#0
                  |L14.156|
;;;1150   
;;;1151       return rdata;                                                           /* Return read data */
00009c  4630              MOV      r0,r6
;;;1152   }
00009e  e8bd8ff0          POP      {r4-r11,pc}
;;;1153   
                          ENDP


                          AREA ||i.UI2C_ReadByteOneReg||, CODE, READONLY, ALIGN=1

                  UI2C_ReadByteOneReg PROC
;;;1251     */
;;;1252   uint8_t UI2C_ReadByteOneReg(UI2C_T *ui2c, uint8_t u8SlaveAddr, uint8_t u8DataAddr)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;1253   {
;;;1254       uint8_t u8Xfering = 1U, u8Err = 0U, rdata = 0U, u8Ctrl = 0U;
000004  2500              MOVS     r5,#0
000006  2701              MOVS     r7,#1
;;;1255       enum UI2C_MASTER_EVENT eEvent = MASTER_SEND_START;
;;;1256   
;;;1257       UI2C_START(ui2c);                                                       /* Send START */
000008  6dc4              LDR      r4,[r0,#0x5c]
00000a  462e              MOV      r6,r5                 ;1254
00000c  2312              MOVS     r3,#0x12              ;1255
00000e  f0240420          BIC      r4,r4,#0x20
000012  f0440408          ORR      r4,r4,#8
000016  65c4              STR      r4,[r0,#0x5c]
;;;1258   
;;;1259       while (u8Xfering)
;;;1260       {
;;;1261           while (!(UI2C_GET_PROT_STATUS(ui2c) & 0x3F00U));                     /* Wait UI2C new status occur */
;;;1262   
;;;1263           switch (UI2C_GET_PROT_STATUS(ui2c) & 0x3F00U)
000018  f44f7c80          MOV      r12,#0x100
00001c  f44f5900          MOV      r9,#0x2000
000020  f44f6a80          MOV      r10,#0x400
000024  f44f7b00          MOV      r11,#0x200
                  |L15.40|
000028  6e44              LDR      r4,[r0,#0x64]         ;1261
00002a  f4145f7c          TST      r4,#0x3f00            ;1261
00002e  d0fb              BEQ      |L15.40|
000030  6e44              LDR      r4,[r0,#0x64]
000032  f404547c          AND      r4,r4,#0x3f00
000036  4564              CMP      r4,r12
000038  d011              BEQ      |L15.94|
00003a  46d8              MOV      r8,r11
00003c  4544              CMP      r4,r8
00003e  d031              BEQ      |L15.164|
000040  46d0              MOV      r8,r10
000042  4544              CMP      r4,r8
000044  d024              BEQ      |L15.144|
000046  46c8              MOV      r8,r9
000048  4544              CMP      r4,r8
00004a  d130              BNE      |L15.174|
;;;1264           {
;;;1265           case UI2C_PROTSTS_STARIF_Msk:
;;;1266               UI2C_CLR_PROT_INT_FLAG(ui2c, UI2C_PROTSTS_STARIF_Msk);     /* Clear START INT Flag */
;;;1267   
;;;1268               if (eEvent == MASTER_SEND_START)
;;;1269               {
;;;1270                   UI2C_SET_DATA(ui2c, (u8SlaveAddr << 1U) | 0x00U);         /* Write SLA+W to Register UI2C_TXDAT */
;;;1271                   eEvent = MASTER_SEND_ADDRESS;
;;;1272               }
;;;1273               else if (eEvent == MASTER_SEND_REPEAT_START)
;;;1274               {
;;;1275                   UI2C_SET_DATA(ui2c, (u8SlaveAddr << 1U) | 0x01U);        /* Write SLA+R to Register TXDAT */
;;;1276                   eEvent = MASTER_SEND_H_RD_ADDRESS;
;;;1277               }
;;;1278   
;;;1279               u8Ctrl = UI2C_CTL_PTRG;
;;;1280               break;
;;;1281   
;;;1282           case UI2C_PROTSTS_ACKIF_Msk:
;;;1283               UI2C_CLR_PROT_INT_FLAG(ui2c, UI2C_PROTSTS_ACKIF_Msk);      /* Clear ACK INT Flag */
00004c  f8c08064          STR      r8,[r0,#0x64]
;;;1284   
;;;1285               if (eEvent == MASTER_SEND_ADDRESS)
000050  2b0a              CMP      r3,#0xa
000052  d016              BEQ      |L15.130|
;;;1286               {
;;;1287                   UI2C_SET_DATA(ui2c, u8DataAddr);                        /* Write data address of register */
;;;1288                   u8Ctrl = UI2C_CTL_PTRG;
;;;1289                   eEvent = MASTER_SEND_DATA;
;;;1290               }
;;;1291               else if (eEvent == MASTER_SEND_DATA)
000054  2b0e              CMP      r3,#0xe
000056  d018              BEQ      |L15.138|
;;;1292               {
;;;1293                   u8Ctrl = (UI2C_CTL_PTRG | UI2C_CTL_STA);                /* Send repeat START signal */
;;;1294                   eEvent = MASTER_SEND_REPEAT_START;
;;;1295               }
;;;1296               else
;;;1297               {
;;;1298                   /* SLA+R ACK */
;;;1299                   u8Ctrl = UI2C_CTL_PTRG;
000058  2420              MOVS     r4,#0x20
;;;1300                   eEvent = MASTER_READ_DATA;
00005a  2310              MOVS     r3,#0x10
00005c  e029              B        |L15.178|
                  |L15.94|
00005e  f8c0c064          STR      r12,[r0,#0x64]        ;1266
000062  2b12              CMP      r3,#0x12              ;1268
000064  d002              BEQ      |L15.108|
000066  2b0f              CMP      r3,#0xf               ;1273
000068  d004              BEQ      |L15.116|
00006a  e008              B        |L15.126|
                  |L15.108|
00006c  004b              LSLS     r3,r1,#1              ;1270
00006e  6303              STR      r3,[r0,#0x30]         ;1270
000070  230a              MOVS     r3,#0xa               ;1271
000072  e004              B        |L15.126|
                  |L15.116|
000074  2301              MOVS     r3,#1                 ;1275
000076  eb030341          ADD      r3,r3,r1,LSL #1       ;1275
00007a  6303              STR      r3,[r0,#0x30]         ;1275
00007c  230c              MOVS     r3,#0xc               ;1276
                  |L15.126|
00007e  2420              MOVS     r4,#0x20              ;1279
000080  e017              B        |L15.178|
                  |L15.130|
000082  6302              STR      r2,[r0,#0x30]         ;1287
000084  2420              MOVS     r4,#0x20              ;1288
000086  230e              MOVS     r3,#0xe               ;1289
000088  e013              B        |L15.178|
                  |L15.138|
00008a  2428              MOVS     r4,#0x28              ;1293
00008c  230f              MOVS     r3,#0xf               ;1294
00008e  e010              B        |L15.178|
                  |L15.144|
;;;1301               }
;;;1302   
;;;1303               break;
;;;1304   
;;;1305           case UI2C_PROTSTS_NACKIF_Msk:
;;;1306               UI2C_CLR_PROT_INT_FLAG(ui2c, UI2C_PROTSTS_NACKIF_Msk);     /* Clear NACK INT Flag */
000090  f8c08064          STR      r8,[r0,#0x64]
;;;1307   
;;;1308               if (eEvent == MASTER_READ_DATA)
000094  2b10              CMP      r3,#0x10
000096  d002              BEQ      |L15.158|
;;;1309               {
;;;1310                   rdata = (uint8_t) UI2C_GET_DATA(ui2c);                  /* Receive Data */
;;;1311               }
;;;1312               else
;;;1313               {
;;;1314                   u8Err = 1U;
000098  2501              MOVS     r5,#1
                  |L15.154|
;;;1315               }
;;;1316   
;;;1317               u8Ctrl = (UI2C_CTL_PTRG | UI2C_CTL_STO);                        /* Clear SI and send STOP */
00009a  2424              MOVS     r4,#0x24
;;;1318   
;;;1319               break;
00009c  e009              B        |L15.178|
                  |L15.158|
00009e  6b44              LDR      r4,[r0,#0x34]         ;1310
0000a0  b2e6              UXTB     r6,r4                 ;1310
0000a2  e7fa              B        |L15.154|
                  |L15.164|
;;;1320   
;;;1321           case UI2C_PROTSTS_STORIF_Msk:
;;;1322               UI2C_CLR_PROT_INT_FLAG(ui2c, UI2C_PROTSTS_STORIF_Msk);     /* Clear STOP INT Flag */
0000a4  f8c08064          STR      r8,[r0,#0x64]
;;;1323               u8Ctrl = UI2C_CTL_PTRG;                                     /* Clear SI */
0000a8  2420              MOVS     r4,#0x20
;;;1324               u8Xfering = 0U;
0000aa  2700              MOVS     r7,#0
;;;1325               break;
0000ac  e001              B        |L15.178|
                  |L15.174|
;;;1326   
;;;1327           case UI2C_PROTSTS_ARBLOIF_Msk:                                  /* Arbitration Lost */
;;;1328           default:                                                        /* Unknow status */
;;;1329               u8Ctrl = (UI2C_CTL_PTRG | UI2C_CTL_STO);                    /* Clear SI and send STOP */
0000ae  2424              MOVS     r4,#0x24
;;;1330               u8Err = 1U;
0000b0  2501              MOVS     r5,#1
                  |L15.178|
;;;1331               break;
;;;1332           }
;;;1333   
;;;1334           UI2C_SET_CONTROL_REG(ui2c, u8Ctrl);                                 /* Write controlbit to UI2C_PROTCTL register */
0000b2  f8d0805c          LDR      r8,[r0,#0x5c]
0000b6  f028082e          BIC      r8,r8,#0x2e
0000ba  ea480804          ORR      r8,r8,r4
0000be  f8c0805c          STR      r8,[r0,#0x5c]
0000c2  2f00              CMP      r7,#0
0000c4  d1b0              BNE      |L15.40|
;;;1335       }
;;;1336   
;;;1337       if (u8Err)
0000c6  b105              CBZ      r5,|L15.202|
;;;1338           rdata = 0U;                                                 /* If occurs error, return 0 */
0000c8  2600              MOVS     r6,#0
                  |L15.202|
;;;1339   
;;;1340       return rdata;                                                  /* Return read data */
0000ca  4630              MOV      r0,r6
;;;1341   }
0000cc  e8bd8ff0          POP      {r4-r11,pc}
;;;1342   
                          ENDP


                          AREA ||i.UI2C_ReadByteTwoRegs||, CODE, READONLY, ALIGN=1

                  UI2C_ReadByteTwoRegs PROC
;;;1461     */
;;;1462   uint8_t UI2C_ReadByteTwoRegs(UI2C_T *ui2c, uint8_t u8SlaveAddr, uint16_t u16DataAddr)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;1463   {
;;;1464       uint8_t u8Xfering = 1U, u8Err = 0U, rdata = 0U, u8Addr = 1U, u8Ctrl = 0U;
000004  2600              MOVS     r6,#0
000006  f04f0801          MOV      r8,#1
;;;1465       enum UI2C_MASTER_EVENT eEvent = MASTER_SEND_START;
;;;1466   
;;;1467       UI2C_START(ui2c);                                                       /* Send START */
00000a  6dc5              LDR      r5,[r0,#0x5c]
00000c  4637              MOV      r7,r6                 ;1464
00000e  46c4              MOV      r12,r8                ;1464
000010  4634              MOV      r4,r6                 ;1464
000012  2312              MOVS     r3,#0x12              ;1465
000014  f0250520          BIC      r5,r5,#0x20
000018  f0450508          ORR      r5,r5,#8
00001c  65c5              STR      r5,[r0,#0x5c]
;;;1468   
;;;1469       while (u8Xfering)
;;;1470       {
;;;1471           while (!(UI2C_GET_PROT_STATUS(ui2c) & 0x3F00U));                     /* Wait UI2C new status occur */
;;;1472   
;;;1473           switch (UI2C_GET_PROT_STATUS(ui2c) & 0x3F00U)
00001e  f44f7a80          MOV      r10,#0x100
000022  f44f5b00          MOV      r11,#0x2000
000026  f44f6e80          MOV      lr,#0x400
                  |L16.42|
00002a  6e45              LDR      r5,[r0,#0x64]         ;1471
00002c  f4155f7c          TST      r5,#0x3f00            ;1471
000030  d0fb              BEQ      |L16.42|
000032  6e45              LDR      r5,[r0,#0x64]
000034  f405557c          AND      r5,r5,#0x3f00
000038  4555              CMP      r5,r10
00003a  d010              BEQ      |L16.94|
00003c  f44f7900          MOV      r9,#0x200
000040  454d              CMP      r5,r9
000042  d037              BEQ      |L16.180|
000044  4575              CMP      r5,lr
000046  d02b              BEQ      |L16.160|
000048  455d              CMP      r5,r11
00004a  d139              BNE      |L16.192|
;;;1474           {
;;;1475           case UI2C_PROTSTS_STARIF_Msk:
;;;1476               UI2C_CLR_PROT_INT_FLAG(ui2c, UI2C_PROTSTS_STARIF_Msk);     /* Clear START INT Flag */
;;;1477   
;;;1478               if (eEvent == MASTER_SEND_START)
;;;1479               {
;;;1480                   UI2C_SET_DATA(ui2c, (u8SlaveAddr << 1U) | 0x00U);        /* Write SLA+W to Register UI2C_TXDAT */
;;;1481                   eEvent = MASTER_SEND_ADDRESS;
;;;1482               }
;;;1483               else if (eEvent == MASTER_SEND_REPEAT_START)
;;;1484               {
;;;1485                   UI2C_SET_DATA(ui2c, (u8SlaveAddr << 1U) | 0x01U);        /* Write SLA+R to Register TXDAT */
;;;1486                   eEvent = MASTER_SEND_H_RD_ADDRESS;
;;;1487               }
;;;1488   
;;;1489               u8Ctrl = UI2C_CTL_PTRG;
;;;1490               break;
;;;1491   
;;;1492           case UI2C_PROTSTS_ACKIF_Msk:
;;;1493               UI2C_CLR_PROT_INT_FLAG(ui2c, UI2C_PROTSTS_ACKIF_Msk);      /* Clear ACK INT Flag */
00004c  f8c0b064          STR      r11,[r0,#0x64]
;;;1494   
;;;1495               if (eEvent == MASTER_SEND_ADDRESS)
000050  2b0a              CMP      r3,#0xa
000052  d016              BEQ      |L16.130|
;;;1496               {
;;;1497                   UI2C_SET_DATA(ui2c, (uint8_t)((u16DataAddr & 0xFF00U) >> 8U));  /* Write Hi byte address of register */
;;;1498                   eEvent = MASTER_SEND_DATA;
;;;1499               }
;;;1500               else if (eEvent == MASTER_SEND_DATA)
000054  2b0e              CMP      r3,#0xe
000056  d018              BEQ      |L16.138|
;;;1501               {
;;;1502                   if (u8Addr)
;;;1503                   {
;;;1504                       UI2C_SET_DATA(ui2c, (uint8_t)(u16DataAddr & 0xFFU));       /* Write Lo byte address of register */
;;;1505                       u8Addr = 0;
;;;1506                   }
;;;1507                   else
;;;1508                   {
;;;1509                       u8Ctrl = (UI2C_CTL_PTRG | UI2C_CTL_STA);                /* Send repeat START signal */
;;;1510                       eEvent = MASTER_SEND_REPEAT_START;
;;;1511                   }
;;;1512               }
;;;1513               else
;;;1514               {
;;;1515                   /* SLA+R ACK */
;;;1516                   u8Ctrl = UI2C_CTL_PTRG;
000058  2420              MOVS     r4,#0x20
;;;1517                   eEvent = MASTER_READ_DATA;
00005a  2310              MOVS     r3,#0x10
00005c  e032              B        |L16.196|
                  |L16.94|
00005e  f8c0a064          STR      r10,[r0,#0x64]        ;1476
000062  2b12              CMP      r3,#0x12              ;1478
000064  d002              BEQ      |L16.108|
000066  2b0f              CMP      r3,#0xf               ;1483
000068  d004              BEQ      |L16.116|
00006a  e008              B        |L16.126|
                  |L16.108|
00006c  004b              LSLS     r3,r1,#1              ;1480
00006e  6303              STR      r3,[r0,#0x30]         ;1480
000070  230a              MOVS     r3,#0xa               ;1481
000072  e004              B        |L16.126|
                  |L16.116|
000074  2301              MOVS     r3,#1                 ;1485
000076  eb030341          ADD      r3,r3,r1,LSL #1       ;1485
00007a  6303              STR      r3,[r0,#0x30]         ;1485
00007c  230c              MOVS     r3,#0xc               ;1486
                  |L16.126|
00007e  2420              MOVS     r4,#0x20              ;1489
000080  e020              B        |L16.196|
                  |L16.130|
000082  0a13              LSRS     r3,r2,#8              ;1497
000084  6303              STR      r3,[r0,#0x30]         ;1497
000086  230e              MOVS     r3,#0xe               ;1498
000088  e01c              B        |L16.196|
                  |L16.138|
00008a  f1bc0f00          CMP      r12,#0                ;1502
00008e  d004              BEQ      |L16.154|
000090  b2d5              UXTB     r5,r2                 ;1504
000092  6305              STR      r5,[r0,#0x30]         ;1504
000094  f04f0c00          MOV      r12,#0                ;1505
000098  e014              B        |L16.196|
                  |L16.154|
00009a  2428              MOVS     r4,#0x28              ;1509
00009c  230f              MOVS     r3,#0xf               ;1510
00009e  e011              B        |L16.196|
                  |L16.160|
;;;1518               }
;;;1519   
;;;1520               break;
;;;1521   
;;;1522           case UI2C_PROTSTS_NACKIF_Msk:
;;;1523               UI2C_CLR_PROT_INT_FLAG(ui2c, UI2C_PROTSTS_NACKIF_Msk);     /* Clear NACK INT Flag */
0000a0  f8c0e064          STR      lr,[r0,#0x64]
;;;1524   
;;;1525               if (eEvent == MASTER_READ_DATA)
0000a4  2b10              CMP      r3,#0x10
0000a6  d002              BEQ      |L16.174|
;;;1526               {
;;;1527                   rdata = (uint8_t) UI2C_GET_DATA(ui2c);                  /* Receive Data */
;;;1528               }
;;;1529               else
;;;1530               {
;;;1531                   u8Err = 1U;
0000a8  2601              MOVS     r6,#1
                  |L16.170|
;;;1532               }
;;;1533   
;;;1534               u8Ctrl = (UI2C_CTL_PTRG | UI2C_CTL_STO);                        /* Clear SI and send STOP */
0000aa  2424              MOVS     r4,#0x24
;;;1535   
;;;1536               break;
0000ac  e00a              B        |L16.196|
                  |L16.174|
0000ae  6b44              LDR      r4,[r0,#0x34]         ;1527
0000b0  b2e7              UXTB     r7,r4                 ;1527
0000b2  e7fa              B        |L16.170|
                  |L16.180|
;;;1537   
;;;1538           case UI2C_PROTSTS_STORIF_Msk:
;;;1539               UI2C_CLR_PROT_INT_FLAG(ui2c, UI2C_PROTSTS_STORIF_Msk);     /* Clear STOP INT Flag */
0000b4  f8c09064          STR      r9,[r0,#0x64]
;;;1540               u8Ctrl = UI2C_CTL_PTRG;                                     /* Clear SI */
0000b8  2420              MOVS     r4,#0x20
;;;1541               u8Xfering = 0U;
0000ba  f04f0800          MOV      r8,#0
;;;1542               break;
0000be  e001              B        |L16.196|
                  |L16.192|
;;;1543   
;;;1544           case UI2C_PROTSTS_ARBLOIF_Msk:                                  /* Arbitration Lost */
;;;1545           default:                                                        /* Unknow status */
;;;1546               u8Ctrl = (UI2C_CTL_PTRG | UI2C_CTL_STO);                    /* Clear SI and send STOP */
0000c0  2424              MOVS     r4,#0x24
;;;1547               u8Err = 1U;
0000c2  2601              MOVS     r6,#1
                  |L16.196|
;;;1548               break;
;;;1549           }
;;;1550   
;;;1551           UI2C_SET_CONTROL_REG(ui2c, u8Ctrl);                                 /* Write controlbit to UI2C_PROTCTL register */
0000c4  6dc5              LDR      r5,[r0,#0x5c]
0000c6  f025052e          BIC      r5,r5,#0x2e
0000ca  4325              ORRS     r5,r5,r4
0000cc  65c5              STR      r5,[r0,#0x5c]
0000ce  f1b80f00          CMP      r8,#0                 ;1469
0000d2  d1aa              BNE      |L16.42|
;;;1552       }
;;;1553   
;;;1554       if (u8Err)
0000d4  b106              CBZ      r6,|L16.216|
;;;1555           rdata = 0U;                                                 /* If occurs error, return 0 */
0000d6  2700              MOVS     r7,#0
                  |L16.216|
;;;1556   
;;;1557       return rdata;                                                  /* Return read data */
0000d8  4638              MOV      r0,r7
;;;1558   }
0000da  e8bd8ff0          POP      {r4-r11,pc}
;;;1559   
                          ENDP


                          AREA ||i.UI2C_ReadMultiBytes||, CODE, READONLY, ALIGN=1

                  UI2C_ReadMultiBytes PROC
;;;1168     */
;;;1169   uint32_t UI2C_ReadMultiBytes(UI2C_T *ui2c, uint8_t u8SlaveAddr, uint8_t *rdata, uint32_t u32rLen)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;1170   {
;;;1171       uint8_t u8Xfering = 1U, u8Ctrl = 0U;
000004  2701              MOVS     r7,#1
;;;1172       uint32_t u32rxLen = 0U;
000006  2400              MOVS     r4,#0
;;;1173       enum UI2C_MASTER_EVENT eEvent = MASTER_SEND_START;
;;;1174   
;;;1175       UI2C_START(ui2c);                                                       /* Send START */
000008  6dc5              LDR      r5,[r0,#0x5c]
00000a  2612              MOVS     r6,#0x12              ;1173
00000c  f0250520          BIC      r5,r5,#0x20
000010  f0450508          ORR      r5,r5,#8
000014  65c5              STR      r5,[r0,#0x5c]
;;;1176   
;;;1177       while (u8Xfering)
;;;1178       {
;;;1179           while (!(UI2C_GET_PROT_STATUS(ui2c) & 0x3F00U));                     /* Wait UI2C new status occur */
;;;1180   
;;;1181           switch (UI2C_GET_PROT_STATUS(ui2c) & 0x3F00U)
000016  f44f7980          MOV      r9,#0x100
00001a  f44f5c00          MOV      r12,#0x2000
00001e  f44f6a80          MOV      r10,#0x400
000022  f44f7b00          MOV      r11,#0x200
                  |L17.38|
000026  6e45              LDR      r5,[r0,#0x64]         ;1179
000028  f4155f7c          TST      r5,#0x3f00            ;1179
00002c  d0fb              BEQ      |L17.38|
00002e  6e45              LDR      r5,[r0,#0x64]
000030  46c8              MOV      r8,r9
000032  f405557c          AND      r5,r5,#0x3f00
000036  4545              CMP      r5,r8
000038  d013              BEQ      |L17.98|
00003a  46d8              MOV      r8,r11
00003c  4545              CMP      r5,r8
00003e  d025              BEQ      |L17.140|
000040  46d0              MOV      r8,r10
000042  4545              CMP      r5,r8
000044  d019              BEQ      |L17.122|
000046  4565              CMP      r5,r12
000048  d11e              BNE      |L17.136|
;;;1182           {
;;;1183           case UI2C_PROTSTS_STARIF_Msk:
;;;1184               UI2C_CLR_PROT_INT_FLAG(ui2c, UI2C_PROTSTS_STARIF_Msk);     /* Clear START INT Flag */
;;;1185               UI2C_SET_DATA(ui2c, (u8SlaveAddr << 1U) | 0x01U);             /* Write SLA+R to Register UI2C_TXDAT */
;;;1186               eEvent = MASTER_SEND_H_RD_ADDRESS;
;;;1187               u8Ctrl = UI2C_CTL_PTRG;
;;;1188               break;
;;;1189   
;;;1190           case UI2C_PROTSTS_ACKIF_Msk:
;;;1191               UI2C_CLR_PROT_INT_FLAG(ui2c, UI2C_PROTSTS_ACKIF_Msk);      /* Clear ACK INT Flag */
00004a  f8c0c064          STR      r12,[r0,#0x64]
;;;1192   
;;;1193               if (eEvent == MASTER_SEND_H_RD_ADDRESS)
00004e  2e0c              CMP      r6,#0xc
000050  d010              BEQ      |L17.116|
;;;1194               {
;;;1195                   u8Ctrl = (UI2C_CTL_PTRG | UI2C_CTL_AA);
;;;1196                   eEvent = MASTER_READ_DATA;
;;;1197               }
;;;1198               else
;;;1199               {
;;;1200                   rdata[u32rxLen++] = (unsigned char) UI2C_GET_DATA(ui2c);    /* Receive Data */
000052  6b45              LDR      r5,[r0,#0x34]
000054  5515              STRB     r5,[r2,r4]
;;;1201   
;;;1202                   if (u32rxLen < (u32rLen - 1U))
000056  1e5d              SUBS     r5,r3,#1
000058  1c64              ADDS     r4,r4,#1
00005a  42ac              CMP      r4,r5
00005c  d208              BCS      |L17.112|
;;;1203                       u8Ctrl = (UI2C_CTL_PTRG | UI2C_CTL_AA);
00005e  2522              MOVS     r5,#0x22
000060  e018              B        |L17.148|
                  |L17.98|
000062  f8c08064          STR      r8,[r0,#0x64]         ;1184
000066  2501              MOVS     r5,#1                 ;1185
000068  eb050541          ADD      r5,r5,r1,LSL #1       ;1185
00006c  6305              STR      r5,[r0,#0x30]         ;1185
00006e  260c              MOVS     r6,#0xc               ;1186
                  |L17.112|
;;;1204                   else
;;;1205                       u8Ctrl = UI2C_CTL_PTRG;
000070  2520              MOVS     r5,#0x20
000072  e00f              B        |L17.148|
                  |L17.116|
000074  2522              MOVS     r5,#0x22              ;1195
000076  2610              MOVS     r6,#0x10              ;1196
000078  e00c              B        |L17.148|
                  |L17.122|
;;;1206               }
;;;1207   
;;;1208               break;
;;;1209   
;;;1210           case UI2C_PROTSTS_NACKIF_Msk:
;;;1211               UI2C_CLR_PROT_INT_FLAG(ui2c, UI2C_PROTSTS_NACKIF_Msk);     /* Clear NACK INT Flag */
00007a  f8c08064          STR      r8,[r0,#0x64]
;;;1212   
;;;1213               if (eEvent == MASTER_READ_DATA)
00007e  2e10              CMP      r6,#0x10
000080  d102              BNE      |L17.136|
;;;1214                   rdata[u32rxLen++] = (unsigned char) UI2C_GET_DATA(ui2c);    /* Receive Data */
000082  6b45              LDR      r5,[r0,#0x34]
000084  5515              STRB     r5,[r2,r4]
000086  1c64              ADDS     r4,r4,#1
                  |L17.136|
;;;1215   
;;;1216               u8Ctrl = (UI2C_CTL_PTRG | UI2C_CTL_STO);                        /* Clear SI and send STOP */
000088  2524              MOVS     r5,#0x24
;;;1217   
;;;1218               break;
00008a  e003              B        |L17.148|
                  |L17.140|
;;;1219   
;;;1220           case UI2C_PROTSTS_STORIF_Msk:
;;;1221               UI2C_CLR_PROT_INT_FLAG(ui2c, UI2C_PROTSTS_STORIF_Msk);     /* Clear STOP INT Flag */
00008c  f8c08064          STR      r8,[r0,#0x64]
;;;1222               u8Ctrl = UI2C_CTL_PTRG;                                     /* Clear SI */
000090  2520              MOVS     r5,#0x20
;;;1223               u8Xfering = 0U;
000092  2700              MOVS     r7,#0
                  |L17.148|
;;;1224               break;
;;;1225   
;;;1226           case UI2C_PROTSTS_ARBLOIF_Msk:                                  /* Arbitration Lost */
;;;1227           default:                                                        /* Unknow status */
;;;1228               u8Ctrl = (UI2C_CTL_PTRG | UI2C_CTL_STO);                    /* Clear SI and send STOP */
;;;1229               break;
;;;1230           }
;;;1231   
;;;1232           UI2C_SET_CONTROL_REG(ui2c, u8Ctrl);                                 /* Write controlbit to UI2C_PROTCTL register */
000094  f8d0805c          LDR      r8,[r0,#0x5c]
000098  f028082e          BIC      r8,r8,#0x2e
00009c  ea480805          ORR      r8,r8,r5
0000a0  f8c0805c          STR      r8,[r0,#0x5c]
0000a4  2f00              CMP      r7,#0
0000a6  d1be              BNE      |L17.38|
;;;1233       }
;;;1234   
;;;1235       return u32rxLen;                                                        /* Return bytes length that have been received */
0000a8  4620              MOV      r0,r4
;;;1236   }
0000aa  e8bd8ff0          POP      {r4-r11,pc}
;;;1237   
                          ENDP


                          AREA ||i.UI2C_ReadMultiBytesOneReg||, CODE, READONLY, ALIGN=1

                  UI2C_ReadMultiBytesOneReg PROC
;;;1357     */
;;;1358   uint32_t UI2C_ReadMultiBytesOneReg(UI2C_T *ui2c, uint8_t u8SlaveAddr, uint8_t u8DataAddr, uint8_t *rdata, uint32_t u32rLen)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;1359   {
;;;1360       uint8_t u8Xfering = 1U, u8Ctrl = 0U;
000004  2701              MOVS     r7,#1
;;;1361       uint32_t u32rxLen = 0U;
000006  2600              MOVS     r6,#0
;;;1362       enum UI2C_MASTER_EVENT eEvent = MASTER_SEND_START;
;;;1363   
;;;1364       UI2C_START(ui2c);                                                       /* Send START */
000008  f8ddc024          LDR      r12,[sp,#0x24]
00000c  6dc5              LDR      r5,[r0,#0x5c]
00000e  2412              MOVS     r4,#0x12              ;1362
000010  f0250520          BIC      r5,r5,#0x20
000014  f0450508          ORR      r5,r5,#8
000018  65c5              STR      r5,[r0,#0x5c]
;;;1365   
;;;1366       while (u8Xfering)
;;;1367       {
;;;1368           while (!(UI2C_GET_PROT_STATUS(ui2c) & 0x3F00U));                     /* Wait UI2C new status occur */
;;;1369   
;;;1370           switch (UI2C_GET_PROT_STATUS(ui2c) & 0x3F00U)
00001a  f44f7980          MOV      r9,#0x100
00001e  f44f5a00          MOV      r10,#0x2000
000022  f44f6b80          MOV      r11,#0x400
000026  f44f7e00          MOV      lr,#0x200
                  |L18.42|
00002a  6e45              LDR      r5,[r0,#0x64]         ;1368
00002c  f4155f7c          TST      r5,#0x3f00            ;1368
000030  d0fb              BEQ      |L18.42|
000032  6e45              LDR      r5,[r0,#0x64]
000034  46c8              MOV      r8,r9
000036  f405557c          AND      r5,r5,#0x3f00
00003a  4545              CMP      r5,r8
00003c  d019              BEQ      |L18.114|
00003e  46f0              MOV      r8,lr
000040  4545              CMP      r5,r8
000042  d03b              BEQ      |L18.188|
000044  46d8              MOV      r8,r11
000046  4545              CMP      r5,r8
000048  d02f              BEQ      |L18.170|
00004a  46d0              MOV      r8,r10
00004c  4545              CMP      r5,r8
00004e  d133              BNE      |L18.184|
;;;1371           {
;;;1372           case UI2C_PROTSTS_STARIF_Msk:
;;;1373               UI2C_CLR_PROT_INT_FLAG(ui2c, UI2C_PROTSTS_STARIF_Msk);     /* Clear START INT Flag */
;;;1374   
;;;1375               if (eEvent == MASTER_SEND_START)
;;;1376               {
;;;1377                   UI2C_SET_DATA(ui2c, (u8SlaveAddr << 1U) | 0x00U);         /* Write SLA+W to Register UI2C_TXDAT */
;;;1378                   eEvent = MASTER_SEND_ADDRESS;
;;;1379               }
;;;1380               else if (eEvent == MASTER_SEND_REPEAT_START)
;;;1381               {
;;;1382                   UI2C_SET_DATA(ui2c, (u8SlaveAddr << 1U) | 0x01U);        /* Write SLA+R to Register TXDAT */
;;;1383                   eEvent = MASTER_SEND_H_RD_ADDRESS;
;;;1384               }
;;;1385   
;;;1386               u8Ctrl = UI2C_CTL_PTRG;
;;;1387               break;
;;;1388   
;;;1389           case UI2C_PROTSTS_ACKIF_Msk:
;;;1390               UI2C_CLR_PROT_INT_FLAG(ui2c, UI2C_PROTSTS_ACKIF_Msk);      /* Clear ACK INT Flag */
000050  f8c08064          STR      r8,[r0,#0x64]
;;;1391   
;;;1392               if (eEvent == MASTER_SEND_ADDRESS)
000054  2c0a              CMP      r4,#0xa
000056  d01e              BEQ      |L18.150|
;;;1393               {
;;;1394                   UI2C_SET_DATA(ui2c, u8DataAddr);                        /* Write data address of register */
;;;1395                   u8Ctrl = UI2C_CTL_PTRG;
;;;1396                   eEvent = MASTER_SEND_DATA;
;;;1397               }
;;;1398               else if (eEvent == MASTER_SEND_DATA)
000058  2c0e              CMP      r4,#0xe
00005a  d020              BEQ      |L18.158|
;;;1399               {
;;;1400                   u8Ctrl = (UI2C_CTL_PTRG | UI2C_CTL_STA);                /* Send repeat START signal */
;;;1401                   eEvent = MASTER_SEND_REPEAT_START;
;;;1402               }
;;;1403               else if (eEvent == MASTER_SEND_H_RD_ADDRESS)
00005c  2c0c              CMP      r4,#0xc
00005e  d021              BEQ      |L18.164|
;;;1404               {
;;;1405                   /* SLA+R ACK */
;;;1406                   u8Ctrl = (UI2C_CTL_PTRG | UI2C_CTL_AA);
;;;1407                   eEvent = MASTER_READ_DATA;
;;;1408               }
;;;1409               else
;;;1410               {
;;;1411                   rdata[u32rxLen++] = (uint8_t) UI2C_GET_DATA(ui2c);      /* Receive Data */
000060  6b45              LDR      r5,[r0,#0x34]
000062  559d              STRB     r5,[r3,r6]
;;;1412   
;;;1413                   if (u32rxLen < u32rLen - 1U)
000064  f1ac0501          SUB      r5,r12,#1
000068  1c76              ADDS     r6,r6,#1
00006a  42ae              CMP      r6,r5
00006c  d211              BCS      |L18.146|
;;;1414                       u8Ctrl = (UI2C_CTL_PTRG | UI2C_CTL_AA);
00006e  2522              MOVS     r5,#0x22
000070  e028              B        |L18.196|
                  |L18.114|
000072  f8c08064          STR      r8,[r0,#0x64]         ;1373
000076  2c12              CMP      r4,#0x12              ;1375
000078  d002              BEQ      |L18.128|
00007a  2c0f              CMP      r4,#0xf               ;1380
00007c  d004              BEQ      |L18.136|
00007e  e008              B        |L18.146|
                  |L18.128|
000080  004c              LSLS     r4,r1,#1              ;1377
000082  6304              STR      r4,[r0,#0x30]         ;1377
000084  240a              MOVS     r4,#0xa               ;1378
000086  e004              B        |L18.146|
                  |L18.136|
000088  2401              MOVS     r4,#1                 ;1382
00008a  eb040441          ADD      r4,r4,r1,LSL #1       ;1382
00008e  6304              STR      r4,[r0,#0x30]         ;1382
000090  240c              MOVS     r4,#0xc               ;1383
                  |L18.146|
;;;1415                   else
;;;1416                       u8Ctrl = UI2C_CTL_PTRG;
000092  2520              MOVS     r5,#0x20
000094  e016              B        |L18.196|
                  |L18.150|
000096  6302              STR      r2,[r0,#0x30]         ;1394
000098  2520              MOVS     r5,#0x20              ;1395
00009a  240e              MOVS     r4,#0xe               ;1396
00009c  e012              B        |L18.196|
                  |L18.158|
00009e  2528              MOVS     r5,#0x28              ;1400
0000a0  240f              MOVS     r4,#0xf               ;1401
0000a2  e00f              B        |L18.196|
                  |L18.164|
0000a4  2522              MOVS     r5,#0x22              ;1406
0000a6  2410              MOVS     r4,#0x10              ;1407
0000a8  e00c              B        |L18.196|
                  |L18.170|
;;;1417               }
;;;1418   
;;;1419               break;
;;;1420   
;;;1421           case UI2C_PROTSTS_NACKIF_Msk:
;;;1422               UI2C_CLR_PROT_INT_FLAG(ui2c, UI2C_PROTSTS_NACKIF_Msk);     /* Clear NACK INT Flag */
0000aa  f8c08064          STR      r8,[r0,#0x64]
;;;1423   
;;;1424               if (eEvent == MASTER_READ_DATA)
0000ae  2c10              CMP      r4,#0x10
0000b0  d102              BNE      |L18.184|
;;;1425                   rdata[u32rxLen++] = (uint8_t) UI2C_GET_DATA(ui2c);                  /* Receive Data */
0000b2  6b45              LDR      r5,[r0,#0x34]
0000b4  559d              STRB     r5,[r3,r6]
0000b6  1c76              ADDS     r6,r6,#1
                  |L18.184|
;;;1426   
;;;1427               u8Ctrl = (UI2C_CTL_PTRG | UI2C_CTL_STO);                        /* Clear SI and send STOP */
0000b8  2524              MOVS     r5,#0x24
;;;1428   
;;;1429               break;
0000ba  e003              B        |L18.196|
                  |L18.188|
;;;1430   
;;;1431           case UI2C_PROTSTS_STORIF_Msk:
;;;1432               UI2C_CLR_PROT_INT_FLAG(ui2c, UI2C_PROTSTS_STORIF_Msk);     /* Clear STOP INT Flag */
0000bc  f8c08064          STR      r8,[r0,#0x64]
;;;1433               u8Ctrl = UI2C_CTL_PTRG;                                     /* Clear SI */
0000c0  2520              MOVS     r5,#0x20
;;;1434               u8Xfering = 0U;
0000c2  2700              MOVS     r7,#0
                  |L18.196|
;;;1435               break;
;;;1436   
;;;1437           case UI2C_PROTSTS_ARBLOIF_Msk:                                  /* Arbitration Lost */
;;;1438           default:                                                        /* Unknow status */
;;;1439               u8Ctrl = (UI2C_CTL_PTRG | UI2C_CTL_STO);                    /* Clear SI and send STOP */
;;;1440               break;
;;;1441           }
;;;1442   
;;;1443           UI2C_SET_CONTROL_REG(ui2c, u8Ctrl);                                 /* Write controlbit to UI2C_PROTCTL register */
0000c4  f8d0805c          LDR      r8,[r0,#0x5c]
0000c8  f028082e          BIC      r8,r8,#0x2e
0000cc  ea480805          ORR      r8,r8,r5
0000d0  f8c0805c          STR      r8,[r0,#0x5c]
0000d4  2f00              CMP      r7,#0
0000d6  d1a8              BNE      |L18.42|
;;;1444       }
;;;1445   
;;;1446       return u32rxLen;                                               /* Return bytes length that have been received */
0000d8  4630              MOV      r0,r6
;;;1447   }
0000da  e8bd8ff0          POP      {r4-r11,pc}
;;;1448   
                          ENDP


                          AREA ||i.UI2C_ReadMultiBytesTwoRegs||, CODE, READONLY, ALIGN=1

                  UI2C_ReadMultiBytesTwoRegs PROC
;;;1574     */
;;;1575   uint32_t UI2C_ReadMultiBytesTwoRegs(UI2C_T *ui2c, uint8_t u8SlaveAddr, uint16_t u16DataAddr, uint8_t *rdata, uint32_t u32rLen)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;1576   {
;;;1577       uint8_t u8Xfering = 1U, u8Addr = 1U, u8Ctrl = 0U;
000004  2500              MOVS     r5,#0
000006  f04f0801          MOV      r8,#1
;;;1578       uint32_t u32rxLen = 0U;
;;;1579       enum UI2C_MASTER_EVENT eEvent = MASTER_SEND_START;
;;;1580   
;;;1581       UI2C_START(ui2c);                                                       /* Send START */
00000a  f8dda024          LDR      r10,[sp,#0x24]
00000e  6dc7              LDR      r7,[r0,#0x5c]
000010  46c4              MOV      r12,r8                ;1577
000012  462e              MOV      r6,r5                 ;1578
000014  2412              MOVS     r4,#0x12              ;1579
000016  f0270720          BIC      r7,r7,#0x20
00001a  f0470708          ORR      r7,r7,#8
00001e  65c7              STR      r7,[r0,#0x5c]
;;;1582   
;;;1583       while (u8Xfering)
;;;1584       {
;;;1585           while (!(UI2C_GET_PROT_STATUS(ui2c) & 0x3F00U));                     /* Wait UI2C new status occur */
;;;1586   
;;;1587           switch (UI2C_GET_PROT_STATUS(ui2c) & 0x3F00U)
000020  f44f7b80          MOV      r11,#0x100
000024  f44f5e00          MOV      lr,#0x2000
                  |L19.40|
000028  6e47              LDR      r7,[r0,#0x64]         ;1585
00002a  f4175f7c          TST      r7,#0x3f00            ;1585
00002e  d0fb              BEQ      |L19.40|
000030  6e47              LDR      r7,[r0,#0x64]
000032  f407577c          AND      r7,r7,#0x3f00
000036  455f              CMP      r7,r11
000038  d01a              BEQ      |L19.112|
00003a  f44f7900          MOV      r9,#0x200
00003e  454f              CMP      r7,r9
000040  d043              BEQ      |L19.202|
000042  f44f6980          MOV      r9,#0x400
000046  454f              CMP      r7,r9
000048  d036              BEQ      |L19.184|
00004a  4577              CMP      r7,lr
00004c  d13b              BNE      |L19.198|
;;;1588           {
;;;1589           case UI2C_PROTSTS_STARIF_Msk:
;;;1590               UI2C_CLR_PROT_INT_FLAG(ui2c, UI2C_PROTSTS_STARIF_Msk);     /* Clear START INT Flag */
;;;1591   
;;;1592               if (eEvent == MASTER_SEND_START)
;;;1593               {
;;;1594                   UI2C_SET_DATA(ui2c, (u8SlaveAddr << 1U) | 0x00U);         /* Write SLA+W to Register UI2C_TXDAT */
;;;1595                   eEvent = MASTER_SEND_ADDRESS;
;;;1596               }
;;;1597               else if (eEvent == MASTER_SEND_REPEAT_START)
;;;1598               {
;;;1599                   UI2C_SET_DATA(ui2c, (u8SlaveAddr << 1U) | 0x01U);        /* Write SLA+R to Register TXDAT */
;;;1600                   eEvent = MASTER_SEND_H_RD_ADDRESS;
;;;1601               }
;;;1602   
;;;1603               u8Ctrl = UI2C_CTL_PTRG;
;;;1604               break;
;;;1605   
;;;1606           case UI2C_PROTSTS_ACKIF_Msk:
;;;1607               UI2C_CLR_PROT_INT_FLAG(ui2c, UI2C_PROTSTS_ACKIF_Msk);      /* Clear ACK INT Flag */
00004e  f8c0e064          STR      lr,[r0,#0x64]
;;;1608   
;;;1609               if (eEvent == MASTER_SEND_ADDRESS)
000052  2c0a              CMP      r4,#0xa
000054  d01e              BEQ      |L19.148|
;;;1610               {
;;;1611                   UI2C_SET_DATA(ui2c, (uint8_t)((u16DataAddr & 0xFF00U) >> 8U));  /* Write Hi byte address of register */
;;;1612                   eEvent = MASTER_SEND_DATA;
;;;1613               }
;;;1614               else if (eEvent == MASTER_SEND_DATA)
000056  2c0e              CMP      r4,#0xe
000058  d020              BEQ      |L19.156|
;;;1615               {
;;;1616                   if (u8Addr)
;;;1617                   {
;;;1618                       UI2C_SET_DATA(ui2c, (uint8_t)(u16DataAddr & 0xFFU));       /* Write Lo byte address of register */
;;;1619                       u8Addr = 0;
;;;1620                   }
;;;1621                   else
;;;1622                   {
;;;1623                       u8Ctrl = (UI2C_CTL_PTRG | UI2C_CTL_STA);                /* Send repeat START signal */
;;;1624                       eEvent = MASTER_SEND_REPEAT_START;
;;;1625                   }
;;;1626               }
;;;1627               else if (eEvent == MASTER_SEND_H_RD_ADDRESS)
00005a  2c0c              CMP      r4,#0xc
00005c  d029              BEQ      |L19.178|
;;;1628               {
;;;1629                   u8Ctrl = (UI2C_CTL_PTRG | UI2C_CTL_AA);
;;;1630                   eEvent = MASTER_READ_DATA;
;;;1631               }
;;;1632               else
;;;1633               {
;;;1634                   rdata[u32rxLen++] = (uint8_t) UI2C_GET_DATA(ui2c);      /* Receive Data */
00005e  6b45              LDR      r5,[r0,#0x34]
000060  559d              STRB     r5,[r3,r6]
;;;1635   
;;;1636                   if (u32rxLen < u32rLen - 1U)
000062  f1aa0501          SUB      r5,r10,#1
000066  1c76              ADDS     r6,r6,#1
000068  42ae              CMP      r6,r5
00006a  d211              BCS      |L19.144|
;;;1637                       u8Ctrl = (UI2C_CTL_PTRG | UI2C_CTL_AA);
00006c  2522              MOVS     r5,#0x22
00006e  e031              B        |L19.212|
                  |L19.112|
000070  f8c0b064          STR      r11,[r0,#0x64]        ;1590
000074  2c12              CMP      r4,#0x12              ;1592
000076  d002              BEQ      |L19.126|
000078  2c0f              CMP      r4,#0xf               ;1597
00007a  d004              BEQ      |L19.134|
00007c  e008              B        |L19.144|
                  |L19.126|
00007e  004c              LSLS     r4,r1,#1              ;1594
000080  6304              STR      r4,[r0,#0x30]         ;1594
000082  240a              MOVS     r4,#0xa               ;1595
000084  e004              B        |L19.144|
                  |L19.134|
000086  2401              MOVS     r4,#1                 ;1599
000088  eb040441          ADD      r4,r4,r1,LSL #1       ;1599
00008c  6304              STR      r4,[r0,#0x30]         ;1599
00008e  240c              MOVS     r4,#0xc               ;1600
                  |L19.144|
;;;1638                   else
;;;1639                       u8Ctrl = UI2C_CTL_PTRG;
000090  2520              MOVS     r5,#0x20
000092  e01f              B        |L19.212|
                  |L19.148|
000094  0a14              LSRS     r4,r2,#8              ;1611
000096  6304              STR      r4,[r0,#0x30]         ;1611
000098  240e              MOVS     r4,#0xe               ;1612
00009a  e01b              B        |L19.212|
                  |L19.156|
00009c  f1bc0f00          CMP      r12,#0                ;1616
0000a0  d004              BEQ      |L19.172|
0000a2  b2d7              UXTB     r7,r2                 ;1618
0000a4  6307              STR      r7,[r0,#0x30]         ;1618
0000a6  f04f0c00          MOV      r12,#0                ;1619
0000aa  e013              B        |L19.212|
                  |L19.172|
0000ac  2528              MOVS     r5,#0x28              ;1623
0000ae  240f              MOVS     r4,#0xf               ;1624
0000b0  e010              B        |L19.212|
                  |L19.178|
0000b2  2522              MOVS     r5,#0x22              ;1629
0000b4  2410              MOVS     r4,#0x10              ;1630
0000b6  e00d              B        |L19.212|
                  |L19.184|
;;;1640               }
;;;1641   
;;;1642               break;
;;;1643   
;;;1644           case UI2C_PROTSTS_NACKIF_Msk:
;;;1645               UI2C_CLR_PROT_INT_FLAG(ui2c, UI2C_PROTSTS_NACKIF_Msk);     /* Clear NACK INT Flag */
0000b8  f8c09064          STR      r9,[r0,#0x64]
;;;1646   
;;;1647               if (eEvent == MASTER_READ_DATA)
0000bc  2c10              CMP      r4,#0x10
0000be  d102              BNE      |L19.198|
;;;1648                   rdata[u32rxLen++] = (uint8_t) UI2C_GET_DATA(ui2c);                  /* Receive Data */
0000c0  6b45              LDR      r5,[r0,#0x34]
0000c2  559d              STRB     r5,[r3,r6]
0000c4  1c76              ADDS     r6,r6,#1
                  |L19.198|
;;;1649   
;;;1650               u8Ctrl = (UI2C_CTL_PTRG | UI2C_CTL_STO);                        /* Clear SI and send STOP */
0000c6  2524              MOVS     r5,#0x24
;;;1651   
;;;1652               break;
0000c8  e004              B        |L19.212|
                  |L19.202|
;;;1653   
;;;1654           case UI2C_PROTSTS_STORIF_Msk:
;;;1655               UI2C_CLR_PROT_INT_FLAG(ui2c, UI2C_PROTSTS_STORIF_Msk);     /* Clear STOP INT Flag */
0000ca  f8c09064          STR      r9,[r0,#0x64]
;;;1656               u8Ctrl = UI2C_CTL_PTRG;                                     /* Clear SI */
0000ce  2520              MOVS     r5,#0x20
;;;1657               u8Xfering = 0U;
0000d0  f04f0800          MOV      r8,#0
                  |L19.212|
;;;1658               break;
;;;1659   
;;;1660           case UI2C_PROTSTS_ARBLOIF_Msk:                                  /* Arbitration Lost */
;;;1661           default:                                                        /* Unknow status */
;;;1662               u8Ctrl = (UI2C_CTL_PTRG | UI2C_CTL_STO);                    /* Clear SI and send STOP */
;;;1663               break;
;;;1664           }
;;;1665   
;;;1666           UI2C_SET_CONTROL_REG(ui2c, u8Ctrl);                                 /* Write controlbit to UI2C_PROTCTL register */
0000d4  6dc7              LDR      r7,[r0,#0x5c]
0000d6  f027072e          BIC      r7,r7,#0x2e
0000da  432f              ORRS     r7,r7,r5
0000dc  65c7              STR      r7,[r0,#0x5c]
0000de  f1b80f00          CMP      r8,#0                 ;1583
0000e2  d1a1              BNE      |L19.40|
;;;1667       }
;;;1668   
;;;1669       return u32rxLen;                                                        /* Return bytes length that have been received */
0000e4  4630              MOV      r0,r6
;;;1670   }
0000e6  e8bd8ff0          POP      {r4-r11,pc}
;;;1671   
                          ENDP


                          AREA ||i.UI2C_SetBusClockFreq||, CODE, READONLY, ALIGN=2

                  UI2C_SetBusClockFreq PROC
;;;299     */
;;;300    uint32_t UI2C_SetBusClockFreq(UI2C_T *ui2c, uint32_t u32BusClock)
000000  b570              PUSH     {r4-r6,lr}
;;;301    {
000002  4604              MOV      r4,r0
;;;302        uint32_t u32ClkDiv;
;;;303        uint32_t u32Pclk;
;;;304    
;;;305        if( ui2c == UI2C0 )
000004  480f              LDR      r0,|L20.68|
000006  460d              MOV      r5,r1                 ;301
000008  4284              CMP      r4,r0
00000a  d102              BNE      |L20.18|
;;;306        {
;;;307            u32Pclk = CLK_GetPCLK0Freq();
00000c  f7fffffe          BL       CLK_GetPCLK0Freq
000010  e001              B        |L20.22|
                  |L20.18|
;;;308        }
;;;309        else
;;;310        {
;;;311            u32Pclk = CLK_GetPCLK1Freq();
000012  f7fffffe          BL       CLK_GetPCLK1Freq
                  |L20.22|
;;;312        }
;;;313    
;;;314        u32ClkDiv = (uint32_t) ((((((u32Pclk/2U)*10U)/(u32BusClock))+5U)/10U)-1U); /* Compute proper divider for USCI_I2C clock */
000016  0842              LSRS     r2,r0,#1
000018  eb020182          ADD      r1,r2,r2,LSL #2
00001c  0049              LSLS     r1,r1,#1
00001e  fbb1f1f5          UDIV     r1,r1,r5
000022  220a              MOVS     r2,#0xa
000024  1d49              ADDS     r1,r1,#5
000026  fbb1f1f2          UDIV     r1,r1,r2
;;;315    
;;;316        /* Set USCI_I2C bus clock */
;;;317        ui2c->BRGEN &= ~UI2C_BRGEN_CLKDIV_Msk;
00002a  68a3              LDR      r3,[r4,#8]
00002c  1e4a              SUBS     r2,r1,#1              ;314
00002e  4d06              LDR      r5,|L20.72|
000030  402b              ANDS     r3,r3,r5
000032  60a3              STR      r3,[r4,#8]
;;;318        ui2c->BRGEN |=  (u32ClkDiv << UI2C_BRGEN_CLKDIV_Pos);
000034  68a3              LDR      r3,[r4,#8]
000036  ea434202          ORR      r2,r3,r2,LSL #16
00003a  60a2              STR      r2,[r4,#8]
;;;319    
;;;320        return ( u32Pclk / ((u32ClkDiv+1U)<<1U) );
;;;321    }
00003c  0049              LSLS     r1,r1,#1
00003e  fbb0f0f1          UDIV     r0,r0,r1              ;320
000042  bd70              POP      {r4-r6,pc}
;;;322    
                          ENDP

                  |L20.68|
                          DCD      0x400d0000
                  |L20.72|
                          DCD      0xfc00ffff

                          AREA ||i.UI2C_SetData||, CODE, READONLY, ALIGN=1

                  UI2C_SetData PROC
;;;485     */
;;;486    void UI2C_SetData(UI2C_T *ui2c, uint8_t u8Data)
000000  6301              STR      r1,[r0,#0x30]
;;;487    {
;;;488        ui2c->TXDAT = u8Data;
;;;489    }
000002  4770              BX       lr
;;;490    
                          ENDP


                          AREA ||i.UI2C_SetSlaveAddr||, CODE, READONLY, ALIGN=1

                  UI2C_SetSlaveAddr PROC
;;;504     */
;;;505    void UI2C_SetSlaveAddr(UI2C_T *ui2c, uint8_t u8SlaveNo, uint16_t u16SlaveAddr, uint8_t u8GCMode)
000000  b109              CBZ      r1,|L22.6|
;;;506    {
;;;507        if(u8SlaveNo)
;;;508        {
;;;509            ui2c->DEVADDR1  = u16SlaveAddr;
000002  6482              STR      r2,[r0,#0x48]
000004  e000              B        |L22.8|
                  |L22.6|
;;;510        }
;;;511        else
;;;512        {
;;;513            ui2c->DEVADDR0  = u16SlaveAddr;
000006  6442              STR      r2,[r0,#0x44]
                  |L22.8|
;;;514        }
;;;515    
;;;516        ui2c->PROTCTL  = (ui2c->PROTCTL & ~UI2C_PROTCTL_GCFUNC_Msk) |u8GCMode;
000008  6dc1              LDR      r1,[r0,#0x5c]
00000a  f0210101          BIC      r1,r1,#1
00000e  4319              ORRS     r1,r1,r3
000010  65c1              STR      r1,[r0,#0x5c]
;;;517    }
000012  4770              BX       lr
;;;518    
                          ENDP


                          AREA ||i.UI2C_SetSlaveAddrMask||, CODE, READONLY, ALIGN=1

                  UI2C_SetSlaveAddrMask PROC
;;;530     */
;;;531    void UI2C_SetSlaveAddrMask(UI2C_T *ui2c, uint8_t u8SlaveNo, uint16_t u16SlaveAddrMask)
000000  b109              CBZ      r1,|L23.6|
;;;532    {
;;;533        if(u8SlaveNo)
;;;534        {
;;;535            ui2c->ADDRMSK1  = u16SlaveAddrMask;
000002  6502              STR      r2,[r0,#0x50]
;;;536        }
;;;537        else
;;;538        {
;;;539            ui2c->ADDRMSK0  = u16SlaveAddrMask;
;;;540        }
;;;541    }
000004  4770              BX       lr
                  |L23.6|
000006  64c2              STR      r2,[r0,#0x4c]         ;539
000008  4770              BX       lr
;;;542    
                          ENDP


                          AREA ||i.UI2C_Trigger||, CODE, READONLY, ALIGN=1

                  UI2C_Trigger PROC
;;;110     */
;;;111    void UI2C_Trigger(UI2C_T *ui2c, uint8_t u8Start, uint8_t u8Stop, uint8_t u8Ptrg, uint8_t u8Ack)
000000  b570              PUSH     {r4-r6,lr}
;;;112    {
;;;113        uint32_t u32Reg = 0U;
;;;114        uint32_t u32Val = ui2c->PROTCTL & ~(UI2C_PROTCTL_STA_Msk | UI2C_PROTCTL_STO_Msk | UI2C_PROTCTL_AA_Msk);
000002  6dc5              LDR      r5,[r0,#0x5c]
000004  9e04              LDR      r6,[sp,#0x10]
000006  2400              MOVS     r4,#0                 ;113
000008  f025050e          BIC      r5,r5,#0xe
00000c  b101              CBZ      r1,|L24.16|
;;;115    
;;;116        if (u8Start)
;;;117        {
;;;118            u32Reg |= UI2C_PROTCTL_STA_Msk;
00000e  2408              MOVS     r4,#8
                  |L24.16|
;;;119        }
;;;120        if (u8Stop)
000010  b10a              CBZ      r2,|L24.22|
;;;121        {
;;;122            u32Reg |= UI2C_PROTCTL_STO_Msk;
000012  f0440404          ORR      r4,r4,#4
                  |L24.22|
;;;123        }
;;;124        if (u8Ptrg)
000016  b10b              CBZ      r3,|L24.28|
;;;125        {
;;;126            u32Reg |= UI2C_PROTCTL_PTRG_Msk;
000018  f0440420          ORR      r4,r4,#0x20
                  |L24.28|
;;;127        }
;;;128        if (u8Ack)
00001c  b10e              CBZ      r6,|L24.34|
;;;129        {
;;;130            u32Reg |= UI2C_PROTCTL_AA_Msk;
00001e  f0440402          ORR      r4,r4,#2
                  |L24.34|
;;;131        }
;;;132    
;;;133        ui2c->PROTCTL = u32Val | u32Reg;
000022  4325              ORRS     r5,r5,r4
000024  65c5              STR      r5,[r0,#0x5c]
;;;134    }
000026  bd70              POP      {r4-r6,pc}
;;;135    
                          ENDP


                          AREA ||i.UI2C_WriteByte||, CODE, READONLY, ALIGN=1

                  UI2C_WriteByte PROC
;;;618    
;;;619    uint8_t UI2C_WriteByte(UI2C_T *ui2c, uint8_t u8SlaveAddr, uint8_t data)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;620    {
;;;621        uint8_t u8Xfering = 1U, u8Err = 0U, u8Ctrl = 0U;
000004  2600              MOVS     r6,#0
000006  2701              MOVS     r7,#1
;;;622        enum UI2C_MASTER_EVENT eEvent = MASTER_SEND_START;
;;;623    
;;;624        UI2C_START(ui2c);                                                       /* Send START */
000008  6dc4              LDR      r4,[r0,#0x5c]
00000a  4633              MOV      r3,r6                 ;621
00000c  2512              MOVS     r5,#0x12              ;622
00000e  f0240420          BIC      r4,r4,#0x20
000012  f0440408          ORR      r4,r4,#8
000016  65c4              STR      r4,[r0,#0x5c]
;;;625    
;;;626        while (u8Xfering)
;;;627        {
;;;628            while (!(UI2C_GET_PROT_STATUS(ui2c) & 0x3F00U));                     /* Wait UI2C new status occur */
;;;629    
;;;630            switch (UI2C_GET_PROT_STATUS(ui2c) & 0x3F00U)
000018  f44f7980          MOV      r9,#0x100
00001c  f44f5800          MOV      r8,#0x2000
000020  f44f6a80          MOV      r10,#0x400
000024  f44f7b00          MOV      r11,#0x200
                  |L25.40|
000028  6e44              LDR      r4,[r0,#0x64]         ;628
00002a  f4145f7c          TST      r4,#0x3f00            ;628
00002e  d0fb              BEQ      |L25.40|
000030  6e44              LDR      r4,[r0,#0x64]
000032  46cc              MOV      r12,r9
000034  f404547c          AND      r4,r4,#0x3f00
000038  4564              CMP      r4,r12
00003a  d00d              BEQ      |L25.88|
00003c  46dc              MOV      r12,r11
00003e  4564              CMP      r4,r12
000040  d022              BEQ      |L25.136|
000042  46d4              MOV      r12,r10
000044  4564              CMP      r4,r12
000046  d011              BEQ      |L25.108|
000048  4544              CMP      r4,r8
00004a  d111              BNE      |L25.112|
;;;631            {
;;;632            case UI2C_PROTSTS_STARIF_Msk:
;;;633                UI2C_CLR_PROT_INT_FLAG(ui2c, UI2C_PROTSTS_STARIF_Msk);     /* Clear START INT Flag */
;;;634                UI2C_SET_DATA(ui2c, (u8SlaveAddr << 1U) | 0x00U);             /* Write SLA+W to Register UI2C_TXDAT */
;;;635                eEvent = MASTER_SEND_ADDRESS;
;;;636                u8Ctrl = UI2C_CTL_PTRG;                                     /* Clear SI */
;;;637                break;
;;;638    
;;;639            case UI2C_PROTSTS_ACKIF_Msk:
;;;640                UI2C_CLR_PROT_INT_FLAG(ui2c, UI2C_PROTSTS_ACKIF_Msk);      /* Clear ACK INT Flag */
00004c  f8c08064          STR      r8,[r0,#0x64]
;;;641    
;;;642                if (eEvent == MASTER_SEND_ADDRESS)
000050  2d0a              CMP      r5,#0xa
000052  d008              BEQ      |L25.102|
;;;643                {
;;;644                    UI2C_SET_DATA(ui2c, data);                              /* Write data to UI2C_TXDAT */
;;;645                    eEvent = MASTER_SEND_DATA;
;;;646                }
;;;647                else
;;;648                {
;;;649                    u8Ctrl = (UI2C_CTL_PTRG | UI2C_CTL_STO);                /* Clear SI and send STOP */
000054  2324              MOVS     r3,#0x24
000056  e00d              B        |L25.116|
                  |L25.88|
000058  f8c0c064          STR      r12,[r0,#0x64]        ;633
00005c  004b              LSLS     r3,r1,#1              ;634
00005e  6303              STR      r3,[r0,#0x30]         ;634
000060  250a              MOVS     r5,#0xa               ;635
000062  2320              MOVS     r3,#0x20              ;636
000064  e006              B        |L25.116|
                  |L25.102|
000066  6302              STR      r2,[r0,#0x30]         ;644
000068  250e              MOVS     r5,#0xe               ;645
00006a  e003              B        |L25.116|
                  |L25.108|
;;;650                }
;;;651    
;;;652                break;
;;;653    
;;;654            case UI2C_PROTSTS_NACKIF_Msk:
;;;655                UI2C_CLR_PROT_INT_FLAG(ui2c, UI2C_PROTSTS_NACKIF_Msk);     /* Clear NACK INT Flag */
00006c  f8c0c064          STR      r12,[r0,#0x64]
                  |L25.112|
;;;656                u8Ctrl = (UI2C_CTL_PTRG | UI2C_CTL_STO);                    /* Clear SI and send STOP */
;;;657                u8Err = 1U;
;;;658                break;
;;;659    
;;;660            case UI2C_PROTSTS_STORIF_Msk:
;;;661                UI2C_CLR_PROT_INT_FLAG(ui2c, UI2C_PROTSTS_STORIF_Msk);     /* Clear STOP INT Flag */
;;;662                u8Ctrl = UI2C_CTL_PTRG;                                     /* Clear SI */
;;;663                u8Xfering = 0U;
;;;664                break;
;;;665    
;;;666            case UI2C_PROTSTS_ARBLOIF_Msk:                                  /* Arbitration Lost */
;;;667            default:                                                        /* Unknow status */
;;;668                u8Ctrl = (UI2C_CTL_PTRG | UI2C_CTL_STO);                    /* Clear SI and send STOP */
000070  2324              MOVS     r3,#0x24
;;;669                u8Err = 1U;
000072  2601              MOVS     r6,#1
                  |L25.116|
;;;670                break;
;;;671            }
;;;672    
;;;673            UI2C_SET_CONTROL_REG(ui2c, u8Ctrl);                                 /* Write controlbit to UI2C_PROTCTL register */
000074  6dc4              LDR      r4,[r0,#0x5c]
000076  f024042e          BIC      r4,r4,#0x2e
00007a  431c              ORRS     r4,r4,r3
00007c  65c4              STR      r4,[r0,#0x5c]
00007e  2f00              CMP      r7,#0
000080  d1d2              BNE      |L25.40|
;;;674        }
;;;675    
;;;676        return (u8Err | u8Xfering);                                             /* return (Success)/(Fail) status */
000082  4630              MOV      r0,r6
;;;677    }
000084  e8bd8ff0          POP      {r4-r11,pc}
                  |L25.136|
000088  f8c0c064          STR      r12,[r0,#0x64]        ;661
00008c  2320              MOVS     r3,#0x20              ;662
00008e  2700              MOVS     r7,#0                 ;663
000090  e7f0              B        |L25.116|
;;;678    
                          ENDP


                          AREA ||i.UI2C_WriteByteOneReg||, CODE, READONLY, ALIGN=1

                  UI2C_WriteByteOneReg PROC
;;;761    
;;;762    uint8_t UI2C_WriteByteOneReg(UI2C_T *ui2c, uint8_t u8SlaveAddr, uint8_t u8DataAddr, uint8_t data)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;763    {
;;;764        uint8_t u8Xfering = 1U, u8Err = 0U, u8Ctrl = 0U;
000004  2700              MOVS     r7,#0
;;;765        uint32_t u32txLen = 0U;
;;;766    
;;;767        UI2C_START(ui2c);                                                       /* Send START */
000006  6dc5              LDR      r5,[r0,#0x5c]
000008  f04f0c01          MOV      r12,#1                ;764
00000c  463c              MOV      r4,r7                 ;764
00000e  463e              MOV      r6,r7                 ;765
000010  f0250520          BIC      r5,r5,#0x20
000014  f0450508          ORR      r5,r5,#8
000018  65c5              STR      r5,[r0,#0x5c]
;;;768    
;;;769        while (u8Xfering)
;;;770        {
;;;771            while (!(UI2C_GET_PROT_STATUS(ui2c) & 0x3F00U));                     /* Wait UI2C new status occur */
;;;772    
;;;773            switch (UI2C_GET_PROT_STATUS(ui2c) & 0x3F00U)
00001a  f44f7980          MOV      r9,#0x100
00001e  f44f5a00          MOV      r10,#0x2000
000022  f44f6b80          MOV      r11,#0x400
000026  f44f7e00          MOV      lr,#0x200
                  |L26.42|
00002a  6e45              LDR      r5,[r0,#0x64]         ;771
00002c  f4155f7c          TST      r5,#0x3f00            ;771
000030  d0fb              BEQ      |L26.42|
000032  6e45              LDR      r5,[r0,#0x64]
000034  46c8              MOV      r8,r9
000036  f405557c          AND      r5,r5,#0x3f00
00003a  4545              CMP      r5,r8
00003c  d00f              BEQ      |L26.94|
00003e  46f0              MOV      r8,lr
000040  4545              CMP      r5,r8
000042  d027              BEQ      |L26.148|
000044  46d8              MOV      r8,r11
000046  4545              CMP      r5,r8
000048  d015              BEQ      |L26.118|
00004a  46d0              MOV      r8,r10
00004c  4545              CMP      r5,r8
00004e  d114              BNE      |L26.122|
;;;774            {
;;;775            case UI2C_PROTSTS_STARIF_Msk:
;;;776                UI2C_CLR_PROT_INT_FLAG(ui2c, UI2C_PROTSTS_STARIF_Msk);     /* Clear START INT Flag */
;;;777                UI2C_SET_DATA(ui2c, (u8SlaveAddr << 1U) | 0x00U);             /* Write SLA+W to Register UI2C_TXDAT */
;;;778                u8Ctrl = UI2C_CTL_PTRG;                                     /* Clear SI */
;;;779                break;
;;;780    
;;;781            case UI2C_PROTSTS_ACKIF_Msk:
;;;782                UI2C_CLR_PROT_INT_FLAG(ui2c, UI2C_PROTSTS_ACKIF_Msk);      /* Clear ACK INT Flag */
000050  f8c08064          STR      r8,[r0,#0x64]
;;;783    
;;;784                if (u32txLen == 0U)
000054  b14e              CBZ      r6,|L26.106|
;;;785                {
;;;786                    UI2C_SET_DATA(ui2c, u8DataAddr);                        /* Write data address to UI2C_TXDAT */
;;;787                    u32txLen++;
;;;788                }
;;;789                else if (u32txLen == 1U)
000056  2e01              CMP      r6,#1
000058  d00a              BEQ      |L26.112|
;;;790                {
;;;791                    UI2C_SET_DATA(ui2c, data);                              /* Write data to UI2C_TXDAT */
;;;792                    u32txLen++;
;;;793                }
;;;794                else
;;;795                {
;;;796                    u8Ctrl = (UI2C_CTL_PTRG | UI2C_CTL_STO);                /* Clear SI and send STOP */
00005a  2424              MOVS     r4,#0x24
00005c  e00f              B        |L26.126|
                  |L26.94|
00005e  f8c08064          STR      r8,[r0,#0x64]         ;776
000062  004c              LSLS     r4,r1,#1              ;777
000064  6304              STR      r4,[r0,#0x30]         ;777
000066  2420              MOVS     r4,#0x20              ;778
000068  e009              B        |L26.126|
                  |L26.106|
00006a  6302              STR      r2,[r0,#0x30]         ;786
00006c  2601              MOVS     r6,#1                 ;787
00006e  e006              B        |L26.126|
                  |L26.112|
000070  6303              STR      r3,[r0,#0x30]         ;791
000072  2602              MOVS     r6,#2                 ;792
000074  e003              B        |L26.126|
                  |L26.118|
;;;797                }
;;;798    
;;;799                break;
;;;800    
;;;801            case UI2C_PROTSTS_NACKIF_Msk:
;;;802                UI2C_CLR_PROT_INT_FLAG(ui2c, UI2C_PROTSTS_NACKIF_Msk);     /* Clear NACK INT Flag */
000076  f8c08064          STR      r8,[r0,#0x64]
                  |L26.122|
;;;803                u8Ctrl = (UI2C_CTL_PTRG | UI2C_CTL_STO);                    /* Clear SI and send STOP */
;;;804                u8Err = 1U;
;;;805                break;
;;;806    
;;;807            case UI2C_PROTSTS_STORIF_Msk:
;;;808                UI2C_CLR_PROT_INT_FLAG(ui2c, UI2C_PROTSTS_STORIF_Msk);     /* Clear STOP INT Flag */
;;;809                u8Ctrl = UI2C_CTL_PTRG;                                     /* Clear SI */
;;;810                u8Xfering = 0U;
;;;811                break;
;;;812    
;;;813            case UI2C_PROTSTS_ARBLOIF_Msk:                                  /* Arbitration Lost */
;;;814            default:                                                        /* Unknow status */
;;;815                u8Ctrl = (UI2C_CTL_PTRG | UI2C_CTL_STO);                    /* Clear SI and send STOP */
00007a  2424              MOVS     r4,#0x24
;;;816                u8Err = 1U;
00007c  2701              MOVS     r7,#1
                  |L26.126|
;;;817                break;
;;;818            }
;;;819    
;;;820            UI2C_SET_CONTROL_REG(ui2c, u8Ctrl);                                 /* Write controlbit to UI2C_CTL register */
00007e  6dc5              LDR      r5,[r0,#0x5c]
000080  f025052e          BIC      r5,r5,#0x2e
000084  4325              ORRS     r5,r5,r4
000086  65c5              STR      r5,[r0,#0x5c]
000088  f1bc0f00          CMP      r12,#0                ;769
00008c  d1cd              BNE      |L26.42|
;;;821        }
;;;822    
;;;823        return (u8Err | u8Xfering);                                             /* return (Success)/(Fail) status */
00008e  4638              MOV      r0,r7
;;;824    }
000090  e8bd8ff0          POP      {r4-r11,pc}
                  |L26.148|
000094  f8c08064          STR      r8,[r0,#0x64]         ;808
000098  2420              MOVS     r4,#0x20              ;809
00009a  f04f0c00          MOV      r12,#0                ;810
00009e  e7ee              B        |L26.126|
;;;825    
                          ENDP


                          AREA ||i.UI2C_WriteByteTwoRegs||, CODE, READONLY, ALIGN=1

                  UI2C_WriteByteTwoRegs PROC
;;;920    
;;;921    uint8_t UI2C_WriteByteTwoRegs(UI2C_T *ui2c, uint8_t u8SlaveAddr, uint16_t u16DataAddr, uint8_t data)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;922    {
;;;923        uint8_t u8Xfering = 1U, u8Err = 0U, u8Ctrl = 0U;
000004  2700              MOVS     r7,#0
;;;924        uint32_t u32txLen = 0U;
;;;925    
;;;926        UI2C_START(ui2c);                                                           /* Send START */
000006  6dc6              LDR      r6,[r0,#0x5c]
000008  f04f0c01          MOV      r12,#1                ;923
00000c  463d              MOV      r5,r7                 ;923
00000e  463c              MOV      r4,r7                 ;924
000010  f0260620          BIC      r6,r6,#0x20
000014  f0460608          ORR      r6,r6,#8
000018  65c6              STR      r6,[r0,#0x5c]
;;;927    
;;;928        while (u8Xfering)
;;;929        {
;;;930            while (!(UI2C_GET_PROT_STATUS(ui2c) & 0x3F00U));                     /* Wait UI2C new status occur */
;;;931    
;;;932            switch (UI2C_GET_PROT_STATUS(ui2c) & 0x3F00U)
00001a  f44f7980          MOV      r9,#0x100
00001e  f44f5a00          MOV      r10,#0x2000
000022  f44f6b80          MOV      r11,#0x400
000026  f44f7e00          MOV      lr,#0x200
                  |L27.42|
00002a  6e46              LDR      r6,[r0,#0x64]         ;930
00002c  f4165f7c          TST      r6,#0x3f00            ;930
000030  d0fb              BEQ      |L27.42|
000032  6e46              LDR      r6,[r0,#0x64]
000034  46c8              MOV      r8,r9
000036  f406567c          AND      r6,r6,#0x3f00
00003a  4546              CMP      r6,r8
00003c  d011              BEQ      |L27.98|
00003e  46f0              MOV      r8,lr
000040  4546              CMP      r6,r8
000042  d02e              BEQ      |L27.162|
000044  46d8              MOV      r8,r11
000046  4546              CMP      r6,r8
000048  d01c              BEQ      |L27.132|
00004a  46d0              MOV      r8,r10
00004c  4546              CMP      r6,r8
00004e  d11b              BNE      |L27.136|
;;;933            {
;;;934            case UI2C_PROTSTS_STARIF_Msk:
;;;935                UI2C_CLR_PROT_INT_FLAG(ui2c, UI2C_PROTSTS_STARIF_Msk);         /* Clear START INT Flag */
;;;936                UI2C_SET_DATA(ui2c, (u8SlaveAddr << 1U) | 0x00U);                 /* Write SLA+W to Register UI2C_TXDAT */
;;;937                u8Ctrl = UI2C_CTL_PTRG;                                         /* Clear SI */
;;;938                break;
;;;939    
;;;940            case UI2C_PROTSTS_ACKIF_Msk:
;;;941                UI2C_CLR_PROT_INT_FLAG(ui2c, UI2C_PROTSTS_ACKIF_Msk);          /* Clear ACK INT Flag */
000050  f8c08064          STR      r8,[r0,#0x64]
;;;942    
;;;943                if (u32txLen == 0U)
000054  b15c              CBZ      r4,|L27.110|
;;;944                {
;;;945                    UI2C_SET_DATA(ui2c, (uint8_t)((u16DataAddr & 0xFF00U) >> 8U));  /* Write Hi byte data address to UI2C_TXDAT */
;;;946                    u32txLen++;
;;;947                }
;;;948                else if (u32txLen == 1U)
000056  2c01              CMP      r4,#1
000058  d00d              BEQ      |L27.118|
;;;949                {
;;;950                    UI2C_SET_DATA(ui2c, (uint8_t)(u16DataAddr & 0xFFU));         /* Write Lo byte data address to UI2C_TXDAT */
;;;951                    u32txLen++;
;;;952                }
;;;953                else if (u32txLen == 2U)
00005a  2c02              CMP      r4,#2
00005c  d00f              BEQ      |L27.126|
;;;954                {
;;;955                    UI2C_SET_DATA(ui2c, data);                                  /* Write data to UI2C_TXDAT */
;;;956                    u32txLen++;
;;;957                }
;;;958                else
;;;959                {
;;;960                    u8Ctrl = (UI2C_CTL_PTRG | UI2C_CTL_STO);                /* Clear SI and send STOP */
00005e  2524              MOVS     r5,#0x24
000060  e014              B        |L27.140|
                  |L27.98|
000062  f8c08064          STR      r8,[r0,#0x64]         ;935
000066  004d              LSLS     r5,r1,#1              ;936
000068  6305              STR      r5,[r0,#0x30]         ;936
00006a  2520              MOVS     r5,#0x20              ;937
00006c  e00e              B        |L27.140|
                  |L27.110|
00006e  0a14              LSRS     r4,r2,#8              ;945
000070  6304              STR      r4,[r0,#0x30]         ;945
000072  2401              MOVS     r4,#1                 ;946
000074  e00a              B        |L27.140|
                  |L27.118|
000076  b2d4              UXTB     r4,r2                 ;950
000078  6304              STR      r4,[r0,#0x30]         ;950
00007a  2402              MOVS     r4,#2                 ;951
00007c  e006              B        |L27.140|
                  |L27.126|
00007e  6303              STR      r3,[r0,#0x30]         ;955
000080  2403              MOVS     r4,#3                 ;956
000082  e003              B        |L27.140|
                  |L27.132|
;;;961                }
;;;962    
;;;963                break;
;;;964    
;;;965            case UI2C_PROTSTS_NACKIF_Msk:
;;;966                UI2C_CLR_PROT_INT_FLAG(ui2c, UI2C_PROTSTS_NACKIF_Msk);         /* Clear NACK INT Flag */
000084  f8c08064          STR      r8,[r0,#0x64]
                  |L27.136|
;;;967                u8Ctrl = (UI2C_CTL_PTRG | UI2C_CTL_STO);                        /* Clear SI and send STOP */
;;;968                u8Err = 1U;
;;;969                break;
;;;970    
;;;971            case UI2C_PROTSTS_STORIF_Msk:
;;;972                UI2C_CLR_PROT_INT_FLAG(ui2c, UI2C_PROTSTS_STORIF_Msk);     /* Clear STOP INT Flag */
;;;973                u8Ctrl = UI2C_CTL_PTRG;                                     /* Clear SI */
;;;974                u8Xfering = 0U;
;;;975                break;
;;;976    
;;;977            case UI2C_PROTSTS_ARBLOIF_Msk:                                      /* Arbitration Lost */
;;;978            default:                                                            /* Unknow status */
;;;979                u8Ctrl = (UI2C_CTL_PTRG | UI2C_CTL_STO);                        /* Clear SI and send STOP */
000088  2524              MOVS     r5,#0x24
;;;980                u8Err = 1U;
00008a  2701              MOVS     r7,#1
                  |L27.140|
;;;981                break;
;;;982            }
;;;983    
;;;984            UI2C_SET_CONTROL_REG(ui2c, u8Ctrl);                                     /* Write controlbit to UI2C_CTL register */
00008c  6dc6              LDR      r6,[r0,#0x5c]
00008e  f026062e          BIC      r6,r6,#0x2e
000092  432e              ORRS     r6,r6,r5
000094  65c6              STR      r6,[r0,#0x5c]
000096  f1bc0f00          CMP      r12,#0                ;928
00009a  d1c6              BNE      |L27.42|
;;;985        }
;;;986    
;;;987        return (u8Err | u8Xfering);
00009c  4638              MOV      r0,r7
;;;988    }
00009e  e8bd8ff0          POP      {r4-r11,pc}
                  |L27.162|
0000a2  f8c08064          STR      r8,[r0,#0x64]         ;972
0000a6  2520              MOVS     r5,#0x20              ;973
0000a8  f04f0c00          MOV      r12,#0                ;974
0000ac  e7ee              B        |L27.140|
;;;989    
                          ENDP


                          AREA ||i.UI2C_WriteMultiBytes||, CODE, READONLY, ALIGN=1

                  UI2C_WriteMultiBytes PROC
;;;692    
;;;693    uint32_t UI2C_WriteMultiBytes(UI2C_T *ui2c, uint8_t u8SlaveAddr, uint8_t *data, uint32_t u32wLen)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;694    {
;;;695        uint8_t u8Xfering = 1U, u8Ctrl = 0U;
000004  2701              MOVS     r7,#1
000006  2400              MOVS     r4,#0
;;;696        uint32_t u32txLen = 0U;
;;;697    
;;;698        UI2C_START(ui2c);                                                       /* Send START */
000008  6dc6              LDR      r6,[r0,#0x5c]
00000a  4625              MOV      r5,r4                 ;696
00000c  f0260620          BIC      r6,r6,#0x20
000010  f0460608          ORR      r6,r6,#8
000014  65c6              STR      r6,[r0,#0x5c]
;;;699    
;;;700        while (u8Xfering)
;;;701        {
;;;702            while (!(UI2C_GET_PROT_STATUS(ui2c) & 0x3F00U));                     /* Wait UI2C new status occur */
;;;703    
;;;704            switch (UI2C_GET_PROT_STATUS(ui2c) & 0x3F00U)
000016  f44f7980          MOV      r9,#0x100
00001a  f44f5800          MOV      r8,#0x2000
00001e  f44f6a80          MOV      r10,#0x400
000022  f44f7b00          MOV      r11,#0x200
                  |L28.38|
000026  6e46              LDR      r6,[r0,#0x64]         ;702
000028  f4165f7c          TST      r6,#0x3f00            ;702
00002c  d0fb              BEQ      |L28.38|
00002e  6e46              LDR      r6,[r0,#0x64]
000030  46cc              MOV      r12,r9
000032  f406567c          AND      r6,r6,#0x3f00
000036  4566              CMP      r6,r12
000038  d00f              BEQ      |L28.90|
00003a  46dc              MOV      r12,r11
00003c  4566              CMP      r6,r12
00003e  d017              BEQ      |L28.112|
000040  46d4              MOV      r12,r10
000042  4566              CMP      r6,r12
000044  d011              BEQ      |L28.106|
000046  4546              CMP      r6,r8
000048  d10d              BNE      |L28.102|
;;;705            {
;;;706            case UI2C_PROTSTS_STARIF_Msk:
;;;707                UI2C_CLR_PROT_INT_FLAG(ui2c, UI2C_PROTSTS_STARIF_Msk);     /* Clear START INT Flag */
;;;708                UI2C_SET_DATA(ui2c, (u8SlaveAddr << 1U) | 0x00U);             /* Write SLA+W to Register UI2C_TXDAT */
;;;709                u8Ctrl = UI2C_CTL_PTRG;                                     /* Clear SI */
;;;710                break;
;;;711    
;;;712            case UI2C_PROTSTS_ACKIF_Msk:
;;;713                UI2C_CLR_PROT_INT_FLAG(ui2c, UI2C_PROTSTS_ACKIF_Msk);      /* Clear ACK INT Flag */
00004a  f8c08064          STR      r8,[r0,#0x64]
;;;714    
;;;715                if (u32txLen < u32wLen)
00004e  429d              CMP      r5,r3
000050  d209              BCS      |L28.102|
;;;716                    UI2C_SET_DATA(ui2c, data[u32txLen++]);                  /* Write data to UI2C_TXDAT */
000052  5d56              LDRB     r6,[r2,r5]
000054  6306              STR      r6,[r0,#0x30]
000056  1c6d              ADDS     r5,r5,#1
000058  e00e              B        |L28.120|
                  |L28.90|
00005a  f8c0c064          STR      r12,[r0,#0x64]        ;707
00005e  004c              LSLS     r4,r1,#1              ;708
000060  6304              STR      r4,[r0,#0x30]         ;708
000062  2420              MOVS     r4,#0x20              ;709
000064  e008              B        |L28.120|
                  |L28.102|
;;;717                else
;;;718                {
;;;719                    u8Ctrl = (UI2C_CTL_PTRG | UI2C_CTL_STO);                /* Clear SI and send STOP */
000066  2424              MOVS     r4,#0x24
000068  e006              B        |L28.120|
                  |L28.106|
;;;720                }
;;;721    
;;;722                break;
;;;723    
;;;724            case UI2C_PROTSTS_NACKIF_Msk:
;;;725                UI2C_CLR_PROT_INT_FLAG(ui2c, UI2C_PROTSTS_NACKIF_Msk);     /* Clear NACK INT Flag */
00006a  f8c0c064          STR      r12,[r0,#0x64]
;;;726                u8Ctrl = (UI2C_CTL_PTRG | UI2C_CTL_STO);                    /* Clear SI and send STOP */
;;;727                break;
00006e  e7fa              B        |L28.102|
                  |L28.112|
;;;728    
;;;729            case UI2C_PROTSTS_STORIF_Msk:
;;;730                UI2C_CLR_PROT_INT_FLAG(ui2c, UI2C_PROTSTS_STORIF_Msk);     /* Clear STOP INT Flag */
000070  f8c0c064          STR      r12,[r0,#0x64]
;;;731                u8Ctrl = UI2C_CTL_PTRG;                                     /* Clear SI */
000074  2420              MOVS     r4,#0x20
;;;732                u8Xfering = 0U;
000076  2700              MOVS     r7,#0
                  |L28.120|
;;;733                break;
;;;734    
;;;735            case UI2C_PROTSTS_ARBLOIF_Msk:                                  /* Arbitration Lost */
;;;736            default:                                                        /* Unknow status */
;;;737                u8Ctrl = (UI2C_CTL_PTRG | UI2C_CTL_STO);                    /* Clear SI and send STOP */
;;;738                break;
;;;739            }
;;;740    
;;;741            UI2C_SET_CONTROL_REG(ui2c, u8Ctrl);                                 /* Write controlbit to UI2C_CTL register */
000078  6dc6              LDR      r6,[r0,#0x5c]
00007a  f026062e          BIC      r6,r6,#0x2e
00007e  4326              ORRS     r6,r6,r4
000080  65c6              STR      r6,[r0,#0x5c]
000082  2f00              CMP      r7,#0
000084  d1cf              BNE      |L28.38|
;;;742        }
;;;743    
;;;744        return u32txLen;                                                        /* Return bytes length that have been transmitted */
000086  4628              MOV      r0,r5
;;;745    }
000088  e8bd8ff0          POP      {r4-r11,pc}
;;;746    
                          ENDP


                          AREA ||i.UI2C_WriteMultiBytesOneReg||, CODE, READONLY, ALIGN=1

                  UI2C_WriteMultiBytesOneReg PROC
;;;841    
;;;842    uint32_t UI2C_WriteMultiBytesOneReg(UI2C_T *ui2c, uint8_t u8SlaveAddr, uint8_t u8DataAddr, uint8_t *data, uint32_t u32wLen)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;843    {
;;;844        uint8_t u8Xfering = 1U, u8Ctrl = 0U;
000004  2400              MOVS     r4,#0
;;;845        uint32_t u32txLen = 0U;
;;;846        enum UI2C_MASTER_EVENT eEvent = MASTER_SEND_START;
;;;847    
;;;848        UI2C_START(ui2c);                                                       /* Send START */
000006  f8dd9024          LDR      r9,[sp,#0x24]
00000a  6dc6              LDR      r6,[r0,#0x5c]
00000c  f04f0c01          MOV      r12,#1                ;844
000010  4625              MOV      r5,r4                 ;845
000012  2712              MOVS     r7,#0x12              ;846
000014  f0260620          BIC      r6,r6,#0x20
000018  f0460608          ORR      r6,r6,#8
00001c  65c6              STR      r6,[r0,#0x5c]
;;;849    
;;;850        while (u8Xfering)
;;;851        {
;;;852            while (!(UI2C_GET_PROT_STATUS(ui2c) & 0x3F00U));                     /* Wait UI2C new status occur */
;;;853    
;;;854            switch (UI2C_GET_PROT_STATUS(ui2c) & 0x3F00U)
00001e  f44f7a80          MOV      r10,#0x100
000022  f44f5b00          MOV      r11,#0x2000
000026  f44f6e80          MOV      lr,#0x400
                  |L29.42|
00002a  6e46              LDR      r6,[r0,#0x64]         ;852
00002c  f4165f7c          TST      r6,#0x3f00            ;852
000030  d0fb              BEQ      |L29.42|
000032  6e46              LDR      r6,[r0,#0x64]
000034  46d0              MOV      r8,r10
000036  f406567c          AND      r6,r6,#0x3f00
00003a  4546              CMP      r6,r8
00003c  d013              BEQ      |L29.102|
00003e  f44f7800          MOV      r8,#0x200
000042  4546              CMP      r6,r8
000044  d01e              BEQ      |L29.132|
000046  46f0              MOV      r8,lr
000048  4546              CMP      r6,r8
00004a  d018              BEQ      |L29.126|
00004c  46d8              MOV      r8,r11
00004e  4546              CMP      r6,r8
000050  d113              BNE      |L29.122|
;;;855            {
;;;856            case UI2C_PROTSTS_STARIF_Msk:
;;;857                UI2C_CLR_PROT_INT_FLAG(ui2c, UI2C_PROTSTS_STARIF_Msk);     /* Clear START INT Flag */
;;;858                UI2C_SET_DATA(ui2c, (u8SlaveAddr << 1U) | 0x00U);             /* Write SLA+W to Register UI2C_TXDAT */
;;;859                eEvent = MASTER_SEND_ADDRESS;
;;;860                u8Ctrl = UI2C_CTL_PTRG;                                     /* Clear SI */
;;;861                break;
;;;862    
;;;863            case UI2C_PROTSTS_ACKIF_Msk:
;;;864                UI2C_CLR_PROT_INT_FLAG(ui2c, UI2C_PROTSTS_ACKIF_Msk);      /* Clear ACK INT Flag */
000052  f8c08064          STR      r8,[r0,#0x64]
;;;865    
;;;866                if (eEvent == MASTER_SEND_ADDRESS)
000056  2f0a              CMP      r7,#0xa
000058  d00c              BEQ      |L29.116|
;;;867                {
;;;868                    UI2C_SET_DATA(ui2c, u8DataAddr);                        /* Write data address to UI2C_TXDAT */
;;;869                    eEvent = MASTER_SEND_DATA;
;;;870                }
;;;871                else
;;;872                {
;;;873                    if (u32txLen < u32wLen)
00005a  454d              CMP      r5,r9
00005c  d20d              BCS      |L29.122|
;;;874                        UI2C_SET_DATA(ui2c, data[u32txLen++]);              /* Write data to UI2C_TXDAT */
00005e  5d5e              LDRB     r6,[r3,r5]
000060  6306              STR      r6,[r0,#0x30]
000062  1c6d              ADDS     r5,r5,#1
000064  e013              B        |L29.142|
                  |L29.102|
000066  f8c08064          STR      r8,[r0,#0x64]         ;857
00006a  004c              LSLS     r4,r1,#1              ;858
00006c  6304              STR      r4,[r0,#0x30]         ;858
00006e  270a              MOVS     r7,#0xa               ;859
000070  2420              MOVS     r4,#0x20              ;860
000072  e00c              B        |L29.142|
                  |L29.116|
000074  6302              STR      r2,[r0,#0x30]         ;868
000076  270e              MOVS     r7,#0xe               ;869
000078  e009              B        |L29.142|
                  |L29.122|
;;;875                    else
;;;876                    {
;;;877                        u8Ctrl = (UI2C_CTL_PTRG | UI2C_CTL_STO);            /* Clear SI and send STOP */
00007a  2424              MOVS     r4,#0x24
00007c  e007              B        |L29.142|
                  |L29.126|
;;;878                    }
;;;879                }
;;;880    
;;;881                break;
;;;882    
;;;883            case UI2C_PROTSTS_NACKIF_Msk:
;;;884                UI2C_CLR_PROT_INT_FLAG(ui2c, UI2C_PROTSTS_NACKIF_Msk);     /* Clear NACK INT Flag */
00007e  f8c08064          STR      r8,[r0,#0x64]
;;;885                u8Ctrl = (UI2C_CTL_PTRG | UI2C_CTL_STO);                    /* Clear SI and send STOP */
;;;886                break;
000082  e7fa              B        |L29.122|
                  |L29.132|
;;;887    
;;;888            case UI2C_PROTSTS_STORIF_Msk:
;;;889                UI2C_CLR_PROT_INT_FLAG(ui2c, UI2C_PROTSTS_STORIF_Msk);     /* Clear STOP INT Flag */
000084  f8c08064          STR      r8,[r0,#0x64]
;;;890                u8Ctrl = UI2C_CTL_PTRG;                                     /* Clear SI */
000088  2420              MOVS     r4,#0x20
;;;891                u8Xfering = 0U;
00008a  f04f0c00          MOV      r12,#0
                  |L29.142|
;;;892                break;
;;;893    
;;;894            case UI2C_PROTSTS_ARBLOIF_Msk:                                  /* Arbitration Lost */
;;;895            default:                                                        /* Unknow status */
;;;896                u8Ctrl = (UI2C_CTL_PTRG | UI2C_CTL_STO);                    /* Clear SI and send STOP */
;;;897                break;
;;;898            }
;;;899    
;;;900            UI2C_SET_CONTROL_REG(ui2c, u8Ctrl);                                 /* Write controlbit to UI2C_CTL register */
00008e  6dc6              LDR      r6,[r0,#0x5c]
000090  f026062e          BIC      r6,r6,#0x2e
000094  4326              ORRS     r6,r6,r4
000096  65c6              STR      r6,[r0,#0x5c]
000098  f1bc0f00          CMP      r12,#0                ;850
00009c  d1c5              BNE      |L29.42|
;;;901        }
;;;902    
;;;903        return u32txLen;                                                        /* Return bytes length that have been transmitted */
00009e  4628              MOV      r0,r5
;;;904    }
0000a0  e8bd8ff0          POP      {r4-r11,pc}
;;;905    
                          ENDP


                          AREA ||i.UI2C_WriteMultiBytesTwoRegs||, CODE, READONLY, ALIGN=1

                  UI2C_WriteMultiBytesTwoRegs PROC
;;;1005   
;;;1006   uint32_t UI2C_WriteMultiBytesTwoRegs(UI2C_T *ui2c, uint8_t u8SlaveAddr, uint16_t u16DataAddr, uint8_t *data, uint32_t u32wLen)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;1007   {
000004  4699              MOV      r9,r3
;;;1008       uint8_t u8Xfering = 1U, u8Addr = 1U, u8Ctrl = 0U;
000006  2300              MOVS     r3,#0
000008  f04f0c01          MOV      r12,#1
;;;1009       uint32_t u32txLen = 0U;
;;;1010       enum UI2C_MASTER_EVENT eEvent = MASTER_SEND_START;
;;;1011   
;;;1012       UI2C_START(ui2c);                                                           /* Send START */
00000c  f8dda024          LDR      r10,[sp,#0x24]
000010  6dc5              LDR      r5,[r0,#0x5c]
000012  4667              MOV      r7,r12                ;1008
000014  461c              MOV      r4,r3                 ;1009
000016  2612              MOVS     r6,#0x12              ;1010
000018  f0250520          BIC      r5,r5,#0x20
00001c  f0450508          ORR      r5,r5,#8
000020  65c5              STR      r5,[r0,#0x5c]
;;;1013   
;;;1014       while (u8Xfering)
;;;1015       {
;;;1016           while (!(UI2C_GET_PROT_STATUS(ui2c) & 0x3F00U));                     /* Wait UI2C new status occur */
;;;1017   
;;;1018           switch (UI2C_GET_PROT_STATUS(ui2c) & 0x3F00U)
000022  f44f7b80          MOV      r11,#0x100
000026  f44f5e00          MOV      lr,#0x2000
                  |L30.42|
00002a  6e45              LDR      r5,[r0,#0x64]         ;1016
00002c  f4155f7c          TST      r5,#0x3f00            ;1016
000030  d0fb              BEQ      |L30.42|
000032  6e45              LDR      r5,[r0,#0x64]
000034  46d8              MOV      r8,r11
000036  f405557c          AND      r5,r5,#0x3f00
00003a  4545              CMP      r5,r8
00003c  d011              BEQ      |L30.98|
00003e  f44f7800          MOV      r8,#0x200
000042  4545              CMP      r5,r8
000044  d029              BEQ      |L30.154|
000046  f44f6880          MOV      r8,#0x400
00004a  4545              CMP      r5,r8
00004c  d022              BEQ      |L30.148|
00004e  46f0              MOV      r8,lr
000050  4545              CMP      r5,r8
000052  d11d              BNE      |L30.144|
;;;1019           {
;;;1020           case UI2C_PROTSTS_STARIF_Msk:
;;;1021               UI2C_CLR_PROT_INT_FLAG(ui2c, UI2C_PROTSTS_STARIF_Msk);         /* Clear START INT Flag */
;;;1022               UI2C_SET_DATA(ui2c, (u8SlaveAddr << 1U) | 0x00U);                 /* Write SLA+W to Register UI2C_TXDAT */
;;;1023               eEvent = MASTER_SEND_ADDRESS;
;;;1024               u8Ctrl = UI2C_CTL_PTRG;                                         /* Clear SI */
;;;1025               break;
;;;1026   
;;;1027           case UI2C_PROTSTS_ACKIF_Msk:
;;;1028               UI2C_CLR_PROT_INT_FLAG(ui2c, UI2C_PROTSTS_ACKIF_Msk);          /* Clear ACK INT Flag */
000054  f8c08064          STR      r8,[r0,#0x64]
;;;1029   
;;;1030               if (eEvent == MASTER_SEND_ADDRESS)
000058  2e0a              CMP      r6,#0xa
00005a  d009              BEQ      |L30.112|
;;;1031               {
;;;1032                   UI2C_SET_DATA(ui2c, (uint8_t)((u16DataAddr & 0xFF00U) >> 8U));  /* Write Hi byte data address to UI2C_TXDAT */
;;;1033                   eEvent = MASTER_SEND_DATA;
;;;1034               }
;;;1035               else if (eEvent == MASTER_SEND_DATA)
00005c  2e0e              CMP      r6,#0xe
00005e  d00b              BEQ      |L30.120|
000060  e020              B        |L30.164|
                  |L30.98|
000062  f8c08064          STR      r8,[r0,#0x64]         ;1021
000066  004b              LSLS     r3,r1,#1              ;1022
000068  6303              STR      r3,[r0,#0x30]         ;1022
00006a  260a              MOVS     r6,#0xa               ;1023
00006c  2320              MOVS     r3,#0x20              ;1024
00006e  e019              B        |L30.164|
                  |L30.112|
000070  0a15              LSRS     r5,r2,#8              ;1032
000072  6305              STR      r5,[r0,#0x30]         ;1032
000074  260e              MOVS     r6,#0xe               ;1033
000076  e015              B        |L30.164|
                  |L30.120|
;;;1036               {
;;;1037                   if (u8Addr)
000078  b11f              CBZ      r7,|L30.130|
;;;1038                   {
;;;1039                       UI2C_SET_DATA(ui2c, (uint8_t)(u16DataAddr & 0xFFU));         /* Write Lo byte data address to UI2C_TXDAT */
00007a  b2d5              UXTB     r5,r2
00007c  6305              STR      r5,[r0,#0x30]
;;;1040                       u8Addr = 0;
00007e  2700              MOVS     r7,#0
000080  e010              B        |L30.164|
                  |L30.130|
;;;1041                   }
;;;1042                   else
;;;1043                   {
;;;1044                       if (u32txLen < u32wLen)
000082  4554              CMP      r4,r10
000084  d204              BCS      |L30.144|
;;;1045                       {
;;;1046                           UI2C_SET_DATA(ui2c, data[u32txLen++]);                  /* Write data to UI2C_TXDAT */
000086  f8195004          LDRB     r5,[r9,r4]
00008a  6305              STR      r5,[r0,#0x30]
00008c  1c64              ADDS     r4,r4,#1
00008e  e009              B        |L30.164|
                  |L30.144|
;;;1047                       }
;;;1048                       else
;;;1049                       {
;;;1050                           u8Ctrl = (UI2C_CTL_PTRG | UI2C_CTL_STO);                /* Clear SI and send STOP */
000090  2324              MOVS     r3,#0x24
000092  e007              B        |L30.164|
                  |L30.148|
;;;1051                       }
;;;1052                   }
;;;1053               }
;;;1054   
;;;1055               break;
;;;1056   
;;;1057           case UI2C_PROTSTS_NACKIF_Msk:
;;;1058               UI2C_CLR_PROT_INT_FLAG(ui2c, UI2C_PROTSTS_NACKIF_Msk);         /* Clear NACK INT Flag */
000094  f8c08064          STR      r8,[r0,#0x64]
;;;1059               u8Ctrl = (UI2C_CTL_PTRG | UI2C_CTL_STO);                        /* Clear SI and send STOP */
;;;1060               break;
000098  e7fa              B        |L30.144|
                  |L30.154|
;;;1061   
;;;1062           case UI2C_PROTSTS_STORIF_Msk:
;;;1063               UI2C_CLR_PROT_INT_FLAG(ui2c, UI2C_PROTSTS_STORIF_Msk);     /* Clear STOP INT Flag */
00009a  f8c08064          STR      r8,[r0,#0x64]
;;;1064               u8Ctrl = UI2C_CTL_PTRG;                                     /* Clear SI */
00009e  2320              MOVS     r3,#0x20
;;;1065               u8Xfering = 0U;
0000a0  f04f0c00          MOV      r12,#0
                  |L30.164|
;;;1066               break;
;;;1067   
;;;1068           case UI2C_PROTSTS_ARBLOIF_Msk:                                      /* Arbitration Lost */
;;;1069           default:                                                            /* Unknow status */
;;;1070               u8Ctrl = (UI2C_CTL_PTRG | UI2C_CTL_STO);                        /* Clear SI and send STOP */
;;;1071               break;
;;;1072           }
;;;1073   
;;;1074           UI2C_SET_CONTROL_REG(ui2c, u8Ctrl);                                     /* Write controlbit to UI2C_CTL register */
0000a4  6dc5              LDR      r5,[r0,#0x5c]
0000a6  f025052e          BIC      r5,r5,#0x2e
0000aa  431d              ORRS     r5,r5,r3
0000ac  65c5              STR      r5,[r0,#0x5c]
0000ae  f1bc0f00          CMP      r12,#0                ;1014
0000b2  d1ba              BNE      |L30.42|
;;;1075       }
;;;1076   
;;;1077       return u32txLen;                                                            /* Return bytes length that have been transmitted */
0000b4  4620              MOV      r0,r4
;;;1078   }
0000b6  e8bd8ff0          POP      {r4-r11,pc}
;;;1079   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\Library\\StdDriver\\src\\usci_i2c.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_usci_i2c_c_c16bae74____REV16|
#line 388 "..\\..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___10_usci_i2c_c_c16bae74____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_usci_i2c_c_c16bae74____REVSH|
#line 402
|__asm___10_usci_i2c_c_c16bae74____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___10_usci_i2c_c_c16bae74____RRX|
#line 587
|__asm___10_usci_i2c_c_c16bae74____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
