; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\uart.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\uart.d --cpu=Cortex-M4.fp.sp --apcs=interwork --diag_suppress=9931 -I..\..\..\..\Library\CMSIS\Include -I..\..\..\..\Library\Device\Nuvoton\M480\Include -I..\..\..\..\Library\StdDriver\inc -ID:\ARM\RV31\INC -ID:\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=531 --omf_browse=.\obj\uart.crf ..\..\..\..\Library\StdDriver\src\uart.c]
                          THUMB

                          AREA ||i.UART_ClearIntFlag||, CODE, READONLY, ALIGN=2

                  UART_ClearIntFlag PROC
;;;39     
;;;40     void UART_ClearIntFlag(UART_T* uart, uint32_t u32InterruptFlag)
000000  054a              LSLS     r2,r1,#21
;;;41     {
000002  d503              BPL      |L1.12|
;;;42     
;;;43         if(u32InterruptFlag & UART_INTSTS_RLSINT_Msk)   /* Clear Receive Line Status Interrupt */
;;;44         {
;;;45             uart->FIFOSTS = UART_FIFOSTS_BIF_Msk | UART_FIFOSTS_FEF_Msk | UART_FIFOSTS_PEF_Msk;
000004  2270              MOVS     r2,#0x70
000006  6182              STR      r2,[r0,#0x18]
;;;46             uart->FIFOSTS = UART_FIFOSTS_ADDRDETF_Msk;
000008  2208              MOVS     r2,#8
00000a  6182              STR      r2,[r0,#0x18]
                  |L1.12|
;;;47         }
;;;48     
;;;49         if(u32InterruptFlag & UART_INTSTS_MODEMINT_Msk)   /* Clear Modem Status Interrupt */
00000c  050a              LSLS     r2,r1,#20
00000e  d503              BPL      |L1.24|
;;;50         {
;;;51             uart->MODEMSTS |= UART_MODEMSTS_CTSDETF_Msk;
000010  6942              LDR      r2,[r0,#0x14]
000012  f0420201          ORR      r2,r2,#1
000016  6142              STR      r2,[r0,#0x14]
                  |L1.24|
;;;52         }
;;;53         else
;;;54         {
;;;55         }
;;;56     
;;;57         if(u32InterruptFlag & UART_INTSTS_BUFERRINT_Msk)   /* Clear Buffer Error Interrupt */
000018  048a              LSLS     r2,r1,#18
00001a  d501              BPL      |L1.32|
;;;58         {
;;;59             uart->FIFOSTS = UART_FIFOSTS_RXOVIF_Msk | UART_FIFOSTS_TXOVIF_Msk;
00001c  4a06              LDR      r2,|L1.56|
00001e  6182              STR      r2,[r0,#0x18]
                  |L1.32|
;;;60         }
;;;61     
;;;62         if(u32InterruptFlag & UART_INTSTS_WKINT_Msk)   /* Clear Wake-up Interrupt */
000020  044a              LSLS     r2,r1,#17
000022  d501              BPL      |L1.40|
;;;63         {
;;;64             uart->WKSTS = UART_WKSTS_CTSWKF_Msk  | UART_WKSTS_DATWKF_Msk  |
000024  221f              MOVS     r2,#0x1f
000026  6442              STR      r2,[r0,#0x44]
                  |L1.40|
;;;65                           UART_WKSTS_RFRTWKF_Msk |UART_WKSTS_RS485WKF_Msk |
;;;66                           UART_WKSTS_TOUTWKF_Msk;
;;;67         }
;;;68     
;;;69         if(u32InterruptFlag & UART_INTSTS_LININT_Msk)   /* Clear LIN Bus Interrupt */
000028  0409              LSLS     r1,r1,#16
00002a  d504              BPL      |L1.54|
;;;70         {
;;;71             uart->INTSTS = UART_INTSTS_LINIF_Msk;
00002c  2180              MOVS     r1,#0x80
00002e  61c1              STR      r1,[r0,#0x1c]
;;;72             uart->LINSTS = UART_LINSTS_BITEF_Msk    | UART_LINSTS_BRKDETF_Msk  |
000030  f240310f          MOV      r1,#0x30f
000034  6381              STR      r1,[r0,#0x38]
                  |L1.54|
;;;73                            UART_LINSTS_SLVSYNCF_Msk | UART_LINSTS_SLVIDPEF_Msk |
;;;74                            UART_LINSTS_SLVHEF_Msk   | UART_LINSTS_SLVHDETF_Msk ;
;;;75         }
;;;76     }
000036  4770              BX       lr
;;;77     
                          ENDP

                  |L1.56|
                          DCD      0x01000001

                          AREA ||i.UART_Close||, CODE, READONLY, ALIGN=1

                  UART_Close PROC
;;;87      */
;;;88     void UART_Close(UART_T* uart)
000000  2100              MOVS     r1,#0
;;;89     {
;;;90         uart->INTEN = 0ul;
000002  6041              STR      r1,[r0,#4]
;;;91     }
000004  4770              BX       lr
;;;92     
                          ENDP


                          AREA ||i.UART_DisableFlowCtrl||, CODE, READONLY, ALIGN=1

                  UART_DisableFlowCtrl PROC
;;;102     */
;;;103    void UART_DisableFlowCtrl(UART_T* uart)
000000  6841              LDR      r1,[r0,#4]
;;;104    {
;;;105        uart->INTEN &= ~(UART_INTEN_ATORTSEN_Msk | UART_INTEN_ATOCTSEN_Msk);
000002  f4215140          BIC      r1,r1,#0x3000
000006  6041              STR      r1,[r0,#4]
;;;106    }
000008  4770              BX       lr
;;;107    
                          ENDP


                          AREA ||i.UART_DisableInt||, CODE, READONLY, ALIGN=1

                  UART_DisableInt PROC
;;;126     */
;;;127    void UART_DisableInt(UART_T*  uart, uint32_t u32InterruptFlag)
000000  6842              LDR      r2,[r0,#4]
;;;128    {
;;;129        /* Disable UART specified interrupt */
;;;130        UART_DISABLE_INT(uart, u32InterruptFlag);
000002  438a              BICS     r2,r2,r1
000004  6042              STR      r2,[r0,#4]
;;;131    }
000006  4770              BX       lr
;;;132    
                          ENDP


                          AREA ||i.UART_EnableFlowCtrl||, CODE, READONLY, ALIGN=1

                  UART_EnableFlowCtrl PROC
;;;142     */
;;;143    void UART_EnableFlowCtrl(UART_T* uart)
000000  6901              LDR      r1,[r0,#0x10]
;;;144    {
;;;145        /* Set RTS pin output is low level active */
;;;146        uart->MODEM |= UART_MODEM_RTSACTLV_Msk;
000002  f4417100          ORR      r1,r1,#0x200
000006  6101              STR      r1,[r0,#0x10]
;;;147    
;;;148        /* Set CTS pin input is low level active */
;;;149        uart->MODEMSTS |= UART_MODEMSTS_CTSACTLV_Msk;
000008  6941              LDR      r1,[r0,#0x14]
00000a  f4417180          ORR      r1,r1,#0x100
00000e  6141              STR      r1,[r0,#0x14]
;;;150    
;;;151        /* Set RTS and CTS auto flow control enable */
;;;152        uart->INTEN |= UART_INTEN_ATORTSEN_Msk | UART_INTEN_ATOCTSEN_Msk;
000010  6841              LDR      r1,[r0,#4]
000012  f4415140          ORR      r1,r1,#0x3000
000016  6041              STR      r1,[r0,#4]
;;;153    }
000018  4770              BX       lr
;;;154    
                          ENDP


                          AREA ||i.UART_EnableInt||, CODE, READONLY, ALIGN=1

                  UART_EnableInt PROC
;;;173     */
;;;174    void UART_EnableInt(UART_T*  uart, uint32_t u32InterruptFlag)
000000  6842              LDR      r2,[r0,#4]
;;;175    {
;;;176        /* Enable UART specified interrupt */
;;;177        UART_ENABLE_INT(uart, u32InterruptFlag);
000002  430a              ORRS     r2,r2,r1
000004  6042              STR      r2,[r0,#4]
;;;178    }
000006  4770              BX       lr
;;;179    
                          ENDP


                          AREA ||i.UART_Open||, CODE, READONLY, ALIGN=2

                  UART_Open PROC
;;;190     */
;;;191    void UART_Open(UART_T* uart, uint32_t u32baudrate)
000000  e92d41ff          PUSH     {r0-r8,lr}
;;;192    {
000004  4604              MOV      r4,r0
;;;193        uint32_t u32UartClkSrcSel=0ul, u32UartClkDivNum=0ul;
;;;194        uint32_t u32ClkTbl[4] = {__HXT, 0ul, __LXT, __HIRC};
000006  483c              LDR      r0,|L7.248|
000008  460f              MOV      r7,r1                 ;192
00000a  2500              MOVS     r5,#0                 ;193
00000c  c80f              LDM      r0,{r0-r3}
00000e  e88d000f          STM      sp,{r0-r3}
;;;195        uint32_t u32Baud_Div = 0ul;
;;;196    
;;;197    
;;;198        if(uart==(UART_T*)UART0)
000012  493a              LDR      r1,|L7.252|
000014  462e              MOV      r6,r5                 ;193
;;;199        {
;;;200            /* Get UART clock source selection */
;;;201            u32UartClkSrcSel = ((uint32_t)(CLK->CLKSEL1 & CLK_CLKSEL1_UART0SEL_Msk)) >> CLK_CLKSEL1_UART0SEL_Pos;
000016  f04f4080          MOV      r0,#0x40000000
00001a  428c              CMP      r4,r1                 ;198
00001c  d106              BNE      |L7.44|
00001e  f8d01214          LDR      r1,[r0,#0x214]
;;;202            /* Get UART clock divider number */
;;;203            u32UartClkDivNum = (CLK->CLKDIV0 & CLK_CLKDIV0_UART0DIV_Msk) >> CLK_CLKDIV0_UART0DIV_Pos;
000022  f8d00220          LDR      r0,[r0,#0x220]
000026  f3c16501          UBFX     r5,r1,#24,#2          ;201
00002a  e02a              B        |L7.130|
                  |L7.44|
;;;204        }
;;;205        else if(uart==(UART_T*)UART1)
00002c  4934              LDR      r1,|L7.256|
00002e  428c              CMP      r4,r1
000030  d106              BNE      |L7.64|
;;;206        {
;;;207            /* Get UART clock source selection */
;;;208            u32UartClkSrcSel = (CLK->CLKSEL1 & CLK_CLKSEL1_UART1SEL_Msk) >> CLK_CLKSEL1_UART1SEL_Pos;
000032  f8d01214          LDR      r1,[r0,#0x214]
;;;209            /* Get UART clock divider number */
;;;210            u32UartClkDivNum = (CLK->CLKDIV0 & CLK_CLKDIV0_UART1DIV_Msk) >> CLK_CLKDIV0_UART1DIV_Pos;
000036  f8d00220          LDR      r0,[r0,#0x220]
00003a  f3c16581          UBFX     r5,r1,#26,#2          ;208
00003e  e02b              B        |L7.152|
                  |L7.64|
;;;211        }
;;;212        else if(uart==(UART_T*)UART2)
000040  4930              LDR      r1,|L7.260|
000042  428c              CMP      r4,r1
000044  d108              BNE      |L7.88|
;;;213        {
;;;214            /* Get UART clock source selection */
;;;215            u32UartClkSrcSel = (CLK->CLKSEL3 & CLK_CLKSEL3_UART2SEL_Msk) >> CLK_CLKSEL3_UART2SEL_Pos;
000046  f8d0121c          LDR      r1,[r0,#0x21c]
;;;216            /* Get UART clock divider number */
;;;217            u32UartClkDivNum = (CLK->CLKDIV4 & CLK_CLKDIV4_UART2DIV_Msk) >> CLK_CLKDIV4_UART2DIV_Pos;
00004a  f8d00230          LDR      r0,[r0,#0x230]
00004e  f3c16501          UBFX     r5,r1,#24,#2          ;215
000052  f000060f          AND      r6,r0,#0xf
000056  e021              B        |L7.156|
                  |L7.88|
;;;218        }
;;;219        else if(uart==(UART_T*)UART3)
000058  492b              LDR      r1,|L7.264|
00005a  428c              CMP      r4,r1
00005c  d108              BNE      |L7.112|
;;;220        {
;;;221            /* Get UART clock source selection */
;;;222            u32UartClkSrcSel = (CLK->CLKSEL3 & CLK_CLKSEL3_UART3SEL_Msk) >> CLK_CLKSEL3_UART3SEL_Pos;
00005e  f8d0121c          LDR      r1,[r0,#0x21c]
;;;223            /* Get UART clock divider number */
;;;224            u32UartClkDivNum = (CLK->CLKDIV4 & CLK_CLKDIV4_UART3DIV_Msk) >> CLK_CLKDIV4_UART3DIV_Pos;
000062  f8d00230          LDR      r0,[r0,#0x230]
000066  f3c16581          UBFX     r5,r1,#26,#2          ;222
00006a  f3c01603          UBFX     r6,r0,#4,#4
00006e  e015              B        |L7.156|
                  |L7.112|
;;;225        }
;;;226        else if(uart==(UART_T*)UART4)
000070  4926              LDR      r1,|L7.268|
000072  428c              CMP      r4,r1
000074  d108              BNE      |L7.136|
;;;227        {
;;;228            /* Get UART clock source selection */
;;;229            u32UartClkSrcSel = (CLK->CLKSEL3 & CLK_CLKSEL3_UART4SEL_Msk) >> CLK_CLKSEL3_UART4SEL_Pos;
000076  f8d0121c          LDR      r1,[r0,#0x21c]
;;;230            /* Get UART clock divider number */
;;;231            u32UartClkDivNum = (CLK->CLKDIV4 & CLK_CLKDIV4_UART4DIV_Msk) >> CLK_CLKDIV4_UART4DIV_Pos;
00007a  f8d00230          LDR      r0,[r0,#0x230]
00007e  f3c17501          UBFX     r5,r1,#28,#2          ;229
                  |L7.130|
000082  f3c02603          UBFX     r6,r0,#8,#4
000086  e009              B        |L7.156|
                  |L7.136|
;;;232        }
;;;233        else if(uart==(UART_T*)UART5)
000088  4921              LDR      r1,|L7.272|
00008a  428c              CMP      r4,r1
00008c  d106              BNE      |L7.156|
;;;234        {
;;;235            /* Get UART clock source selection */
;;;236            u32UartClkSrcSel = (CLK->CLKSEL3 & CLK_CLKSEL3_UART5SEL_Msk) >> CLK_CLKSEL3_UART5SEL_Pos;
00008e  f8d0121c          LDR      r1,[r0,#0x21c]
;;;237            /* Get UART clock divider number */
;;;238            u32UartClkDivNum = (CLK->CLKDIV4 & CLK_CLKDIV4_UART5DIV_Msk) >> CLK_CLKDIV4_UART5DIV_Pos;
000092  f8d00230          LDR      r0,[r0,#0x230]
000096  0f8d              LSRS     r5,r1,#30             ;236
                  |L7.152|
000098  f3c03603          UBFX     r6,r0,#12,#4
                  |L7.156|
;;;239        }
;;;240    
;;;241        /* Select UART function */
;;;242        uart->FUNCSEL = UART_FUNCSEL_UART;
00009c  2000              MOVS     r0,#0
00009e  6320              STR      r0,[r4,#0x30]
;;;243    
;;;244        /* Set UART line configuration */
;;;245        uart->LINE = UART_WORD_LEN_8 | UART_PARITY_NONE | UART_STOP_BIT_1;
0000a0  2003              MOVS     r0,#3
0000a2  60e0              STR      r0,[r4,#0xc]
;;;246    
;;;247        /* Set UART Rx and RTS trigger level */
;;;248        uart->FIFO &= ~(UART_FIFO_RFITL_Msk | UART_FIFO_RTSTRGLV_Msk);
0000a4  68a0              LDR      r0,[r4,#8]
0000a6  491b              LDR      r1,|L7.276|
0000a8  4008              ANDS     r0,r0,r1
0000aa  60a0              STR      r0,[r4,#8]
0000ac  46e8              MOV      r8,sp                 ;194
;;;249    
;;;250        /* Get PLL clock frequency if UART clock source selection is PLL */
;;;251        if(u32UartClkSrcSel == 1ul)
0000ae  2d01              CMP      r5,#1
0000b0  d102              BNE      |L7.184|
;;;252        {
;;;253            u32ClkTbl[u32UartClkSrcSel] = CLK_GetPLLClockFreq();
0000b2  f7fffffe          BL       CLK_GetPLLClockFreq
0000b6  9001              STR      r0,[sp,#4]
                  |L7.184|
;;;254        }
;;;255    
;;;256        /* Set UART baud rate */
;;;257        if(u32baudrate != 0ul)
0000b8  2f00              CMP      r7,#0
0000ba  d01a              BEQ      |L7.242|
;;;258        {
;;;259            u32Baud_Div = UART_BAUD_MODE2_DIVIDER((u32ClkTbl[u32UartClkSrcSel]) / (u32UartClkDivNum + 1ul), u32baudrate);
0000bc  f8581025          LDR      r1,[r8,r5,LSL #2]
0000c0  1c76              ADDS     r6,r6,#1
0000c2  fbb1f0f6          UDIV     r0,r1,r6
0000c6  eb000057          ADD      r0,r0,r7,LSR #1
0000ca  fbb0f0f7          UDIV     r0,r0,r7
0000ce  1e80              SUBS     r0,r0,#2
;;;260    
;;;261            if(u32Baud_Div > 0xFFFFul)
0000d0  f5b03f80          CMP      r0,#0x10000
0000d4  d30a              BCC      |L7.236|
;;;262            {
;;;263                uart->BAUD = (UART_BAUD_MODE0 | UART_BAUD_MODE0_DIVIDER((u32ClkTbl[u32UartClkSrcSel]) / (u32UartClkDivNum + 1ul), u32baudrate));
0000d6  fbb1f0f6          UDIV     r0,r1,r6
0000da  eb0000c7          ADD      r0,r0,r7,LSL #3
0000de  fbb0f0f7          UDIV     r0,r0,r7
0000e2  f06f0101          MVN      r1,#1
0000e6  eb011010          ADD      r0,r1,r0,LSR #4
0000ea  e001              B        |L7.240|
                  |L7.236|
;;;264            }
;;;265            else
;;;266            {
;;;267                uart->BAUD = (UART_BAUD_MODE2 | u32Baud_Div);
0000ec  f0405040          ORR      r0,r0,#0x30000000
                  |L7.240|
0000f0  6260              STR      r0,[r4,#0x24]
                  |L7.242|
;;;268            }
;;;269        }
;;;270    }
0000f2  e8bd81ff          POP      {r0-r8,pc}
;;;271    
                          ENDP

0000f6  0000              DCW      0x0000
                  |L7.248|
                          DCD      ||.constdata||
                  |L7.252|
                          DCD      0x40070000
                  |L7.256|
                          DCD      0x40071000
                  |L7.260|
                          DCD      0x40072000
                  |L7.264|
                          DCD      0x40073000
                  |L7.268|
                          DCD      0x40074000
                  |L7.272|
                          DCD      0x40075000
                  |L7.276|
                          DCD      0xfff0ff0f

                          AREA ||i.UART_Read||, CODE, READONLY, ALIGN=1

                  UART_Read PROC
;;;283     */
;;;284    uint32_t UART_Read(UART_T* uart, uint8_t pu8RxBuf[], uint32_t u32ReadBytes)
000000  b5f0              PUSH     {r4-r7,lr}
;;;285    {
000002  4604              MOV      r4,r0
;;;286        uint32_t  u32Count, u32delayno;
;;;287        uint32_t  u32Exit = 0ul;
000004  2600              MOVS     r6,#0
;;;288    
;;;289        for(u32Count = 0ul; u32Count < u32ReadBytes; u32Count++)
000006  4630              MOV      r0,r6
;;;290        {
;;;291            u32delayno = 0ul;
;;;292    
;;;293            while(uart->FIFOSTS & UART_FIFOSTS_RXEMPTY_Msk)   /* Check RX empty => failed */
;;;294            {
;;;295                u32delayno++;
;;;296                if(u32delayno >= 0x40000000ul)
000008  f04f4580          MOV      r5,#0x40000000
00000c  e00c              B        |L8.40|
                  |L8.14|
00000e  2300              MOVS     r3,#0                 ;291
000010  e002              B        |L8.24|
                  |L8.18|
000012  1c5b              ADDS     r3,r3,#1              ;293
000014  42ab              CMP      r3,r5
000016  d209              BCS      |L8.44|
                  |L8.24|
000018  69a7              LDR      r7,[r4,#0x18]         ;293
00001a  047f              LSLS     r7,r7,#17             ;293
00001c  d4f9              BMI      |L8.18|
;;;297                {
;;;298                    u32Exit = 1ul;
;;;299                    break;
;;;300                }
;;;301                else
;;;302                {
;;;303                }
;;;304            }
;;;305    
;;;306            if(u32Exit == 1ul)
00001e  2e00              CMP      r6,#0
000020  d104              BNE      |L8.44|
;;;307            {
;;;308                break;
;;;309            }
;;;310            else
;;;311            {
;;;312                pu8RxBuf[u32Count] = (uint8_t)uart->DAT; /* Get Data from UART RX  */
000022  6823              LDR      r3,[r4,#0]
000024  540b              STRB     r3,[r1,r0]
000026  1c40              ADDS     r0,r0,#1
                  |L8.40|
000028  4290              CMP      r0,r2                 ;289
00002a  d3f0              BCC      |L8.14|
                  |L8.44|
;;;313            }
;;;314        }
;;;315    
;;;316        return u32Count;
;;;317    
;;;318    }
00002c  bdf0              POP      {r4-r7,pc}
;;;319    
                          ENDP


                          AREA ||i.UART_SelectIrDAMode||, CODE, READONLY, ALIGN=2

                  UART_SelectIrDAMode PROC
;;;458     */
;;;459    void UART_SelectIrDAMode(UART_T* uart, uint32_t u32Buadrate, uint32_t u32Direction)
000000  e92d47ff          PUSH     {r0-r10,lr}
;;;460    {
000004  4604              MOV      r4,r0
;;;461        uint32_t u32UartClkSrcSel=0ul, u32UartClkDivNum=0ul;
;;;462        uint32_t u32ClkTbl[4ul] = {__HXT, 0ul, __LXT, __HIRC};
000006  483c              LDR      r0,|L9.248|
000008  4691              MOV      r9,r2                 ;460
00000a  460f              MOV      r7,r1                 ;460
00000c  c80f              LDM      r0,{r0-r3}
00000e  e88d000f          STM      sp,{r0-r3}
000012  2500              MOVS     r5,#0                 ;461
;;;463        uint32_t u32Baud_Div;
;;;464    
;;;465        /* Select IrDA function mode */
;;;466        uart->FUNCSEL = UART_FUNCSEL_IrDA;
000014  2002              MOVS     r0,#2
000016  462e              MOV      r6,r5                 ;461
000018  6320              STR      r0,[r4,#0x30]
;;;467    
;;;468    
;;;469        if(uart==UART0)
00001a  4938              LDR      r1,|L9.252|
;;;470        {
;;;471            /* Get UART clock source selection */
;;;472            u32UartClkSrcSel = (CLK->CLKSEL1 & CLK_CLKSEL1_UART0SEL_Msk) >> CLK_CLKSEL1_UART0SEL_Pos;
00001c  0740              LSLS     r0,r0,#29
00001e  46e8              MOV      r8,sp                 ;462
000020  428c              CMP      r4,r1                 ;469
000022  d106              BNE      |L9.50|
000024  f8d01214          LDR      r1,[r0,#0x214]
;;;473            /* Get UART clock divider number */
;;;474            u32UartClkDivNum = (CLK->CLKDIV0 & CLK_CLKDIV0_UART0DIV_Msk) >> CLK_CLKDIV0_UART0DIV_Pos;
000028  f8d00220          LDR      r0,[r0,#0x220]
00002c  f3c16501          UBFX     r5,r1,#24,#2          ;472
000030  e02a              B        |L9.136|
                  |L9.50|
;;;475        }
;;;476        else if(uart==UART1)
000032  4933              LDR      r1,|L9.256|
000034  428c              CMP      r4,r1
000036  d106              BNE      |L9.70|
;;;477        {
;;;478            /* Get UART clock source selection */
;;;479            u32UartClkSrcSel = (CLK->CLKSEL1 & CLK_CLKSEL1_UART1SEL_Msk) >> CLK_CLKSEL1_UART1SEL_Pos;
000038  f8d01214          LDR      r1,[r0,#0x214]
;;;480            /* Get UART clock divider number */
;;;481            u32UartClkDivNum = (CLK->CLKDIV0 & CLK_CLKDIV0_UART1DIV_Msk) >> CLK_CLKDIV0_UART1DIV_Pos;
00003c  f8d00220          LDR      r0,[r0,#0x220]
000040  f3c16581          UBFX     r5,r1,#26,#2          ;479
000044  e02b              B        |L9.158|
                  |L9.70|
;;;482        }
;;;483        else if(uart==UART2)
000046  492f              LDR      r1,|L9.260|
000048  428c              CMP      r4,r1
00004a  d108              BNE      |L9.94|
;;;484        {
;;;485            /* Get UART clock source selection */
;;;486            u32UartClkSrcSel = (CLK->CLKSEL3 & CLK_CLKSEL3_UART2SEL_Msk) >> CLK_CLKSEL3_UART2SEL_Pos;
00004c  f8d0121c          LDR      r1,[r0,#0x21c]
;;;487            /* Get UART clock divider number */
;;;488            u32UartClkDivNum = (CLK->CLKDIV4 & CLK_CLKDIV4_UART2DIV_Msk) >> CLK_CLKDIV4_UART2DIV_Pos;
000050  f8d00230          LDR      r0,[r0,#0x230]
000054  f3c16501          UBFX     r5,r1,#24,#2          ;486
000058  f000060f          AND      r6,r0,#0xf
00005c  e021              B        |L9.162|
                  |L9.94|
;;;489        }
;;;490        else if(uart==UART3)
00005e  492a              LDR      r1,|L9.264|
000060  428c              CMP      r4,r1
000062  d108              BNE      |L9.118|
;;;491        {
;;;492            /* Get UART clock source selection */
;;;493            u32UartClkSrcSel = (CLK->CLKSEL3 & CLK_CLKSEL3_UART3SEL_Msk) >> CLK_CLKSEL3_UART3SEL_Pos;
000064  f8d0121c          LDR      r1,[r0,#0x21c]
;;;494            /* Get UART clock divider number */
;;;495            u32UartClkDivNum = (CLK->CLKDIV4 & CLK_CLKDIV4_UART3DIV_Msk) >> CLK_CLKDIV4_UART3DIV_Pos;
000068  f8d00230          LDR      r0,[r0,#0x230]
00006c  f3c16581          UBFX     r5,r1,#26,#2          ;493
000070  f3c01603          UBFX     r6,r0,#4,#4
000074  e015              B        |L9.162|
                  |L9.118|
;;;496        }
;;;497        else if(uart==UART4)
000076  4925              LDR      r1,|L9.268|
000078  428c              CMP      r4,r1
00007a  d108              BNE      |L9.142|
;;;498        {
;;;499            /* Get UART clock source selection */
;;;500            u32UartClkSrcSel = (CLK->CLKSEL3 & CLK_CLKSEL3_UART4SEL_Msk) >> CLK_CLKSEL3_UART4SEL_Pos;
00007c  f8d0121c          LDR      r1,[r0,#0x21c]
;;;501            /* Get UART clock divider number */
;;;502            u32UartClkDivNum = (CLK->CLKDIV4 & CLK_CLKDIV4_UART4DIV_Msk) >> CLK_CLKDIV4_UART4DIV_Pos;
000080  f8d00230          LDR      r0,[r0,#0x230]
000084  f3c17501          UBFX     r5,r1,#28,#2          ;500
                  |L9.136|
000088  f3c02603          UBFX     r6,r0,#8,#4
00008c  e009              B        |L9.162|
                  |L9.142|
;;;503        }
;;;504        else if(uart==UART5)
00008e  4920              LDR      r1,|L9.272|
000090  428c              CMP      r4,r1
000092  d10b              BNE      |L9.172|
;;;505        {
;;;506            /* Get UART clock source selection */
;;;507            u32UartClkSrcSel = (CLK->CLKSEL3 & CLK_CLKSEL3_UART5SEL_Msk) >> CLK_CLKSEL3_UART5SEL_Pos;
000094  f8d0121c          LDR      r1,[r0,#0x21c]
;;;508            /* Get UART clock divider number */
;;;509            u32UartClkDivNum = (CLK->CLKDIV4 & CLK_CLKDIV4_UART5DIV_Msk) >> CLK_CLKDIV4_UART5DIV_Pos;
000098  f8d00230          LDR      r0,[r0,#0x230]
00009c  0f8d              LSRS     r5,r1,#30             ;507
                  |L9.158|
00009e  f3c03603          UBFX     r6,r0,#12,#4
                  |L9.162|
;;;510        }
;;;511    
;;;512    
;;;513        /* Get PLL clock frequency if UART clock source selection is PLL */
;;;514        if(u32UartClkSrcSel == 1ul)
0000a2  2d01              CMP      r5,#1
0000a4  d102              BNE      |L9.172|
;;;515        {
;;;516            u32ClkTbl[u32UartClkSrcSel] = CLK_GetPLLClockFreq();
0000a6  f7fffffe          BL       CLK_GetPLLClockFreq
0000aa  9001              STR      r0,[sp,#4]
                  |L9.172|
;;;517        }
;;;518        else
;;;519        {
;;;520        }
;;;521    
;;;522        /* Set UART IrDA baud rate in mode 0 */
;;;523        if(u32Buadrate != 0ul)
0000ac  b187              CBZ      r7,|L9.208|
;;;524        {
;;;525            u32Baud_Div = UART_BAUD_MODE0_DIVIDER((u32ClkTbl[u32UartClkSrcSel]) / (u32UartClkDivNum + 1ul), u32Buadrate);
0000ae  f8580025          LDR      r0,[r8,r5,LSL #2]
0000b2  1c76              ADDS     r6,r6,#1
0000b4  fbb0f0f6          UDIV     r0,r0,r6
0000b8  eb0000c7          ADD      r0,r0,r7,LSL #3
0000bc  fbb0f0f7          UDIV     r0,r0,r7
0000c0  f06f0101          MVN      r1,#1
0000c4  eb011010          ADD      r0,r1,r0,LSR #4
;;;526    
;;;527            if(u32Baud_Div < 0xFFFFul)
0000c8  0c09              LSRS     r1,r1,#16
0000ca  4288              CMP      r0,r1
0000cc  d200              BCS      |L9.208|
;;;528            {
;;;529                uart->BAUD = (UART_BAUD_MODE0 | u32Baud_Div);
0000ce  6260              STR      r0,[r4,#0x24]
                  |L9.208|
;;;530            }
;;;531            else
;;;532            {
;;;533            }
;;;534        }
;;;535    
;;;536        /* Configure IrDA relative settings */
;;;537        if(u32Direction == UART_IRDA_RXEN)
;;;538        {
;;;539            uart->IRDA |= UART_IRDA_RXINV_Msk;     /*Rx signal is inverse*/
;;;540            uart->IRDA &= ~UART_IRDA_TXEN_Msk;
;;;541        }
;;;542        else
;;;543        {
;;;544            uart->IRDA &= ~UART_IRDA_TXINV_Msk;    /*Tx signal is not inverse*/
0000d0  6aa0              LDR      r0,[r4,#0x28]
0000d2  f1b90f00          CMP      r9,#0                 ;537
0000d6  d008              BEQ      |L9.234|
0000d8  f0200020          BIC      r0,r0,#0x20
0000dc  62a0              STR      r0,[r4,#0x28]
;;;545            uart->IRDA |= UART_IRDA_TXEN_Msk;
0000de  6aa0              LDR      r0,[r4,#0x28]
0000e0  f0400002          ORR      r0,r0,#2
                  |L9.228|
0000e4  62a0              STR      r0,[r4,#0x28]         ;540
;;;546        }
;;;547    
;;;548    }
0000e6  e8bd87ff          POP      {r0-r10,pc}
                  |L9.234|
0000ea  f0400040          ORR      r0,r0,#0x40           ;539
0000ee  62a0              STR      r0,[r4,#0x28]         ;539
0000f0  6aa0              LDR      r0,[r4,#0x28]         ;540
0000f2  f0200002          BIC      r0,r0,#2              ;540
0000f6  e7f5              B        |L9.228|
;;;549    
                          ENDP

                  |L9.248|
                          DCD      ||.constdata||+0x20
                  |L9.252|
                          DCD      0x40070000
                  |L9.256|
                          DCD      0x40071000
                  |L9.260|
                          DCD      0x40072000
                  |L9.264|
                          DCD      0x40073000
                  |L9.268|
                          DCD      0x40074000
                  |L9.272|
                          DCD      0x40075000

                          AREA ||i.UART_SelectLINMode||, CODE, READONLY, ALIGN=1

                  UART_SelectLINMode PROC
;;;588     */
;;;589    void UART_SelectLINMode(UART_T* uart, uint32_t u32Mode, uint32_t u32BreakLength)
000000  2301              MOVS     r3,#1
;;;590    {
;;;591        /* Select LIN function mode */
;;;592        uart->FUNCSEL = UART_FUNCSEL_LIN;
000002  6303              STR      r3,[r0,#0x30]
;;;593    
;;;594        /* Select LIN function setting : Tx enable, Rx enable and break field length */
;;;595        uart->ALTCTL &= ~(UART_ALTCTL_LINTXEN_Msk | UART_ALTCTL_LINRXEN_Msk | UART_ALTCTL_BRKFL_Msk);
000004  6ac3              LDR      r3,[r0,#0x2c]
000006  f02303cf          BIC      r3,r3,#0xcf
00000a  62c3              STR      r3,[r0,#0x2c]
;;;596        uart->ALTCTL |= (u32Mode | (u32BreakLength << UART_ALTCTL_BRKFL_Pos));
00000c  6ac3              LDR      r3,[r0,#0x2c]
00000e  4311              ORRS     r1,r1,r2
000010  430b              ORRS     r3,r3,r1
000012  62c3              STR      r3,[r0,#0x2c]
;;;597    }
000014  4770              BX       lr
;;;598    
                          ENDP


                          AREA ||i.UART_SelectRS485Mode||, CODE, READONLY, ALIGN=2

                  UART_SelectRS485Mode PROC
;;;564     */
;;;565    void UART_SelectRS485Mode(UART_T* uart, uint32_t u32Mode, uint32_t u32Addr)
000000  b510              PUSH     {r4,lr}
;;;566    {
;;;567        /* Select UART RS485 function mode */
;;;568        uart->FUNCSEL = UART_FUNCSEL_RS485;
000002  2303              MOVS     r3,#3
000004  6303              STR      r3,[r0,#0x30]
;;;569    
;;;570        /* Set RS585 configuration */
;;;571        uart->ALTCTL &= ~(UART_ALTCTL_RS485NMM_Msk | UART_ALTCTL_RS485AUD_Msk | UART_ALTCTL_RS485AAD_Msk | UART_ALTCTL_ADDRMV_Msk);
000006  6ac3              LDR      r3,[r0,#0x2c]
000008  4c04              LDR      r4,|L11.28|
00000a  4023              ANDS     r3,r3,r4
00000c  62c3              STR      r3,[r0,#0x2c]
;;;572        uart->ALTCTL |= (u32Mode | (u32Addr << UART_ALTCTL_ADDRMV_Pos));
00000e  6ac3              LDR      r3,[r0,#0x2c]
000010  ea416102          ORR      r1,r1,r2,LSL #24
000014  430b              ORRS     r3,r3,r1
000016  62c3              STR      r3,[r0,#0x2c]
;;;573    }
000018  bd10              POP      {r4,pc}
;;;574    
                          ENDP

00001a  0000              DCW      0x0000
                  |L11.28|
                          DCD      0x00fff8ff

                          AREA ||i.UART_SetLineConfig||, CODE, READONLY, ALIGN=2

                  UART_SetLineConfig PROC
;;;346     */
;;;347    void UART_SetLineConfig(UART_T* uart, uint32_t u32baudrate, uint32_t u32data_width, uint32_t u32parity, uint32_t  u32stop_bits)
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;348    {
000004  4604              MOV      r4,r0
;;;349        uint32_t u32UartClkSrcSel=0ul, u32UartClkDivNum=0ul;
;;;350        uint32_t u32ClkTbl[4ul] = {__HXT, 0ul, __LXT, __HIRC};
000006  483c              LDR      r0,|L12.248|
000008  469a              MOV      r10,r3                ;348
00000a  4691              MOV      r9,r2                 ;348
00000c  460f              MOV      r7,r1                 ;348
00000e  c80f              LDM      r0,{r0-r3}
000010  f8ddb038          LDR      r11,[sp,#0x38]
000014  e88d000f          STM      sp,{r0-r3}
000018  2500              MOVS     r5,#0                 ;349
;;;351        uint32_t u32Baud_Div = 0ul;
;;;352    
;;;353    
;;;354        if(uart==(UART_T*)UART0)
00001a  4938              LDR      r1,|L12.252|
00001c  462e              MOV      r6,r5                 ;349
;;;355        {
;;;356            /* Get UART clock source selection */
;;;357            u32UartClkSrcSel = (CLK->CLKSEL1 & CLK_CLKSEL1_UART0SEL_Msk) >> CLK_CLKSEL1_UART0SEL_Pos;
00001e  f04f4080          MOV      r0,#0x40000000
000022  46e8              MOV      r8,sp                 ;350
000024  428c              CMP      r4,r1                 ;354
000026  d106              BNE      |L12.54|
000028  f8d01214          LDR      r1,[r0,#0x214]
;;;358            /* Get UART clock divider number */
;;;359            u32UartClkDivNum = (CLK->CLKDIV0 & CLK_CLKDIV0_UART0DIV_Msk) >> CLK_CLKDIV0_UART0DIV_Pos;
00002c  f8d00220          LDR      r0,[r0,#0x220]
000030  f3c16501          UBFX     r5,r1,#24,#2          ;357
000034  e02a              B        |L12.140|
                  |L12.54|
;;;360        }
;;;361        else if(uart==(UART_T*)UART1)
000036  4932              LDR      r1,|L12.256|
000038  428c              CMP      r4,r1
00003a  d106              BNE      |L12.74|
;;;362        {
;;;363            /* Get UART clock source selection */
;;;364            u32UartClkSrcSel = (CLK->CLKSEL1 & CLK_CLKSEL1_UART1SEL_Msk) >> CLK_CLKSEL1_UART1SEL_Pos;
00003c  f8d01214          LDR      r1,[r0,#0x214]
;;;365            /* Get UART clock divider number */
;;;366            u32UartClkDivNum = (CLK->CLKDIV0 & CLK_CLKDIV0_UART1DIV_Msk) >> CLK_CLKDIV0_UART1DIV_Pos;
000040  f8d00220          LDR      r0,[r0,#0x220]
000044  f3c16581          UBFX     r5,r1,#26,#2          ;364
000048  e02b              B        |L12.162|
                  |L12.74|
;;;367        }
;;;368        else if(uart==(UART_T*)UART2)
00004a  492e              LDR      r1,|L12.260|
00004c  428c              CMP      r4,r1
00004e  d108              BNE      |L12.98|
;;;369        {
;;;370            /* Get UART clock source selection */
;;;371            u32UartClkSrcSel = (CLK->CLKSEL3 & CLK_CLKSEL3_UART2SEL_Msk) >> CLK_CLKSEL3_UART2SEL_Pos;
000050  f8d0121c          LDR      r1,[r0,#0x21c]
;;;372            /* Get UART clock divider number */
;;;373            u32UartClkDivNum = (CLK->CLKDIV4 & CLK_CLKDIV4_UART2DIV_Msk) >> CLK_CLKDIV4_UART2DIV_Pos;
000054  f8d00230          LDR      r0,[r0,#0x230]
000058  f3c16501          UBFX     r5,r1,#24,#2          ;371
00005c  f000060f          AND      r6,r0,#0xf
000060  e021              B        |L12.166|
                  |L12.98|
;;;374        }
;;;375        else if(uart==(UART_T*)UART3)
000062  4929              LDR      r1,|L12.264|
000064  428c              CMP      r4,r1
000066  d108              BNE      |L12.122|
;;;376        {
;;;377            /* Get UART clock source selection */
;;;378            u32UartClkSrcSel = (CLK->CLKSEL3 & CLK_CLKSEL3_UART3SEL_Msk) >> CLK_CLKSEL3_UART3SEL_Pos;
000068  f8d0121c          LDR      r1,[r0,#0x21c]
;;;379            /* Get UART clock divider number */
;;;380            u32UartClkDivNum = (CLK->CLKDIV4 & CLK_CLKDIV4_UART3DIV_Msk) >> CLK_CLKDIV4_UART3DIV_Pos;
00006c  f8d00230          LDR      r0,[r0,#0x230]
000070  f3c16581          UBFX     r5,r1,#26,#2          ;378
000074  f3c01603          UBFX     r6,r0,#4,#4
000078  e015              B        |L12.166|
                  |L12.122|
;;;381        }
;;;382        else if(uart==(UART_T*)UART4)
00007a  4924              LDR      r1,|L12.268|
00007c  428c              CMP      r4,r1
00007e  d108              BNE      |L12.146|
;;;383        {
;;;384            /* Get UART clock source selection */
;;;385            u32UartClkSrcSel = (CLK->CLKSEL3 & CLK_CLKSEL3_UART4SEL_Msk) >> CLK_CLKSEL3_UART4SEL_Pos;
000080  f8d0121c          LDR      r1,[r0,#0x21c]
;;;386            /* Get UART clock divider number */
;;;387            u32UartClkDivNum = (CLK->CLKDIV4 & CLK_CLKDIV4_UART4DIV_Msk) >> CLK_CLKDIV4_UART4DIV_Pos;
000084  f8d00230          LDR      r0,[r0,#0x230]
000088  f3c17501          UBFX     r5,r1,#28,#2          ;385
                  |L12.140|
00008c  f3c02603          UBFX     r6,r0,#8,#4
000090  e009              B        |L12.166|
                  |L12.146|
;;;388        }
;;;389        else if(uart==(UART_T*)UART5)
000092  491f              LDR      r1,|L12.272|
000094  428c              CMP      r4,r1
000096  d10b              BNE      |L12.176|
;;;390        {
;;;391            /* Get UART clock source selection */
;;;392            u32UartClkSrcSel = (CLK->CLKSEL3 & CLK_CLKSEL3_UART5SEL_Msk) >> CLK_CLKSEL3_UART5SEL_Pos;
000098  f8d0121c          LDR      r1,[r0,#0x21c]
;;;393            /* Get UART clock divider number */
;;;394            u32UartClkDivNum = (CLK->CLKDIV4 & CLK_CLKDIV4_UART5DIV_Msk) >> CLK_CLKDIV4_UART5DIV_Pos;
00009c  f8d00230          LDR      r0,[r0,#0x230]
0000a0  0f8d              LSRS     r5,r1,#30             ;392
                  |L12.162|
0000a2  f3c03603          UBFX     r6,r0,#12,#4
                  |L12.166|
;;;395        }
;;;396    
;;;397        /* Get PLL clock frequency if UART clock source selection is PLL */
;;;398        if(u32UartClkSrcSel == 1ul)
0000a6  2d01              CMP      r5,#1
0000a8  d102              BNE      |L12.176|
;;;399        {
;;;400            u32ClkTbl[u32UartClkSrcSel] = CLK_GetPLLClockFreq();
0000aa  f7fffffe          BL       CLK_GetPLLClockFreq
0000ae  9001              STR      r0,[sp,#4]
                  |L12.176|
;;;401        }
;;;402        else
;;;403        {
;;;404        }
;;;405    
;;;406        /* Set UART baud rate */
;;;407        if(u32baudrate != 0ul)
0000b0  b1d7              CBZ      r7,|L12.232|
;;;408        {
;;;409            u32Baud_Div = UART_BAUD_MODE2_DIVIDER((u32ClkTbl[u32UartClkSrcSel]) / (u32UartClkDivNum + 1ul), u32baudrate);
0000b2  f8581025          LDR      r1,[r8,r5,LSL #2]
0000b6  1c76              ADDS     r6,r6,#1
0000b8  fbb1f0f6          UDIV     r0,r1,r6
0000bc  eb000057          ADD      r0,r0,r7,LSR #1
0000c0  fbb0f0f7          UDIV     r0,r0,r7
0000c4  1e80              SUBS     r0,r0,#2
;;;410    
;;;411            if(u32Baud_Div > 0xFFFFul)
0000c6  f5b03f80          CMP      r0,#0x10000
0000ca  d30a              BCC      |L12.226|
;;;412            {
;;;413                uart->BAUD = (UART_BAUD_MODE0 | UART_BAUD_MODE0_DIVIDER((u32ClkTbl[u32UartClkSrcSel]) / (u32UartClkDivNum + 1ul), u32baudrate));
0000cc  fbb1f0f6          UDIV     r0,r1,r6
0000d0  eb0000c7          ADD      r0,r0,r7,LSL #3
0000d4  fbb0f0f7          UDIV     r0,r0,r7
0000d8  f06f0101          MVN      r1,#1
0000dc  eb011010          ADD      r0,r1,r0,LSR #4
0000e0  e001              B        |L12.230|
                  |L12.226|
;;;414            }
;;;415            else
;;;416            {
;;;417                uart->BAUD = (UART_BAUD_MODE2 | u32Baud_Div);
0000e2  f0405040          ORR      r0,r0,#0x30000000
                  |L12.230|
0000e6  6260              STR      r0,[r4,#0x24]         ;413
                  |L12.232|
;;;418            }
;;;419        }
;;;420    
;;;421        /* Set UART line configuration */
;;;422        uart->LINE = u32data_width | u32parity | u32stop_bits;
0000e8  ea49000a          ORR      r0,r9,r10
0000ec  ea40000b          ORR      r0,r0,r11
0000f0  60e0              STR      r0,[r4,#0xc]
;;;423    }
0000f2  e8bd9fff          POP      {r0-r12,pc}
;;;424    
                          ENDP

0000f6  0000              DCW      0x0000
                  |L12.248|
                          DCD      ||.constdata||+0x10
                  |L12.252|
                          DCD      0x40070000
                  |L12.256|
                          DCD      0x40071000
                  |L12.260|
                          DCD      0x40072000
                  |L12.264|
                          DCD      0x40073000
                  |L12.268|
                          DCD      0x40074000
                  |L12.272|
                          DCD      0x40075000

                          AREA ||i.UART_SetTimeoutCnt||, CODE, READONLY, ALIGN=1

                  UART_SetTimeoutCnt PROC
;;;435     */
;;;436    void UART_SetTimeoutCnt(UART_T* uart, uint32_t u32TOC)
000000  6a02              LDR      r2,[r0,#0x20]
;;;437    {
;;;438        /* Set time-out interrupt comparator */
;;;439        uart->TOUT = (uart->TOUT & ~UART_TOUT_TOIC_Msk) | (u32TOC);
000002  f02202ff          BIC      r2,r2,#0xff
000006  430a              ORRS     r2,r2,r1
000008  6202              STR      r2,[r0,#0x20]
;;;440    
;;;441        /* Set time-out counter enable */
;;;442        uart->INTEN |= UART_INTEN_TOCNTEN_Msk;
00000a  6841              LDR      r1,[r0,#4]
00000c  f4416100          ORR      r1,r1,#0x800
000010  6041              STR      r1,[r0,#4]
;;;443    }
000012  4770              BX       lr
;;;444    
                          ENDP


                          AREA ||i.UART_Write||, CODE, READONLY, ALIGN=1

                  UART_Write PROC
;;;610     */
;;;611    uint32_t UART_Write(UART_T* uart, uint8_t pu8TxBuf[], uint32_t u32WriteBytes)
000000  b5f0              PUSH     {r4-r7,lr}
;;;612    {
000002  4604              MOV      r4,r0
;;;613        uint32_t  u32Count, u32delayno;
;;;614        uint32_t  u32Exit = 0ul;
000004  2600              MOVS     r6,#0
;;;615    
;;;616        for(u32Count = 0ul; u32Count != u32WriteBytes; u32Count++)
000006  4630              MOV      r0,r6
;;;617        {
;;;618            u32delayno = 0ul;
;;;619            while(uart->FIFOSTS & UART_FIFOSTS_TXFULL_Msk)   /* Check Tx Full */
;;;620            {
;;;621                u32delayno++;
;;;622                if(u32delayno >= 0x40000000ul)
000008  f04f4580          MOV      r5,#0x40000000
00000c  e00c              B        |L14.40|
                  |L14.14|
00000e  2300              MOVS     r3,#0                 ;618
000010  e002              B        |L14.24|
                  |L14.18|
000012  1c5b              ADDS     r3,r3,#1              ;619
000014  42ab              CMP      r3,r5
000016  d209              BCS      |L14.44|
                  |L14.24|
000018  69a7              LDR      r7,[r4,#0x18]         ;619
00001a  023f              LSLS     r7,r7,#8              ;619
00001c  d4f9              BMI      |L14.18|
;;;623                {
;;;624                    u32Exit = 1ul;
;;;625                    break;
;;;626                }
;;;627                else
;;;628                {
;;;629                }
;;;630            }
;;;631    
;;;632            if(u32Exit == 1ul)
00001e  2e00              CMP      r6,#0
000020  d104              BNE      |L14.44|
;;;633            {
;;;634                break;
;;;635            }
;;;636            else
;;;637            {
;;;638                uart->DAT = pu8TxBuf[u32Count];    /* Send UART Data from buffer */
000022  5c0b              LDRB     r3,[r1,r0]
000024  6023              STR      r3,[r4,#0]
000026  1c40              ADDS     r0,r0,#1
                  |L14.40|
000028  4290              CMP      r0,r2                 ;616
00002a  d1f0              BNE      |L14.14|
                  |L14.44|
;;;639            }
;;;640        }
;;;641    
;;;642        return u32Count;
;;;643    }
00002c  bdf0              POP      {r4-r7,pc}
;;;644    
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                          DCD      0x00b71b00
                          DCD      0x00000000
                          DCD      0x00008000
                          DCD      0x00b71b00
                          DCD      0x00b71b00
                          DCD      0x00000000
                          DCD      0x00008000
                          DCD      0x00b71b00
                          DCD      0x00b71b00
                          DCD      0x00000000
                          DCD      0x00008000
                          DCD      0x00b71b00

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\Library\\StdDriver\\src\\uart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_uart_c_f12f5b44____REV16|
#line 388 "..\\..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_uart_c_f12f5b44____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_uart_c_f12f5b44____REVSH|
#line 402
|__asm___6_uart_c_f12f5b44____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___6_uart_c_f12f5b44____RRX|
#line 587
|__asm___6_uart_c_f12f5b44____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
